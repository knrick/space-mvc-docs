{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Space MVC Framework The Space MVC PHP Framework is the fastest and most lightweight high performance, scalable, advanced PHP 7+ MVC framework available. How PHP works on servers When a client (browser) sends a request for a PHP page to the server, the server reads the requested file from the disk (storage) and sends this file to the interpreter. The interpreter then runs the PHP code, fetches the DB data (if required) and puts it into HTML tags. Once the interpreter completes its tasks, it sends the result back to the server, which sends this data to the client (browser) that made a request for this page. MVC architecture with PHP MVC, which stands for Model-View-Controller, is a really good way to develop clean, scalable, powerful and fast applications in the least amount of time and with the least effort. The Model-View-Controller concept involved in software development evolved in the late 1980s. Its a software architecture built on the idea that the logic of an application should be separated from its presentation. A system developed on the MVC architecture should allow a front-end developer and a back-end developer to work on the same system without interfering with each other. Model Model is the name given to the component that will communicate with the database to manipulate the data. It acts as a bridge between the View component and the Controller component in the overall architecture. It doesnt matter to the Model component what happens to the data when it is passed to the View or Controller components. View The View requests for data from the Model component and then its final output is determined. View interacts with the user, and then transfers the users reaction to the Controller component to respond accordingly. An example of this is a link generated by the View component, when a user clicks and an action gets triggered in the Controller. Controller The Controllers job is to handle data that the user inputs or submits through the forms, and then Model updates this accordingly in the database. The Controller is nothing without the users interactions, which happen through the View component.","title":"Introduction"},{"location":"#what-is-space-mvc-framework","text":"The Space MVC PHP Framework is the fastest and most lightweight high performance, scalable, advanced PHP 7+ MVC framework available.","title":"What is Space MVC Framework"},{"location":"#how-php-works-on-servers","text":"When a client (browser) sends a request for a PHP page to the server, the server reads the requested file from the disk (storage) and sends this file to the interpreter. The interpreter then runs the PHP code, fetches the DB data (if required) and puts it into HTML tags. Once the interpreter completes its tasks, it sends the result back to the server, which sends this data to the client (browser) that made a request for this page.","title":"How PHP works on servers"},{"location":"#mvc-architecture-with-php","text":"MVC, which stands for Model-View-Controller, is a really good way to develop clean, scalable, powerful and fast applications in the least amount of time and with the least effort. The Model-View-Controller concept involved in software development evolved in the late 1980s. Its a software architecture built on the idea that the logic of an application should be separated from its presentation. A system developed on the MVC architecture should allow a front-end developer and a back-end developer to work on the same system without interfering with each other.","title":"MVC architecture with PHP"},{"location":"#model","text":"Model is the name given to the component that will communicate with the database to manipulate the data. It acts as a bridge between the View component and the Controller component in the overall architecture. It doesnt matter to the Model component what happens to the data when it is passed to the View or Controller components.","title":"Model"},{"location":"#view","text":"The View requests for data from the Model component and then its final output is determined. View interacts with the user, and then transfers the users reaction to the Controller component to respond accordingly. An example of this is a link generated by the View component, when a user clicks and an action gets triggered in the Controller.","title":"View"},{"location":"#controller","text":"The Controllers job is to handle data that the user inputs or submits through the forms, and then Model updates this accordingly in the database. The Controller is nothing without the users interactions, which happen through the View component.","title":"Controller"},{"location":"asset/","text":"","title":"Asset"},{"location":"broadcasting/","text":"Broadcasting Introduction Configuration Driver Prerequisites Concept Overview Using An Example Application Defining Broadcast Events Broadcast Name Broadcast Data Broadcast Queue Broadcast Conditions Authorizing Channels Defining Authorization Routes Defining Authorization Callbacks Defining Channel Classes Broadcasting Events Only To Others Receiving Broadcasts Installing Space MVC Echo Listening For Events Leaving A Channel Namespaces Presence Channels Authorizing Presence Channels Joining Presence Channels Broadcasting To Presence Channels Client Events Notifications Introduction In many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client. This provides a more robust, efficient alternative to continually polling your application for changes. To assist you in building these types of applications, Space MVC makes it easy to \"broadcast\" your events over a WebSocket connection. Broadcasting your Space MVC events allows you to share the same event names between your server-side code and your client-side JavaScript application. Before diving into event broadcasting, make sure you have read all of the documentation regarding Space MVC events and listeners . Configuration All of your application's event broadcasting configuration is stored in the config/broadcasting.php configuration file. Space MVC supports several broadcast drivers out of the box: Pusher , Redis , and a log driver for local development and debugging. Additionally, a null driver is included which allows you to totally disable broadcasting. A configuration example is included for each of these drivers in the config/broadcasting.php configuration file. Broadcast Service Provider Before broadcasting any events, you will first need to register the App\\Providers\\BroadcastServiceProvider. In fresh Space MVC applications, you only need to uncomment this provider in the providers array of your config/app.php configuration file. This provider will allow you to register the broadcast authorization routes and callbacks. CSRF Token Space MVC Echo will need access to the current session's CSRF token. You should verify that your application's head HTML element defines a meta tag containing the CSRF token: meta name= csrf-token content= {{ csrf_token() }} Driver Prerequisites Pusher If you are broadcasting your events over Pusher , you should install the Pusher PHP SDK using the Composer package manager: composer require pusher/pusher-php-server ~3.0 Next, you should configure your Pusher credentials in the config/broadcasting.php configuration file. An example Pusher configuration is already included in this file, allowing you to quickly specify your Pusher key, secret, and application ID. The config/broadcasting.php file's pusher configuration also allows you to specify additional options that are supported by Pusher, such as the cluster: 'options' = [ 'cluster' = 'eu', 'encrypted' = true ], When using Pusher and Space MVC Echo , you should specify pusher as your desired broadcaster when instantiating the Echo instance in your resources/js/bootstrap.js file: import Echo from Space MVC-echo window.Pusher = require('pusher-js'); window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key' }); Redis If you are using the Redis broadcaster, you should install the Predis library: composer require predis/predis The Redis broadcaster will broadcast messages using Redis' pub / sub feature; however, you will need to pair this with a WebSocket server that can receive the messages from Redis and broadcast them to your WebSocket channels. When the Redis broadcaster publishes an event, it will be published on the event's specified channel names and the payload will be a JSON encoded string containing the event name, a data payload, and the user that generated the event's socket ID (if applicable). Socket.IO If you are going to pair the Redis broadcaster with a Socket.IO server, you will need to include the Socket.IO JavaScript client library in your application. You may install it via the NPM package manager: npm install --save socket.io-client Next, you will need to instantiate Echo with the socket.io connector and a host. import Echo from Space MVC-echo window.io = require('socket.io-client'); window.Echo = new Echo({ broadcaster: 'socket.io', host: window.location.hostname + ':6001' }); Finally, you will need to run a compatible Socket.IO server. Space MVC does not include a Socket.IO server implementation; however, a community driven Socket.IO server is currently maintained at the tlaverdure/Space MVC-echo-server GitHub repository. Queue Prerequisites Before broadcasting events, you will also need to configure and run a queue listener . All event broadcasting is done via queued jobs so that the response time of your application is not seriously affected. Concept Overview Space MVC's event broadcasting allows you to broadcast your server-side Space MVC events to your client-side JavaScript application using a driver-based approach to WebSockets. Currently, Space MVC ships with Pusher and Redis drivers. The events may be easily consumed on the client-side using the Space MVC Echo Javascript package. Events are broadcast over \"channels\", which may be specified as public or private. Any visitor to your application may subscribe to a public channel without any authentication or authorization; however, in order to subscribe to a private channel, a user must be authenticated and authorized to listen on that channel. Using An Example Application Before diving into each component of event broadcasting, let's take a high level overview using an e-commerce store as an example. We won't discuss the details of configuring Pusher or Space MVC Echo since that will be discussed in detail in other sections of this documentation. In our application, let's assume we have a page that allows users to view the shipping status for their orders. Let's also assume that a ShippingStatusUpdated event is fired when a shipping status update is processed by the application: event(new ShippingStatusUpdated($update)); The ShouldBroadcast Interface When a user is viewing one of their orders, we don't want them to have to refresh the page to view status updates. Instead, we want to broadcast the updates to the application as they are created. So, we need to mark the ShippingStatusUpdated event with the ShouldBroadcast interface. This will instruct Space MVC to broadcast the event when it is fired: ?php namespace App\\Events; use Illuminate\\Broadcasting\\Channel; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Broadcasting\\PrivateChannel; use Illuminate\\Broadcasting\\PresenceChannel; use Illuminate\\Broadcasting\\InteractsWithSockets; use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast; class ShippingStatusUpdated implements ShouldBroadcast { /** * Information about the shipping status update. * * @var string */ public $update; } The ShouldBroadcast interface requires our event to define a broadcastOn method. This method is responsible for returning the channels that the event should broadcast on. An empty stub of this method is already defined on generated event classes, so we only need to fill in its details. We only want the creator of the order to be able to view status updates, so we will broadcast the event on a private channel that is tied to the order: /** * Get the channels the event should broadcast on. * * @return array */ public function broadcastOn() { return new PrivateChannel('order.'.$this- update- order_id); } Authorizing Channels Remember, users must be authorized to listen on private channels. We may define our channel authorization rules in the routes/channels.php file. In this example, we need to verify that any user attempting to listen on the private order.1 channel is actually the creator of the order: Broadcast::channel('order.{orderId}', function ($user, $orderId) { return $user- id === Order::findOrNew($orderId)- user_id; }); The channel method accepts two arguments: the name of the channel and a callback which returns true or false indicating whether the user is authorized to listen on the channel. All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the {orderId} placeholder to indicate that the \"ID\" portion of the channel name is a wildcard. Listening For Event Broadcasts Next, all that remains is to listen for the event in our JavaScript application. We can do this using Space MVC Echo. First, we'll use the private method to subscribe to the private channel. Then, we may use the listen method to listen for the ShippingStatusUpdated event. By default, all of the event's public properties will be included on the broadcast event: Echo.private(`order.${orderId}`) .listen('ShippingStatusUpdated', (e) = { console.log(e.update); }); Defining Broadcast Events To inform Space MVC that a given event should be broadcast, implement the Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast interface on the event class. This interface is already imported into all event classes generated by the framework so you may easily add it to any of your events. The ShouldBroadcast interface requires you to implement a single method: broadcastOn. The broadcastOn method should return a channel or array of channels that the event should broadcast on. The channels should be instances of Channel, PrivateChannel, or PresenceChannel. Instances of Channel represent public channels that any user may subscribe to, while PrivateChannels and PresenceChannels represent private channels that require channel authorization : ?php namespace App\\Events; use Illuminate\\Broadcasting\\Channel; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Broadcasting\\PrivateChannel; use Illuminate\\Broadcasting\\PresenceChannel; use Illuminate\\Broadcasting\\InteractsWithSockets; use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast; class ServerCreated implements ShouldBroadcast { use SerializesModels; public $user; /** * Create a new event instance. * * @return void */ public function __construct(User $user) { $this- user = $user; } /** * Get the channels the event should broadcast on. * * @return Channel|array */ public function broadcastOn() { return new PrivateChannel('user.'.$this- user- id); } } Then, you only need to fire the event as you normally would. Once the event has been fired, a queued job will automatically broadcast the event over your specified broadcast driver. Broadcast Name By default, Space MVC will broadcast the event using the event's class name. However, you may customize the broadcast name by defining a broadcastAs method on the event: /** * The event's broadcast name. * * @return string */ public function broadcastAs() { return 'server.created'; } If you customize the broadcast name using the broadcastAs method, you should make sure to register your listener with a leading . character. This will instruct Echo to not prepend the application's namespace to the event: .listen('.server.created', function (e) { .... }); Broadcast Data When an event is broadcast, all of its public properties are automatically serialized and broadcast as the event's payload, allowing you to access any of its public data from your JavaScript application. So, for example, if your event has a single public $user property that contains an Eloquent model, the event's broadcast payload would be: { user : { id : 1, name : Patrick Stewart ... } } However, if you wish to have more fine-grained control over your broadcast payload, you may add a broadcastWith method to your event. This method should return the array of data that you wish to broadcast as the event payload: /** * Get the data to broadcast. * * @return array */ public function broadcastWith() { return ['id' = $this- user- id]; } Broadcast Queue By default, each broadcast event is placed on the default queue for the default queue connection specified in your queue.php configuration file. You may customize the queue used by the broadcaster by defining a broadcastQueue property on your event class. This property should specify the name of the queue you wish to use when broadcasting: /** * The name of the queue on which to place the event. * * @var string */ public $broadcastQueue = 'your-queue-name'; If you want to broadcast your event using the sync queue instead of the default queue driver, you can implement the ShouldBroadcastNow interface instead of ShouldBroadcast: ?php use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow; class ShippingStatusUpdated implements ShouldBroadcastNow { // } Broadcast Conditions Sometimes you want to broadcast your event only if a given condition is true. You may define these conditions by adding a broadcastWhen method to your event class: /** * Determine if this event should broadcast. * * @return bool */ public function broadcastWhen() { return $this- value 100; } Authorizing Channels Private channels require you to authorize that the currently authenticated user can actually listen on the channel. This is accomplished by making an HTTP request to your Space MVC application with the channel name and allowing your application to determine if the user can listen on that channel. When using Space MVC Echo , the HTTP request to authorize subscriptions to private channels will be made automatically; however, you do need to define the proper routes to respond to these requests. Defining Authorization Routes Thankfully, Space MVC makes it easy to define the routes to respond to channel authorization requests. In the BroadcastServiceProvider included with your Space MVC application, you will see a call to the Broadcast::routes method. This method will register the /broadcasting/auth route to handle authorization requests: Broadcast::routes(); The Broadcast::routes method will automatically place its routes within the web middleware group; however, you may pass an array of route attributes to the method if you would like to customize the assigned attributes: Broadcast::routes($attributes); Customizing The Authorization Endpoint By default, Echo will use the /broadcasting/auth endpoint to authorize channel access. However, you may specify your own authorization endpoint by passing the authEndpoint configuration option to your Echo instance: window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', authEndpoint: '/custom/endpoint/auth' }); Defining Authorization Callbacks Next, we need to define the logic that will actually perform the channel authorization. This is done in the routes/channels.php file that is included with your application. In this file, you may use the Broadcast::channel method to register channel authorization callbacks: Broadcast::channel('order.{orderId}', function ($user, $orderId) { return $user- id === Order::findOrNew($orderId)- user_id; }); The channel method accepts two arguments: the name of the channel and a callback which returns true or false indicating whether the user is authorized to listen on the channel. All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the {orderId} placeholder to indicate that the \"ID\" portion of the channel name is a wildcard. Authorization Callback Model Binding Just like HTTP routes, channel routes may also take advantage of implicit and explicit route model binding . For example, instead of receiving the string or numeric order ID, you may request an actual Order model instance: use App\\Order; Broadcast::channel('order.{order}', function ($user, Order $order) { return $user- id === $order- user_id; }); Defining Channel Classes If your application is consuming many different channels, your routes/channels.php file could become bulky. So, instead of using Closures to authorize channels, you may use channel classes. To generate a channel class, use the make:channel Artisan command. This command will place a new channel class in the App/Broadcasting directory. php artisan make:channel OrderChannel Next, register your channel in your routes/channels.php file: use App\\Broadcasting\\OrderChannel; Broadcast::channel('order.{order}', OrderChannel::class); Finally, you may place the authorization logic for your channel in the channel class' join method. This join method will house the same logic you would have typically placed in your channel authorization Closure. Of course, you may also take advantage of channel model binding: ?php namespace App\\Broadcasting; use App\\User; use App\\Order; class OrderChannel { /** * Create a new channel instance. * * @return void */ public function __construct() { // } /** * Authenticate the user's access to the channel. * * @param \\App\\User $user * @param \\App\\Order $order * @return array|bool */ public function join(User $user, Order $order) { return $user- id === $order- user_id; } } Like many other classes in Space MVC, channel classes will automatically be resolved by the service container . So, you may type-hint any dependencies required by your channel in its constructor. Broadcasting Events Once you have defined an event and marked it with the ShouldBroadcast interface, you only need to fire the event using the event function. The event dispatcher will notice that the event is marked with the ShouldBroadcast interface and will queue the event for broadcasting: event(new ShippingStatusUpdated($update)); Only To Others When building an application that utilizes event broadcasting, you may substitute the event function with the broadcast function. Like the event function, the broadcast function dispatches the event to your server-side listeners: broadcast(new ShippingStatusUpdated($update)); However, the broadcast function also exposes the toOthers method which allows you to exclude the current user from the broadcast's recipients: broadcast(new ShippingStatusUpdated($update))- toOthers(); To better understand when you may want to use the toOthers method, let's imagine a task list application where a user may create a new task by entering a task name. To create a task, your application might make a request to a /task end-point which broadcasts the task's creation and returns a JSON representation of the new task. When your JavaScript application receives the response from the end-point, it might directly insert the new task into its task list like so: axios.post('/task', task) .then((response) = { this.tasks.push(response.data); }); However, remember that we also broadcast the task's creation. If your JavaScript application is listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast. You may solve this by using the toOthers method to instruct the broadcaster to not broadcast the event to the current user. Your event must use the Illuminate\\Broadcasting\\InteractsWithSockets trait in order to call the toOthers method. Configuration When you initialize a Space MVC Echo instance, a socket ID is assigned to the connection. If you are using Vue and Axios , the socket ID will automatically be attached to every outgoing request as a X-Socket-ID header. Then, when you call the toOthers method, Space MVC will extract the socket ID from the header and instruct the broadcaster to not broadcast to any connections with that socket ID. If you are not using Vue and Axios, you will need to manually configure your JavaScript application to send the X-Socket-ID header. You may retrieve the socket ID using the Echo.socketId method: var socketId = Echo.socketId(); Receiving Broadcasts Installing Space MVC Echo Space MVC Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by Space MVC. You may install Echo via the NPM package manager. In this example, we will also install the pusher-js package since we will be using the Pusher broadcaster: npm install --save Space MVC-echo pusher-js Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do this is at the bottom of the resources/js/bootstrap.js file that is included with the Space MVC framework: import Echo from Space MVC-echo window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key' }); When creating an Echo instance that uses the pusher connector, you may also specify a cluster as well as whether the connection should be encrypted: window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', cluster: 'eu', encrypted: true }); Using An Existing Client Instance If you already have a Pusher or Socket.io client instance that you would like Echo to utilize, you may pass it to Echo via the client configuration option: const client = require('pusher-js'); window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', client: client }); Listening For Events Once you have installed and instantiated Echo, you are ready to start listening for event broadcasts. First, use the channel method to retrieve an instance of a channel, then call the listen method to listen for a specified event: Echo.channel('orders') .listen('OrderShipped', (e) = { console.log(e.order.name); }); If you would like to listen for events on a private channel, use the private method instead. You may continue to chain calls to the listen method to listen for multiple events on a single channel: Echo.private('orders') .listen(...) .listen(...) .listen(...); Leaving A Channel To leave a channel, you may call the leave method on your Echo instance: Echo.leave('orders'); Namespaces You may have noticed in the examples above that we did not specify the full namespace for the event classes. This is because Echo will automatically assume the events are located in the App\\Events namespace. However, you may configure the root namespace when you instantiate Echo by passing a namespace configuration option: window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', namespace: 'App.Other.Namespace' }); Alternatively, you may prefix event classes with a . when subscribing to them using Echo. This will allow you to always specify the fully-qualified class name: Echo.channel('orders') .listen('.Namespace.Event.Class', (e) = { // }); Presence Channels Presence channels build on the security of private channels while exposing the additional feature of awareness of who is subscribed to the channel. This makes it easy to build powerful, collaborative application features such as notifying users when another user is viewing the same page. Authorizing Presence Channels All presence channels are also private channels; therefore, users must be authorized to access them . However, when defining authorization callbacks for presence channels, you will not return true if the user is authorized to join the channel. Instead, you should return an array of data about the user. The data returned by the authorization callback will be made available to the presence channel event listeners in your JavaScript application. If the user is not authorized to join the presence channel, you should return false or null: Broadcast::channel('chat.{roomId}', function ($user, $roomId) { if ($user- canJoinRoom($roomId)) { return ['id' = $user- id, 'name' = $user- name]; } }); Joining Presence Channels To join a presence channel, you may use Echo's join method. The join method will return a PresenceChannel implementation which, along with exposing the listen method, allows you to subscribe to the here, joining, and leaving events. Echo.join(`chat.${roomId}`) .here((users) = { // }) .joining((user) = { console.log(user.name); }) .leaving((user) = { console.log(user.name); }); The here callback will be executed immediately once the channel is joined successfully, and will receive an array containing the user information for all of the other users currently subscribed to the channel. The joining method will be executed when a new user joins a channel, while the leaving method will be executed when a user leaves the channel. Broadcasting To Presence Channels Presence channels may receive events just like public or private channels. Using the example of a chatroom, we may want to broadcast NewMessage events to the room's presence channel. To do so, we'll return an instance of PresenceChannel from the event's broadcastOn method: /** * Get the channels the event should broadcast on. * * @return Channel|array */ public function broadcastOn() { return new PresenceChannel('room.'.$this- message- room_id); } Like public or private events, presence channel events may be broadcast using the broadcast function. As with other events, you may use the toOthers method to exclude the current user from receiving the broadcast: broadcast(new NewMessage($message)); broadcast(new NewMessage($message))- toOthers(); You may listen for the join event via Echo's listen method: Echo.join(`chat.${roomId}`) .here(...) .joining(...) .leaving(...) .listen('NewMessage', (e) = { // }); Client Events When using Pusher , you must enable the \"Client Events\" option in the \"App Settings\" section of your application dashboard in order to send client events. Sometimes you may wish to broadcast an event to other connected clients without hitting your Space MVC application at all. This can be particularly useful for things like \"typing\" notifications, where you want to alert users of your application that another user is typing a message on a given screen. To broadcast client events, you may use Echo's whisper method: Echo.private('chat') .whisper('typing', { name: this.user.name }); To listen for client events, you may use the listenForWhisper method: Echo.private('chat') .listenForWhisper('typing', (e) = { console.log(e.name); }); Notifications By pairing event broadcasting with notifications , your JavaScript application may receive new notifications as they occur without needing to refresh the page. First, be sure to read over the documentation on using the broadcast notification channel . Once you have configured a notification to use the broadcast channel, you may listen for the broadcast events using Echo's notification method. Remember, the channel name should match the class name of the entity receiving the notifications: Echo.private(`App.User.${userId}`) .notification((notification) = { console.log(notification.type); }); In this example, all notifications sent to App\\User instances via the broadcast channel would be received by the callback. A channel authorization callback for the App.User.{id} channel is included in the default BroadcastServiceProvider that ships with the Space MVC framework.","title":"Broadcasting"},{"location":"broadcasting/#broadcasting","text":"Introduction Configuration Driver Prerequisites Concept Overview Using An Example Application Defining Broadcast Events Broadcast Name Broadcast Data Broadcast Queue Broadcast Conditions Authorizing Channels Defining Authorization Routes Defining Authorization Callbacks Defining Channel Classes Broadcasting Events Only To Others Receiving Broadcasts Installing Space MVC Echo Listening For Events Leaving A Channel Namespaces Presence Channels Authorizing Presence Channels Joining Presence Channels Broadcasting To Presence Channels Client Events Notifications","title":"Broadcasting"},{"location":"broadcasting/#introduction","text":"In many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client. This provides a more robust, efficient alternative to continually polling your application for changes. To assist you in building these types of applications, Space MVC makes it easy to \"broadcast\" your events over a WebSocket connection. Broadcasting your Space MVC events allows you to share the same event names between your server-side code and your client-side JavaScript application. Before diving into event broadcasting, make sure you have read all of the documentation regarding Space MVC events and listeners .","title":"Introduction"},{"location":"broadcasting/#configuration","text":"All of your application's event broadcasting configuration is stored in the config/broadcasting.php configuration file. Space MVC supports several broadcast drivers out of the box: Pusher , Redis , and a log driver for local development and debugging. Additionally, a null driver is included which allows you to totally disable broadcasting. A configuration example is included for each of these drivers in the config/broadcasting.php configuration file.","title":"Configuration"},{"location":"broadcasting/#broadcast-service-provider","text":"Before broadcasting any events, you will first need to register the App\\Providers\\BroadcastServiceProvider. In fresh Space MVC applications, you only need to uncomment this provider in the providers array of your config/app.php configuration file. This provider will allow you to register the broadcast authorization routes and callbacks.","title":"Broadcast Service Provider"},{"location":"broadcasting/#csrf-token","text":"Space MVC Echo will need access to the current session's CSRF token. You should verify that your application's head HTML element defines a meta tag containing the CSRF token: meta name= csrf-token content= {{ csrf_token() }}","title":"CSRF Token"},{"location":"broadcasting/#driver-prerequisites","text":"","title":"Driver Prerequisites"},{"location":"broadcasting/#pusher","text":"If you are broadcasting your events over Pusher , you should install the Pusher PHP SDK using the Composer package manager: composer require pusher/pusher-php-server ~3.0 Next, you should configure your Pusher credentials in the config/broadcasting.php configuration file. An example Pusher configuration is already included in this file, allowing you to quickly specify your Pusher key, secret, and application ID. The config/broadcasting.php file's pusher configuration also allows you to specify additional options that are supported by Pusher, such as the cluster: 'options' = [ 'cluster' = 'eu', 'encrypted' = true ], When using Pusher and Space MVC Echo , you should specify pusher as your desired broadcaster when instantiating the Echo instance in your resources/js/bootstrap.js file: import Echo from Space MVC-echo window.Pusher = require('pusher-js'); window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key' });","title":"Pusher"},{"location":"broadcasting/#redis","text":"If you are using the Redis broadcaster, you should install the Predis library: composer require predis/predis The Redis broadcaster will broadcast messages using Redis' pub / sub feature; however, you will need to pair this with a WebSocket server that can receive the messages from Redis and broadcast them to your WebSocket channels. When the Redis broadcaster publishes an event, it will be published on the event's specified channel names and the payload will be a JSON encoded string containing the event name, a data payload, and the user that generated the event's socket ID (if applicable).","title":"Redis"},{"location":"broadcasting/#socketio","text":"If you are going to pair the Redis broadcaster with a Socket.IO server, you will need to include the Socket.IO JavaScript client library in your application. You may install it via the NPM package manager: npm install --save socket.io-client Next, you will need to instantiate Echo with the socket.io connector and a host. import Echo from Space MVC-echo window.io = require('socket.io-client'); window.Echo = new Echo({ broadcaster: 'socket.io', host: window.location.hostname + ':6001' }); Finally, you will need to run a compatible Socket.IO server. Space MVC does not include a Socket.IO server implementation; however, a community driven Socket.IO server is currently maintained at the tlaverdure/Space MVC-echo-server GitHub repository.","title":"Socket.IO"},{"location":"broadcasting/#queue-prerequisites","text":"Before broadcasting events, you will also need to configure and run a queue listener . All event broadcasting is done via queued jobs so that the response time of your application is not seriously affected.","title":"Queue Prerequisites"},{"location":"broadcasting/#concept-overview","text":"Space MVC's event broadcasting allows you to broadcast your server-side Space MVC events to your client-side JavaScript application using a driver-based approach to WebSockets. Currently, Space MVC ships with Pusher and Redis drivers. The events may be easily consumed on the client-side using the Space MVC Echo Javascript package. Events are broadcast over \"channels\", which may be specified as public or private. Any visitor to your application may subscribe to a public channel without any authentication or authorization; however, in order to subscribe to a private channel, a user must be authenticated and authorized to listen on that channel.","title":"Concept Overview"},{"location":"broadcasting/#using-an-example-application","text":"Before diving into each component of event broadcasting, let's take a high level overview using an e-commerce store as an example. We won't discuss the details of configuring Pusher or Space MVC Echo since that will be discussed in detail in other sections of this documentation. In our application, let's assume we have a page that allows users to view the shipping status for their orders. Let's also assume that a ShippingStatusUpdated event is fired when a shipping status update is processed by the application: event(new ShippingStatusUpdated($update));","title":"Using An Example Application"},{"location":"broadcasting/#the-shouldbroadcast-interface","text":"When a user is viewing one of their orders, we don't want them to have to refresh the page to view status updates. Instead, we want to broadcast the updates to the application as they are created. So, we need to mark the ShippingStatusUpdated event with the ShouldBroadcast interface. This will instruct Space MVC to broadcast the event when it is fired: ?php namespace App\\Events; use Illuminate\\Broadcasting\\Channel; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Broadcasting\\PrivateChannel; use Illuminate\\Broadcasting\\PresenceChannel; use Illuminate\\Broadcasting\\InteractsWithSockets; use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast; class ShippingStatusUpdated implements ShouldBroadcast { /** * Information about the shipping status update. * * @var string */ public $update; } The ShouldBroadcast interface requires our event to define a broadcastOn method. This method is responsible for returning the channels that the event should broadcast on. An empty stub of this method is already defined on generated event classes, so we only need to fill in its details. We only want the creator of the order to be able to view status updates, so we will broadcast the event on a private channel that is tied to the order: /** * Get the channels the event should broadcast on. * * @return array */ public function broadcastOn() { return new PrivateChannel('order.'.$this- update- order_id); }","title":"The ShouldBroadcast Interface"},{"location":"broadcasting/#authorizing-channels","text":"Remember, users must be authorized to listen on private channels. We may define our channel authorization rules in the routes/channels.php file. In this example, we need to verify that any user attempting to listen on the private order.1 channel is actually the creator of the order: Broadcast::channel('order.{orderId}', function ($user, $orderId) { return $user- id === Order::findOrNew($orderId)- user_id; }); The channel method accepts two arguments: the name of the channel and a callback which returns true or false indicating whether the user is authorized to listen on the channel. All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the {orderId} placeholder to indicate that the \"ID\" portion of the channel name is a wildcard.","title":"Authorizing Channels"},{"location":"broadcasting/#listening-for-event-broadcasts","text":"Next, all that remains is to listen for the event in our JavaScript application. We can do this using Space MVC Echo. First, we'll use the private method to subscribe to the private channel. Then, we may use the listen method to listen for the ShippingStatusUpdated event. By default, all of the event's public properties will be included on the broadcast event: Echo.private(`order.${orderId}`) .listen('ShippingStatusUpdated', (e) = { console.log(e.update); });","title":"Listening For Event Broadcasts"},{"location":"broadcasting/#defining-broadcast-events","text":"To inform Space MVC that a given event should be broadcast, implement the Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast interface on the event class. This interface is already imported into all event classes generated by the framework so you may easily add it to any of your events. The ShouldBroadcast interface requires you to implement a single method: broadcastOn. The broadcastOn method should return a channel or array of channels that the event should broadcast on. The channels should be instances of Channel, PrivateChannel, or PresenceChannel. Instances of Channel represent public channels that any user may subscribe to, while PrivateChannels and PresenceChannels represent private channels that require channel authorization : ?php namespace App\\Events; use Illuminate\\Broadcasting\\Channel; use Illuminate\\Queue\\SerializesModels; use Illuminate\\Broadcasting\\PrivateChannel; use Illuminate\\Broadcasting\\PresenceChannel; use Illuminate\\Broadcasting\\InteractsWithSockets; use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast; class ServerCreated implements ShouldBroadcast { use SerializesModels; public $user; /** * Create a new event instance. * * @return void */ public function __construct(User $user) { $this- user = $user; } /** * Get the channels the event should broadcast on. * * @return Channel|array */ public function broadcastOn() { return new PrivateChannel('user.'.$this- user- id); } } Then, you only need to fire the event as you normally would. Once the event has been fired, a queued job will automatically broadcast the event over your specified broadcast driver.","title":"Defining Broadcast Events"},{"location":"broadcasting/#broadcast-name","text":"By default, Space MVC will broadcast the event using the event's class name. However, you may customize the broadcast name by defining a broadcastAs method on the event: /** * The event's broadcast name. * * @return string */ public function broadcastAs() { return 'server.created'; } If you customize the broadcast name using the broadcastAs method, you should make sure to register your listener with a leading . character. This will instruct Echo to not prepend the application's namespace to the event: .listen('.server.created', function (e) { .... });","title":"Broadcast Name"},{"location":"broadcasting/#broadcast-data","text":"When an event is broadcast, all of its public properties are automatically serialized and broadcast as the event's payload, allowing you to access any of its public data from your JavaScript application. So, for example, if your event has a single public $user property that contains an Eloquent model, the event's broadcast payload would be: { user : { id : 1, name : Patrick Stewart ... } } However, if you wish to have more fine-grained control over your broadcast payload, you may add a broadcastWith method to your event. This method should return the array of data that you wish to broadcast as the event payload: /** * Get the data to broadcast. * * @return array */ public function broadcastWith() { return ['id' = $this- user- id]; }","title":"Broadcast Data"},{"location":"broadcasting/#broadcast-queue","text":"By default, each broadcast event is placed on the default queue for the default queue connection specified in your queue.php configuration file. You may customize the queue used by the broadcaster by defining a broadcastQueue property on your event class. This property should specify the name of the queue you wish to use when broadcasting: /** * The name of the queue on which to place the event. * * @var string */ public $broadcastQueue = 'your-queue-name'; If you want to broadcast your event using the sync queue instead of the default queue driver, you can implement the ShouldBroadcastNow interface instead of ShouldBroadcast: ?php use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow; class ShippingStatusUpdated implements ShouldBroadcastNow { // }","title":"Broadcast Queue"},{"location":"broadcasting/#broadcast-conditions","text":"Sometimes you want to broadcast your event only if a given condition is true. You may define these conditions by adding a broadcastWhen method to your event class: /** * Determine if this event should broadcast. * * @return bool */ public function broadcastWhen() { return $this- value 100; }","title":"Broadcast Conditions"},{"location":"broadcasting/#authorizing-channels_1","text":"Private channels require you to authorize that the currently authenticated user can actually listen on the channel. This is accomplished by making an HTTP request to your Space MVC application with the channel name and allowing your application to determine if the user can listen on that channel. When using Space MVC Echo , the HTTP request to authorize subscriptions to private channels will be made automatically; however, you do need to define the proper routes to respond to these requests.","title":"Authorizing Channels"},{"location":"broadcasting/#defining-authorization-routes","text":"Thankfully, Space MVC makes it easy to define the routes to respond to channel authorization requests. In the BroadcastServiceProvider included with your Space MVC application, you will see a call to the Broadcast::routes method. This method will register the /broadcasting/auth route to handle authorization requests: Broadcast::routes(); The Broadcast::routes method will automatically place its routes within the web middleware group; however, you may pass an array of route attributes to the method if you would like to customize the assigned attributes: Broadcast::routes($attributes);","title":"Defining Authorization Routes"},{"location":"broadcasting/#customizing-the-authorization-endpoint","text":"By default, Echo will use the /broadcasting/auth endpoint to authorize channel access. However, you may specify your own authorization endpoint by passing the authEndpoint configuration option to your Echo instance: window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', authEndpoint: '/custom/endpoint/auth' });","title":"Customizing The Authorization Endpoint"},{"location":"broadcasting/#defining-authorization-callbacks","text":"Next, we need to define the logic that will actually perform the channel authorization. This is done in the routes/channels.php file that is included with your application. In this file, you may use the Broadcast::channel method to register channel authorization callbacks: Broadcast::channel('order.{orderId}', function ($user, $orderId) { return $user- id === Order::findOrNew($orderId)- user_id; }); The channel method accepts two arguments: the name of the channel and a callback which returns true or false indicating whether the user is authorized to listen on the channel. All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the {orderId} placeholder to indicate that the \"ID\" portion of the channel name is a wildcard.","title":"Defining Authorization Callbacks"},{"location":"broadcasting/#authorization-callback-model-binding","text":"Just like HTTP routes, channel routes may also take advantage of implicit and explicit route model binding . For example, instead of receiving the string or numeric order ID, you may request an actual Order model instance: use App\\Order; Broadcast::channel('order.{order}', function ($user, Order $order) { return $user- id === $order- user_id; });","title":"Authorization Callback Model Binding"},{"location":"broadcasting/#defining-channel-classes","text":"If your application is consuming many different channels, your routes/channels.php file could become bulky. So, instead of using Closures to authorize channels, you may use channel classes. To generate a channel class, use the make:channel Artisan command. This command will place a new channel class in the App/Broadcasting directory. php artisan make:channel OrderChannel Next, register your channel in your routes/channels.php file: use App\\Broadcasting\\OrderChannel; Broadcast::channel('order.{order}', OrderChannel::class); Finally, you may place the authorization logic for your channel in the channel class' join method. This join method will house the same logic you would have typically placed in your channel authorization Closure. Of course, you may also take advantage of channel model binding: ?php namespace App\\Broadcasting; use App\\User; use App\\Order; class OrderChannel { /** * Create a new channel instance. * * @return void */ public function __construct() { // } /** * Authenticate the user's access to the channel. * * @param \\App\\User $user * @param \\App\\Order $order * @return array|bool */ public function join(User $user, Order $order) { return $user- id === $order- user_id; } } Like many other classes in Space MVC, channel classes will automatically be resolved by the service container . So, you may type-hint any dependencies required by your channel in its constructor.","title":"Defining Channel Classes"},{"location":"broadcasting/#broadcasting-events","text":"Once you have defined an event and marked it with the ShouldBroadcast interface, you only need to fire the event using the event function. The event dispatcher will notice that the event is marked with the ShouldBroadcast interface and will queue the event for broadcasting: event(new ShippingStatusUpdated($update));","title":"Broadcasting Events"},{"location":"broadcasting/#only-to-others","text":"When building an application that utilizes event broadcasting, you may substitute the event function with the broadcast function. Like the event function, the broadcast function dispatches the event to your server-side listeners: broadcast(new ShippingStatusUpdated($update)); However, the broadcast function also exposes the toOthers method which allows you to exclude the current user from the broadcast's recipients: broadcast(new ShippingStatusUpdated($update))- toOthers(); To better understand when you may want to use the toOthers method, let's imagine a task list application where a user may create a new task by entering a task name. To create a task, your application might make a request to a /task end-point which broadcasts the task's creation and returns a JSON representation of the new task. When your JavaScript application receives the response from the end-point, it might directly insert the new task into its task list like so: axios.post('/task', task) .then((response) = { this.tasks.push(response.data); }); However, remember that we also broadcast the task's creation. If your JavaScript application is listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast. You may solve this by using the toOthers method to instruct the broadcaster to not broadcast the event to the current user. Your event must use the Illuminate\\Broadcasting\\InteractsWithSockets trait in order to call the toOthers method.","title":"Only To Others"},{"location":"broadcasting/#configuration_1","text":"When you initialize a Space MVC Echo instance, a socket ID is assigned to the connection. If you are using Vue and Axios , the socket ID will automatically be attached to every outgoing request as a X-Socket-ID header. Then, when you call the toOthers method, Space MVC will extract the socket ID from the header and instruct the broadcaster to not broadcast to any connections with that socket ID. If you are not using Vue and Axios, you will need to manually configure your JavaScript application to send the X-Socket-ID header. You may retrieve the socket ID using the Echo.socketId method: var socketId = Echo.socketId();","title":"Configuration"},{"location":"broadcasting/#receiving-broadcasts","text":"","title":"Receiving Broadcasts"},{"location":"broadcasting/#installing-space-mvc-echo","text":"Space MVC Echo is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by Space MVC. You may install Echo via the NPM package manager. In this example, we will also install the pusher-js package since we will be using the Pusher broadcaster: npm install --save Space MVC-echo pusher-js Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do this is at the bottom of the resources/js/bootstrap.js file that is included with the Space MVC framework: import Echo from Space MVC-echo window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key' }); When creating an Echo instance that uses the pusher connector, you may also specify a cluster as well as whether the connection should be encrypted: window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', cluster: 'eu', encrypted: true });","title":"Installing Space MVC Echo"},{"location":"broadcasting/#using-an-existing-client-instance","text":"If you already have a Pusher or Socket.io client instance that you would like Echo to utilize, you may pass it to Echo via the client configuration option: const client = require('pusher-js'); window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', client: client });","title":"Using An Existing Client Instance"},{"location":"broadcasting/#listening-for-events","text":"Once you have installed and instantiated Echo, you are ready to start listening for event broadcasts. First, use the channel method to retrieve an instance of a channel, then call the listen method to listen for a specified event: Echo.channel('orders') .listen('OrderShipped', (e) = { console.log(e.order.name); }); If you would like to listen for events on a private channel, use the private method instead. You may continue to chain calls to the listen method to listen for multiple events on a single channel: Echo.private('orders') .listen(...) .listen(...) .listen(...);","title":"Listening For Events"},{"location":"broadcasting/#leaving-a-channel","text":"To leave a channel, you may call the leave method on your Echo instance: Echo.leave('orders');","title":"Leaving A Channel"},{"location":"broadcasting/#namespaces","text":"You may have noticed in the examples above that we did not specify the full namespace for the event classes. This is because Echo will automatically assume the events are located in the App\\Events namespace. However, you may configure the root namespace when you instantiate Echo by passing a namespace configuration option: window.Echo = new Echo({ broadcaster: 'pusher', key: 'your-pusher-key', namespace: 'App.Other.Namespace' }); Alternatively, you may prefix event classes with a . when subscribing to them using Echo. This will allow you to always specify the fully-qualified class name: Echo.channel('orders') .listen('.Namespace.Event.Class', (e) = { // });","title":"Namespaces"},{"location":"broadcasting/#presence-channels","text":"Presence channels build on the security of private channels while exposing the additional feature of awareness of who is subscribed to the channel. This makes it easy to build powerful, collaborative application features such as notifying users when another user is viewing the same page.","title":"Presence Channels"},{"location":"broadcasting/#authorizing-presence-channels","text":"All presence channels are also private channels; therefore, users must be authorized to access them . However, when defining authorization callbacks for presence channels, you will not return true if the user is authorized to join the channel. Instead, you should return an array of data about the user. The data returned by the authorization callback will be made available to the presence channel event listeners in your JavaScript application. If the user is not authorized to join the presence channel, you should return false or null: Broadcast::channel('chat.{roomId}', function ($user, $roomId) { if ($user- canJoinRoom($roomId)) { return ['id' = $user- id, 'name' = $user- name]; } });","title":"Authorizing Presence Channels"},{"location":"broadcasting/#joining-presence-channels","text":"To join a presence channel, you may use Echo's join method. The join method will return a PresenceChannel implementation which, along with exposing the listen method, allows you to subscribe to the here, joining, and leaving events. Echo.join(`chat.${roomId}`) .here((users) = { // }) .joining((user) = { console.log(user.name); }) .leaving((user) = { console.log(user.name); }); The here callback will be executed immediately once the channel is joined successfully, and will receive an array containing the user information for all of the other users currently subscribed to the channel. The joining method will be executed when a new user joins a channel, while the leaving method will be executed when a user leaves the channel.","title":"Joining Presence Channels"},{"location":"broadcasting/#broadcasting-to-presence-channels","text":"Presence channels may receive events just like public or private channels. Using the example of a chatroom, we may want to broadcast NewMessage events to the room's presence channel. To do so, we'll return an instance of PresenceChannel from the event's broadcastOn method: /** * Get the channels the event should broadcast on. * * @return Channel|array */ public function broadcastOn() { return new PresenceChannel('room.'.$this- message- room_id); } Like public or private events, presence channel events may be broadcast using the broadcast function. As with other events, you may use the toOthers method to exclude the current user from receiving the broadcast: broadcast(new NewMessage($message)); broadcast(new NewMessage($message))- toOthers(); You may listen for the join event via Echo's listen method: Echo.join(`chat.${roomId}`) .here(...) .joining(...) .leaving(...) .listen('NewMessage', (e) = { // });","title":"Broadcasting To Presence Channels"},{"location":"broadcasting/#client-events","text":"When using Pusher , you must enable the \"Client Events\" option in the \"App Settings\" section of your application dashboard in order to send client events. Sometimes you may wish to broadcast an event to other connected clients without hitting your Space MVC application at all. This can be particularly useful for things like \"typing\" notifications, where you want to alert users of your application that another user is typing a message on a given screen. To broadcast client events, you may use Echo's whisper method: Echo.private('chat') .whisper('typing', { name: this.user.name }); To listen for client events, you may use the listenForWhisper method: Echo.private('chat') .listenForWhisper('typing', (e) = { console.log(e.name); });","title":"Client Events"},{"location":"broadcasting/#notifications","text":"By pairing event broadcasting with notifications , your JavaScript application may receive new notifications as they occur without needing to refresh the page. First, be sure to read over the documentation on using the broadcast notification channel . Once you have configured a notification to use the broadcast channel, you may listen for the broadcast events using Echo's notification method. Remember, the channel name should match the class name of the entity receiving the notifications: Echo.private(`App.User.${userId}`) .notification((notification) = { console.log(notification.type); }); In this example, all notifications sent to App\\User instances via the broadcast channel would be received by the callback. A channel authorization callback for the App.User.{id} channel is included in the default BroadcastServiceProvider that ships with the Space MVC framework.","title":"Notifications"},{"location":"cache/","text":"Cache Configuration Space MVC provides an expressive, unified API for various caching backends. The cache configuration is located at config/cache.php. In this file you may specify which cache driver you would like to be used by default throughout your application. Space MVC supports popular caching backends like Memcached and Redis out of the box. The cache configuration file also contains various other options, which are documented within the file, so make sure to read over these options. By default, Space MVC is configured to use the file cache driver, which stores the serialized, cached objects in the filesystem. For larger applications, it is recommended that you use a more robust driver such as Memcached or Redis. You may even configure multiple cache configurations for the same driver. Driver Prerequisites Database When using the database cache driver, you will need to setup a table to contain the cache items. You'll find an example Schema declaration for the table below: Schema::create('cache', function ($table) { $table- string('key')- unique(); $table- text('value'); $table- integer('expiration'); }); You may also use the php artisan cache:table Artisan command to generate a migration with the proper schema. Memcached Using the Memcached driver requires the Memcached PECL package to be installed. You may list all of your Memcached servers in the config/cache.php configuration file: 'memcached' = [ [ 'host' = '127.0.0.1', 'port' = 11211, 'weight' = 100 ], ], You may also set the host option to a UNIX socket path. If you do this, the port option should be set to 0: 'memcached' = [ [ 'host' = '/var/run/memcached/memcached.sock', 'port' = 0, 'weight' = 100 ], ], Redis Before using a Redis cache with Space MVC, you will need to either install the predis/predis package (~1.0) via Composer or install the PhpRedis PHP extension via PECL. For more information on configuring Redis, consult its Space MVC documentation page . Cache Usage Obtaining A Cache Instance The Illuminate\\Contracts\\Cache\\Factory and Illuminate\\Contracts\\Cache\\Repository contracts provide access to Space MVC's cache services. The Factory contract provides access to all cache drivers defined for your application. The Repository contract is typically an implementation of the default cache driver for your application as specified by your cache configuration file. However, you may also use the Cache facade, which is what we will use throughout this documentation. The Cache facade provides convenient, terse access to the underlying implementations of the Space MVC cache contracts: ?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\Cache; class UserController extends Controller { /** * Show a list of all users of the application. * * @return Response */ public function index() { $value = Cache::get('key'); // } } Accessing Multiple Cache Stores Using the Cache facade, you may access various cache stores via the store method. The key passed to the store method should correspond to one of the stores listed in the stores configuration array in your cache configuration file: $value = Cache::store('file')- get('foo'); Cache::store('redis')- put('bar', 'baz', 10); Retrieving Items From The Cache The get method on the Cache facade is used to retrieve items from the cache. If the item does not exist in the cache, null will be returned. If you wish, you may pass a second argument to the get method specifying the default value you wish to be returned if the item doesn't exist: $value = Cache::get('key'); $value = Cache::get('key', 'default'); You may even pass a Closure as the default value. The result of the Closure will be returned if the specified item does not exist in the cache. Passing a Closure allows you to defer the retrieval of default values from a database or other external service: $value = Cache::get('key', function () { return DB::table(...)- get(); }); Checking For Item Existence The has method may be used to determine if an item exists in the cache. This method will return false if the value is null or false: if (Cache::has('key')) { // } Incrementing / Decrementing Values The increment and decrement methods may be used to adjust the value of integer items in the cache. Both of these methods accept an optional second argument indicating the amount by which to increment or decrement the item's value: Cache::increment('key'); Cache::increment('key', $amount); Cache::decrement('key'); Cache::decrement('key', $amount); Retrieve Store Sometimes you may wish to retrieve an item from the cache, but also store a default value if the requested item doesn't exist. For example, you may wish to retrieve all users from the cache or, if they don't exist, retrieve them from the database and add them to the cache. You may do this using the Cache::remember method: $value = Cache::remember('users', $minutes, function () { return DB::table('users')- get(); }); If the item does not exist in the cache, the Closure passed to the remember method will be executed and its result will be placed in the cache. You may use the rememberForever method to retrieve an item from the cache or store it forever: $value = Cache::rememberForever('users', function () { return DB::table('users')- get(); }); Retrieve Delete If you need to retrieve an item from the cache and then delete the item, you may use the pull method. Like the get method, null will be returned if the item does not exist in the cache: $value = Cache::pull('key'); Storing Items In The Cache You may use the put method on the Cache facade to store items in the cache. When you place an item in the cache, you need to specify the number of minutes for which the value should be cached: Cache::put('key', 'value', $minutes); Instead of passing the number of minutes as an integer, you may also pass a DateTime instance representing the expiration time of the cached item: $expiresAt = now()- addMinutes(10); Cache::put('key', 'value', $expiresAt); Store If Not Present The add method will only add the item to the cache if it does not already exist in the cache store. The method will return true if the item is actually added to the cache. Otherwise, the method will return false: Cache::add('key', 'value', $minutes); Storing Items Forever The forever method may be used to store an item in the cache permanently. Since these items will not expire, they must be manually removed from the cache using the forget method: Cache::forever('key', 'value'); If you are using the Memcached driver, items that are stored \"forever\" may be removed when the cache reaches its size limit. Removing Items From The Cache You may remove items from the cache using the forget method: Cache::forget('key'); You may clear the entire cache using the flush method: Cache::flush(); Flushing the cache does not respect the cache prefix and will remove all entries from the cache. Consider this carefully when clearing a cache which is shared by other applications. Atomic Locks To utilize this feature, your application must be using the memcached or redis cache driver as your application's default cache driver. In addition, all servers must be communicating with the same central cache server. Atomic locks allow for the manipulation of distributed locks without worrying about race conditions. For example, Space MVC uses atomic locks to ensure that only one remote task is being executed on a server at a time. You may create and manage locks using the Cache::lock method: if (Cache::lock('foo', 10)- get()) { // Lock acquired for 10 seconds... Cache::lock('foo')- release(); } The get method also accepts a Closure. After the Closure is executed, Space MVC will automatically release the lock: Cache::lock('foo')- get(function () { // Lock acquired indefinitely and automatically released... }); If the lock is not available at the moment you request it, you may instruct Space MVC to wait for a specified number of seconds. If the lock can not be acquired within the specified time limit, an Illuminate\\Contracts\\Cache\\LockTimeoutException will be thrown: if (Cache::lock('foo', 10)- block(5)) { // Lock acquired after waiting maximum of 5 seconds... } Cache::lock('foo', 10)- block(5, function () { // Lock acquired after waiting maximum of 5 seconds... }); The Cache Helper In addition to using the Cache facade or cache contract , you may also use the global cache function to retrieve and store data via the cache. When the cache function is called with a single, string argument, it will return the value of the given key: $value = cache('key'); If you provide an array of key / value pairs and an expiration time to the function, it will store values in the cache for the specified duration: cache(['key' = 'value'], $minutes); cache(['key' = 'value'], now()- addSeconds(10)); When the cache function is called without any arguments, it returns an instance of the Illuminate\\Contracts\\Cache\\Factory implementation, allowing you to all other caching methods: cache()- remember('users', $minutes, function () { return DB::table('users')- get(); }); When testing call to the global cache function, you may use the Cache::shouldReceive method just as if you were testing a facade . Cache Tags Cache tags are not supported when using the file or database cache drivers. Furthermore, when using multiple tags with caches that are stored \"forever\", performance will be best with a driver such as memcached, which automatically purges stale records. Storing Tagged Cache Items Cache tags allow you to tag related items in the cache and then flush all cached values that have been assigned a given tag. You may access a tagged cache by passing in an ordered array of tag names. For example, let's access a tagged cache and put value in the cache: Cache::tags(['people', 'artists'])- put('John', $john, $minutes); Cache::tags(['people', 'authors'])- put('Anne', $anne, $minutes); Accessing Tagged Cache Items To retrieve a tagged cache item, pass the same ordered list of tags to the tags method and then call the get method with the key you wish to retrieve: $john = Cache::tags(['people', 'artists'])- get('John'); $anne = Cache::tags(['people', 'authors'])- get('Anne'); Removing Tagged Cache Items You may flush all items that are assigned a tag or list of tags. For example, this statement would remove all caches tagged with either people, authors, or both. So, both Anne and John would be removed from the cache: Cache::tags(['people', 'authors'])- flush(); In contrast, this statement would remove only caches tagged with authors, so Anne would be removed, but not John: Cache::tags('authors')- flush(); Adding Custom Cache Drivers Writing The Driver To create our custom cache driver, we first need to implement the Illuminate\\Contracts\\Cache\\Store contract . So, a MongoDB cache implementation would look something like this: ?php namespace App\\Extensions; use Illuminate\\Contracts\\Cache\\Store; class MongoStore implements Store { public function get($key) {} public function many(array $keys); public function put($key, $value, $minutes) {} public function putMany(array $values, $minutes); public function increment($key, $value = 1) {} public function decrement($key, $value = 1) {} public function forever($key, $value) {} public function forget($key) {} public function flush() {} public function getPrefix() {} } We just need to implement each of these methods using a MongoDB connection. For an example of how to implement each of these methods, take a look at the Illuminate\\Cache\\MemcachedStore in the framework source code. Once our implementation is complete, we can finish our custom driver registration. Cache::extend('mongo', function ($app) { return Cache::repository(new MongoStore); }); If you're wondering where to put your custom cache driver code, you could create an Extensions namespace within your app directory. However, keep in mind that Space MVC does not have a rigid application structure and you are free to organize your application according to your preferences. Registering The Driver To register the custom cache driver with Space MVC, we will use the extend method on the Cache facade. The call to Cache::extend could be done in the boot method of the default App\\Providers\\AppServiceProvider that ships with fresh Space MVC applications, or you may create your own service provider to house the extension - just don't forget to register the provider in the config/app.php provider array: ?php namespace App\\Providers; use App\\Extensions\\MongoStore; use Illuminate\\Support\\Facades\\Cache; use Illuminate\\Support\\ServiceProvider; class CacheServiceProvider extends ServiceProvider { /** * Perform post-registration booting of services. * * @return void */ public function boot() { Cache::extend('mongo', function ($app) { return Cache::repository(new MongoStore); }); } /** * Register bindings in the container. * * @return void */ public function register() { // } } The first argument passed to the extend method is the name of the driver. This will correspond to your driver option in the config/cache.php configuration file. The second argument is a Closure that should return an Illuminate\\Cache\\Repository instance. The Closure will be passed an $app instance, which is an instance of the service container . Once your extension is registered, update your config/cache.php configuration file's driver option to the name of your extension. Events To execute code on every cache operation, you may listen for the events fired by the cache. Typically, you should place these event listeners within your EventServiceProvider: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'Illuminate\\Cache\\Events\\CacheHit' = [ 'App\\Listeners\\LogCacheHit', ], 'Illuminate\\Cache\\Events\\CacheMissed' = [ 'App\\Listeners\\LogCacheMissed', ], 'Illuminate\\Cache\\Events\\KeyForgotten' = [ 'App\\Listeners\\LogKeyForgotten', ], 'Illuminate\\Cache\\Events\\KeyWritten' = [ 'App\\Listeners\\LogKeyWritten', ], ];","title":"Cache"},{"location":"cache/#cache","text":"","title":"Cache"},{"location":"cache/#configuration","text":"Space MVC provides an expressive, unified API for various caching backends. The cache configuration is located at config/cache.php. In this file you may specify which cache driver you would like to be used by default throughout your application. Space MVC supports popular caching backends like Memcached and Redis out of the box. The cache configuration file also contains various other options, which are documented within the file, so make sure to read over these options. By default, Space MVC is configured to use the file cache driver, which stores the serialized, cached objects in the filesystem. For larger applications, it is recommended that you use a more robust driver such as Memcached or Redis. You may even configure multiple cache configurations for the same driver.","title":"Configuration"},{"location":"cache/#driver-prerequisites","text":"","title":"Driver Prerequisites"},{"location":"cache/#database","text":"When using the database cache driver, you will need to setup a table to contain the cache items. You'll find an example Schema declaration for the table below: Schema::create('cache', function ($table) { $table- string('key')- unique(); $table- text('value'); $table- integer('expiration'); }); You may also use the php artisan cache:table Artisan command to generate a migration with the proper schema.","title":"Database"},{"location":"cache/#memcached","text":"Using the Memcached driver requires the Memcached PECL package to be installed. You may list all of your Memcached servers in the config/cache.php configuration file: 'memcached' = [ [ 'host' = '127.0.0.1', 'port' = 11211, 'weight' = 100 ], ], You may also set the host option to a UNIX socket path. If you do this, the port option should be set to 0: 'memcached' = [ [ 'host' = '/var/run/memcached/memcached.sock', 'port' = 0, 'weight' = 100 ], ],","title":"Memcached"},{"location":"cache/#redis","text":"Before using a Redis cache with Space MVC, you will need to either install the predis/predis package (~1.0) via Composer or install the PhpRedis PHP extension via PECL. For more information on configuring Redis, consult its Space MVC documentation page .","title":"Redis"},{"location":"cache/#cache-usage","text":"","title":"Cache Usage"},{"location":"cache/#obtaining-a-cache-instance","text":"The Illuminate\\Contracts\\Cache\\Factory and Illuminate\\Contracts\\Cache\\Repository contracts provide access to Space MVC's cache services. The Factory contract provides access to all cache drivers defined for your application. The Repository contract is typically an implementation of the default cache driver for your application as specified by your cache configuration file. However, you may also use the Cache facade, which is what we will use throughout this documentation. The Cache facade provides convenient, terse access to the underlying implementations of the Space MVC cache contracts: ?php namespace App\\Http\\Controllers; use Illuminate\\Support\\Facades\\Cache; class UserController extends Controller { /** * Show a list of all users of the application. * * @return Response */ public function index() { $value = Cache::get('key'); // } }","title":"Obtaining A Cache Instance"},{"location":"cache/#accessing-multiple-cache-stores","text":"Using the Cache facade, you may access various cache stores via the store method. The key passed to the store method should correspond to one of the stores listed in the stores configuration array in your cache configuration file: $value = Cache::store('file')- get('foo'); Cache::store('redis')- put('bar', 'baz', 10);","title":"Accessing Multiple Cache Stores"},{"location":"cache/#retrieving-items-from-the-cache","text":"The get method on the Cache facade is used to retrieve items from the cache. If the item does not exist in the cache, null will be returned. If you wish, you may pass a second argument to the get method specifying the default value you wish to be returned if the item doesn't exist: $value = Cache::get('key'); $value = Cache::get('key', 'default'); You may even pass a Closure as the default value. The result of the Closure will be returned if the specified item does not exist in the cache. Passing a Closure allows you to defer the retrieval of default values from a database or other external service: $value = Cache::get('key', function () { return DB::table(...)- get(); });","title":"Retrieving Items From The Cache"},{"location":"cache/#checking-for-item-existence","text":"The has method may be used to determine if an item exists in the cache. This method will return false if the value is null or false: if (Cache::has('key')) { // }","title":"Checking For Item Existence"},{"location":"cache/#incrementing-decrementing-values","text":"The increment and decrement methods may be used to adjust the value of integer items in the cache. Both of these methods accept an optional second argument indicating the amount by which to increment or decrement the item's value: Cache::increment('key'); Cache::increment('key', $amount); Cache::decrement('key'); Cache::decrement('key', $amount);","title":"Incrementing / Decrementing Values"},{"location":"cache/#retrieve-store","text":"Sometimes you may wish to retrieve an item from the cache, but also store a default value if the requested item doesn't exist. For example, you may wish to retrieve all users from the cache or, if they don't exist, retrieve them from the database and add them to the cache. You may do this using the Cache::remember method: $value = Cache::remember('users', $minutes, function () { return DB::table('users')- get(); }); If the item does not exist in the cache, the Closure passed to the remember method will be executed and its result will be placed in the cache. You may use the rememberForever method to retrieve an item from the cache or store it forever: $value = Cache::rememberForever('users', function () { return DB::table('users')- get(); });","title":"Retrieve &amp; Store"},{"location":"cache/#retrieve-delete","text":"If you need to retrieve an item from the cache and then delete the item, you may use the pull method. Like the get method, null will be returned if the item does not exist in the cache: $value = Cache::pull('key');","title":"Retrieve &amp; Delete"},{"location":"cache/#storing-items-in-the-cache","text":"You may use the put method on the Cache facade to store items in the cache. When you place an item in the cache, you need to specify the number of minutes for which the value should be cached: Cache::put('key', 'value', $minutes); Instead of passing the number of minutes as an integer, you may also pass a DateTime instance representing the expiration time of the cached item: $expiresAt = now()- addMinutes(10); Cache::put('key', 'value', $expiresAt);","title":"Storing Items In The Cache"},{"location":"cache/#store-if-not-present","text":"The add method will only add the item to the cache if it does not already exist in the cache store. The method will return true if the item is actually added to the cache. Otherwise, the method will return false: Cache::add('key', 'value', $minutes);","title":"Store If Not Present"},{"location":"cache/#storing-items-forever","text":"The forever method may be used to store an item in the cache permanently. Since these items will not expire, they must be manually removed from the cache using the forget method: Cache::forever('key', 'value'); If you are using the Memcached driver, items that are stored \"forever\" may be removed when the cache reaches its size limit.","title":"Storing Items Forever"},{"location":"cache/#removing-items-from-the-cache","text":"You may remove items from the cache using the forget method: Cache::forget('key'); You may clear the entire cache using the flush method: Cache::flush(); Flushing the cache does not respect the cache prefix and will remove all entries from the cache. Consider this carefully when clearing a cache which is shared by other applications.","title":"Removing Items From The Cache"},{"location":"cache/#atomic-locks","text":"To utilize this feature, your application must be using the memcached or redis cache driver as your application's default cache driver. In addition, all servers must be communicating with the same central cache server. Atomic locks allow for the manipulation of distributed locks without worrying about race conditions. For example, Space MVC uses atomic locks to ensure that only one remote task is being executed on a server at a time. You may create and manage locks using the Cache::lock method: if (Cache::lock('foo', 10)- get()) { // Lock acquired for 10 seconds... Cache::lock('foo')- release(); } The get method also accepts a Closure. After the Closure is executed, Space MVC will automatically release the lock: Cache::lock('foo')- get(function () { // Lock acquired indefinitely and automatically released... }); If the lock is not available at the moment you request it, you may instruct Space MVC to wait for a specified number of seconds. If the lock can not be acquired within the specified time limit, an Illuminate\\Contracts\\Cache\\LockTimeoutException will be thrown: if (Cache::lock('foo', 10)- block(5)) { // Lock acquired after waiting maximum of 5 seconds... } Cache::lock('foo', 10)- block(5, function () { // Lock acquired after waiting maximum of 5 seconds... });","title":"Atomic Locks"},{"location":"cache/#the-cache-helper","text":"In addition to using the Cache facade or cache contract , you may also use the global cache function to retrieve and store data via the cache. When the cache function is called with a single, string argument, it will return the value of the given key: $value = cache('key'); If you provide an array of key / value pairs and an expiration time to the function, it will store values in the cache for the specified duration: cache(['key' = 'value'], $minutes); cache(['key' = 'value'], now()- addSeconds(10)); When the cache function is called without any arguments, it returns an instance of the Illuminate\\Contracts\\Cache\\Factory implementation, allowing you to all other caching methods: cache()- remember('users', $minutes, function () { return DB::table('users')- get(); }); When testing call to the global cache function, you may use the Cache::shouldReceive method just as if you were testing a facade .","title":"The Cache Helper"},{"location":"cache/#cache-tags","text":"Cache tags are not supported when using the file or database cache drivers. Furthermore, when using multiple tags with caches that are stored \"forever\", performance will be best with a driver such as memcached, which automatically purges stale records.","title":"Cache Tags"},{"location":"cache/#storing-tagged-cache-items","text":"Cache tags allow you to tag related items in the cache and then flush all cached values that have been assigned a given tag. You may access a tagged cache by passing in an ordered array of tag names. For example, let's access a tagged cache and put value in the cache: Cache::tags(['people', 'artists'])- put('John', $john, $minutes); Cache::tags(['people', 'authors'])- put('Anne', $anne, $minutes);","title":"Storing Tagged Cache Items"},{"location":"cache/#accessing-tagged-cache-items","text":"To retrieve a tagged cache item, pass the same ordered list of tags to the tags method and then call the get method with the key you wish to retrieve: $john = Cache::tags(['people', 'artists'])- get('John'); $anne = Cache::tags(['people', 'authors'])- get('Anne');","title":"Accessing Tagged Cache Items"},{"location":"cache/#removing-tagged-cache-items","text":"You may flush all items that are assigned a tag or list of tags. For example, this statement would remove all caches tagged with either people, authors, or both. So, both Anne and John would be removed from the cache: Cache::tags(['people', 'authors'])- flush(); In contrast, this statement would remove only caches tagged with authors, so Anne would be removed, but not John: Cache::tags('authors')- flush();","title":"Removing Tagged Cache Items"},{"location":"cache/#adding-custom-cache-drivers","text":"","title":"Adding Custom Cache Drivers"},{"location":"cache/#writing-the-driver","text":"To create our custom cache driver, we first need to implement the Illuminate\\Contracts\\Cache\\Store contract . So, a MongoDB cache implementation would look something like this: ?php namespace App\\Extensions; use Illuminate\\Contracts\\Cache\\Store; class MongoStore implements Store { public function get($key) {} public function many(array $keys); public function put($key, $value, $minutes) {} public function putMany(array $values, $minutes); public function increment($key, $value = 1) {} public function decrement($key, $value = 1) {} public function forever($key, $value) {} public function forget($key) {} public function flush() {} public function getPrefix() {} } We just need to implement each of these methods using a MongoDB connection. For an example of how to implement each of these methods, take a look at the Illuminate\\Cache\\MemcachedStore in the framework source code. Once our implementation is complete, we can finish our custom driver registration. Cache::extend('mongo', function ($app) { return Cache::repository(new MongoStore); }); If you're wondering where to put your custom cache driver code, you could create an Extensions namespace within your app directory. However, keep in mind that Space MVC does not have a rigid application structure and you are free to organize your application according to your preferences.","title":"Writing The Driver"},{"location":"cache/#registering-the-driver","text":"To register the custom cache driver with Space MVC, we will use the extend method on the Cache facade. The call to Cache::extend could be done in the boot method of the default App\\Providers\\AppServiceProvider that ships with fresh Space MVC applications, or you may create your own service provider to house the extension - just don't forget to register the provider in the config/app.php provider array: ?php namespace App\\Providers; use App\\Extensions\\MongoStore; use Illuminate\\Support\\Facades\\Cache; use Illuminate\\Support\\ServiceProvider; class CacheServiceProvider extends ServiceProvider { /** * Perform post-registration booting of services. * * @return void */ public function boot() { Cache::extend('mongo', function ($app) { return Cache::repository(new MongoStore); }); } /** * Register bindings in the container. * * @return void */ public function register() { // } } The first argument passed to the extend method is the name of the driver. This will correspond to your driver option in the config/cache.php configuration file. The second argument is a Closure that should return an Illuminate\\Cache\\Repository instance. The Closure will be passed an $app instance, which is an instance of the service container . Once your extension is registered, update your config/cache.php configuration file's driver option to the name of your extension.","title":"Registering The Driver"},{"location":"cache/#events","text":"To execute code on every cache operation, you may listen for the events fired by the cache. Typically, you should place these event listeners within your EventServiceProvider: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'Illuminate\\Cache\\Events\\CacheHit' = [ 'App\\Listeners\\LogCacheHit', ], 'Illuminate\\Cache\\Events\\CacheMissed' = [ 'App\\Listeners\\LogCacheMissed', ], 'Illuminate\\Cache\\Events\\KeyForgotten' = [ 'App\\Listeners\\LogKeyForgotten', ], 'Illuminate\\Cache\\Events\\KeyWritten' = [ 'App\\Listeners\\LogKeyWritten', ], ];","title":"Events"},{"location":"code-contributors/","text":"Thank you, You have successfully been added to our contributors list! Subscribe to our Code Contributors List Please Subscribe to our code contributors list if you would like to join our development team and help us work on this project. We will send developers beginners, mid weight and advanced tutorials, guides, videos, and more. We aim to bring everybody up to scratch with modern professional php programming we don't aim to leave anybody behind we can work with developers of all levels from first timers to advanced pro league developers. We will teach and work with you to create innovative features and create specific set tasks whilst learning helping you to learn and work on this framework for your own projects. We will allow you to participate in working on real tasks we work on as a team daily and we hope with the help you and we receive everybody can be more successful going forward into the future :) As a code contributor you will be able to view and choose from task lists we will provide and you can save your changes to our projects master source code. We will also list every contributors photos on this page in future so everybody can see who has contributed so far and beyond. We will inform everybody via email of how to work with our team and how to learn to code like a professional. Thanks for reading and your interests. Space MVC Email Address Subscribe","title":"Code contributors"},{"location":"configuration/","text":"All of the configuration files for the Space MVC framework are stored in the config directory. Each option is documented, so feel free to look through the files and get familiar with the options available to you.","title":"Configuration"},{"location":"controllers/","text":"Controllers Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes. Controllers can group related request handling logic into a single class. Controllers are stored in the app/Http/Controllers directory. Defining Controllers Below is an example of a basic controller class. Note that the controller extends the base controller class included with Space MVC. The base class provides a few convenience methods such as the middleware method, which may be used to attach middleware to controller actions: ?php namespace App\\Http\\Controllers; use App\\User; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param int $id * @return View */ public function show($id) { return view('user.profile', ['user' = User::findOrFail($id)]); } } You can define a route to this controller action like so: Route::get('user/{id}', 'UserController@show'); Now, when a request matches the specified route URI, the show method on the UserController class will be executed. Of course, the route parameters will also be passed to the method. Controllers are not required to extend a base class. However, you will not have access to convenience features such as the middleware, validate, and dispatch methods. Controllers Namespaces It is very important to note that we did not need to specify the full controller namespace when defining the controller route. Since the RouteServiceProvider loads your route files within a route group that contains the namespace, we only specified the portion of the class name that comes after the App\\Http\\Controllers portion of the namespace. If you choose to nest your controllers deeper into the App\\Http\\Controllers directory, use the specific class name relative to the App\\Http\\Controllers root namespace. So, if your full controller class is App\\Http\\Controllers\\Photos\\AdminController, you should register routes to the controller like so: Route::get('foo', 'Photos\\AdminController@method');","title":"Controllers"},{"location":"controllers/#controllers","text":"Instead of defining all of your request handling logic as Closures in route files, you may wish to organize this behavior using Controller classes. Controllers can group related request handling logic into a single class. Controllers are stored in the app/Http/Controllers directory.","title":"Controllers"},{"location":"controllers/#defining-controllers","text":"Below is an example of a basic controller class. Note that the controller extends the base controller class included with Space MVC. The base class provides a few convenience methods such as the middleware method, which may be used to attach middleware to controller actions: ?php namespace App\\Http\\Controllers; use App\\User; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param int $id * @return View */ public function show($id) { return view('user.profile', ['user' = User::findOrFail($id)]); } } You can define a route to this controller action like so: Route::get('user/{id}', 'UserController@show'); Now, when a request matches the specified route URI, the show method on the UserController class will be executed. Of course, the route parameters will also be passed to the method. Controllers are not required to extend a base class. However, you will not have access to convenience features such as the middleware, validate, and dispatch methods.","title":"Defining Controllers"},{"location":"controllers/#controllers-namespaces","text":"It is very important to note that we did not need to specify the full controller namespace when defining the controller route. Since the RouteServiceProvider loads your route files within a route group that contains the namespace, we only specified the portion of the class name that comes after the App\\Http\\Controllers portion of the namespace. If you choose to nest your controllers deeper into the App\\Http\\Controllers directory, use the specific class name relative to the App\\Http\\Controllers root namespace. So, if your full controller class is App\\Http\\Controllers\\Photos\\AdminController, you should register routes to the controller like so: Route::get('foo', 'Photos\\AdminController@method');","title":"Controllers &amp; Namespaces"},{"location":"csrf/","text":"CSRF Protection ul li a href=\"#csrf-introduction\" Introduction /a /li li a href=\"#csrf-excluding-uris\" Excluding URIs /a /li li a href=\"#csrf-x-csrf-token\" X-CSRF-Token /a /li li a href=\"#csrf-x-xsrf-token\" X-XSRF-Token /a /li /ul Introduction Space MVC makes it easy to protect your application from cross-site request forgery (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user. Space MVC automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application. Anytime you define a HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: form method= POST action= /profile @csrf ... /form The VerifyCsrfToken middleware , which is included in the web middleware group, will automatically verify that the token in the request input matches the token stored in the session. CSRF Tokens JavaScript When building JavaScript driven applications, it is convenient to have your JavaScript HTTP library automatically attach the CSRF token to every outgoing request. By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. Excluding URIs From CSRF Protection Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes. Typically, you should place these kinds of routes outside of the web middleware group that the RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware: ?php namespace App\\Http\\Middleware; use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware; class VerifyCsrfToken extends Middleware { /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]; } The CSRF middleware is automatically disabled when running tests . X-CSRF-TOKEN In addition to checking for the CSRF token as a POST parameter, the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in a HTML meta tag: meta name= csrf-token content= {{ csrf_token() }} Then, once you have created the meta tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications: $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name= csrf-token ]').attr('content') } }); By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. X-XSRF-TOKEN Space MVC stores the current CSRF token in a XSRF-TOKEN cookie that is included with each response generated by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header. This cookie is primarily sent as a convenience since some JavaScript frameworks and libraries, like Angular and Axios, automatically place its value in the X-XSRF-TOKEN header. CSRF Protection ul li a href=\"#csrf-introduction\" Introduction /a /li li a href=\"#csrf-excluding-uris\" Excluding URIs /a /li li a href=\"#csrf-x-csrf-token\" X-CSRF-Token /a /li li a href=\"#csrf-x-xsrf-token\" X-XSRF-Token /a /li /ul Introduction Space MVC makes it easy to protect your application from cross-site request forgery (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user. Space MVC automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application. Anytime you define a HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: form method= POST action= /profile @csrf ... /form The VerifyCsrfToken middleware , which is included in the web middleware group, will automatically verify that the token in the request input matches the token stored in the session. CSRF Tokens JavaScript When building JavaScript driven applications, it is convenient to have your JavaScript HTTP library automatically attach the CSRF token to every outgoing request. By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. Excluding URIs From CSRF Protection Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes. Typically, you should place these kinds of routes outside of the web middleware group that the RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware: ?php namespace App\\Http\\Middleware; use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware; class VerifyCsrfToken extends Middleware { /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]; } The CSRF middleware is automatically disabled when running tests . X-CSRF-TOKEN In addition to checking for the CSRF token as a POST parameter, the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in a HTML meta tag: meta name= csrf-token content= {{ csrf_token() }} Then, once you have created the meta tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications: $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name= csrf-token ]').attr('content') } }); By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application. X-XSRF-TOKEN Space MVC stores the current CSRF token in a XSRF-TOKEN cookie that is included with each response generated by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header. This cookie is primarily sent as a convenience since some JavaScript frameworks and libraries, like Angular and Axios, automatically place its value in the X-XSRF-TOKEN header.","title":"CSRF Protection"},{"location":"csrf/#csrf-protection","text":"ul li a href=\"#csrf-introduction\" Introduction /a /li li a href=\"#csrf-excluding-uris\" Excluding URIs /a /li li a href=\"#csrf-x-csrf-token\" X-CSRF-Token /a /li li a href=\"#csrf-x-xsrf-token\" X-XSRF-Token /a /li /ul","title":"CSRF Protection"},{"location":"csrf/#introduction","text":"Space MVC makes it easy to protect your application from cross-site request forgery (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user. Space MVC automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application. Anytime you define a HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: form method= POST action= /profile @csrf ... /form The VerifyCsrfToken middleware , which is included in the web middleware group, will automatically verify that the token in the request input matches the token stored in the session.","title":"Introduction"},{"location":"csrf/#csrf-tokens-javascript","text":"When building JavaScript driven applications, it is convenient to have your JavaScript HTTP library automatically attach the CSRF token to every outgoing request. By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application.","title":"CSRF Tokens &amp; JavaScript"},{"location":"csrf/#excluding-uris-from-csrf-protection","text":"Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes. Typically, you should place these kinds of routes outside of the web middleware group that the RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware: ?php namespace App\\Http\\Middleware; use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware; class VerifyCsrfToken extends Middleware { /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]; } The CSRF middleware is automatically disabled when running tests .","title":"Excluding URIs From CSRF Protection"},{"location":"csrf/#x-csrf-token","text":"In addition to checking for the CSRF token as a POST parameter, the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in a HTML meta tag: meta name= csrf-token content= {{ csrf_token() }} Then, once you have created the meta tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications: $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name= csrf-token ]').attr('content') } }); By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application.","title":"X-CSRF-TOKEN"},{"location":"csrf/#x-xsrf-token","text":"Space MVC stores the current CSRF token in a XSRF-TOKEN cookie that is included with each response generated by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header. This cookie is primarily sent as a convenience since some JavaScript frameworks and libraries, like Angular and Axios, automatically place its value in the X-XSRF-TOKEN header.","title":"X-XSRF-TOKEN"},{"location":"csrf/#csrf-protection_1","text":"ul li a href=\"#csrf-introduction\" Introduction /a /li li a href=\"#csrf-excluding-uris\" Excluding URIs /a /li li a href=\"#csrf-x-csrf-token\" X-CSRF-Token /a /li li a href=\"#csrf-x-xsrf-token\" X-XSRF-Token /a /li /ul","title":"CSRF Protection"},{"location":"csrf/#introduction_1","text":"Space MVC makes it easy to protect your application from cross-site request forgery (CSRF) attacks. Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user. Space MVC automatically generates a CSRF \"token\" for each active user session managed by the application. This token is used to verify that the authenticated user is the one actually making the requests to the application. Anytime you define a HTML form in your application, you should include a hidden CSRF token field in the form so that the CSRF protection middleware can validate the request. You may use the @csrf Blade directive to generate the token field: form method= POST action= /profile @csrf ... /form The VerifyCsrfToken middleware , which is included in the web middleware group, will automatically verify that the token in the request input matches the token stored in the session.","title":"Introduction"},{"location":"csrf/#csrf-tokens-javascript_1","text":"When building JavaScript driven applications, it is convenient to have your JavaScript HTTP library automatically attach the CSRF token to every outgoing request. By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application.","title":"CSRF Tokens &amp; JavaScript"},{"location":"csrf/#excluding-uris-from-csrf-protection_1","text":"Sometimes you may wish to exclude a set of URIs from CSRF protection. For example, if you are using Stripe to process payments and are utilizing their webhook system, you will need to exclude your Stripe webhook handler route from CSRF protection since Stripe will not know what CSRF token to send to your routes. Typically, you should place these kinds of routes outside of the web middleware group that the RouteServiceProvider applies to all routes in the routes/web.php file. However, you may also exclude the routes by adding their URIs to the $except property of the VerifyCsrfToken middleware: ?php namespace App\\Http\\Middleware; use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware; class VerifyCsrfToken extends Middleware { /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ]; } The CSRF middleware is automatically disabled when running tests .","title":"Excluding URIs From CSRF Protection"},{"location":"csrf/#x-csrf-token_1","text":"In addition to checking for the CSRF token as a POST parameter, the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header. You could, for example, store the token in a HTML meta tag: meta name= csrf-token content= {{ csrf_token() }} Then, once you have created the meta tag, you can instruct a library like jQuery to automatically add the token to all request headers. This provides simple, convenient CSRF protection for your AJAX based applications: $.ajaxSetup({ headers: { 'X-CSRF-TOKEN': $('meta[name= csrf-token ]').attr('content') } }); By default, the resources/js/bootstrap.js file registers the value of the csrf-token meta tag with the Axios HTTP library. If you are not using this library, you will need to manually configure this behavior for your application.","title":"X-CSRF-TOKEN"},{"location":"csrf/#x-xsrf-token_1","text":"Space MVC stores the current CSRF token in a XSRF-TOKEN cookie that is included with each response generated by the framework. You can use the cookie value to set the X-XSRF-TOKEN request header. This cookie is primarily sent as a convenience since some JavaScript frameworks and libraries, like Angular and Axios, automatically place its value in the X-XSRF-TOKEN header.","title":"X-XSRF-TOKEN"},{"location":"database-basic-crud/","text":"Database : Basic CRUD Create Read Update Delete Massive CRUD as defined by Wikipedia: Create, read, update and delete (CRUD) are the four basic functions of persistent storage, a major part of nearly all computer software. Sometimes CRUD is expanded with the words retrieve instead of read or destroy instead of delete. It is also sometimes used to describe user interface conventions that facilitate viewing, searching, and changing information; often using computer-based forms and reports. In other words, CRUD is the day-to-day tedium of saving and reading data. ActiveRecord removes the remedial and encumbering task of hand-writing SQL queries. Instead, you will only need to write the relevant parts to work with your data. Create This is where you save records to your database. Here we create a new post by instantiating a new object and then invoking the save() method. 1 $post = new Post(); 2 $post- title = 'My first blog post!!'; 3 $post- author_id = 5; 4 $post- save(); 5 # INSERT INTO `posts` (title,author_id) VALUES('My first blog post!!', 5) 6 7 # the below methods accomplish the same thing 8 9 $attributes = array('title' = 'My first blog post!!', 'author_id' = 5); 10 $post = new Post($attributes); 11 $post- save(); 12 # same sql as above 13 14 $post = Post::create($attributes); 15 # same sql as above Read These are your basic methods to find and retrieve records from your database. See the Finders section for more details. 1 $post = Post::find(1); 2 echo $post- title; # 'My first blog post!!' 3 echo $post- author_id; # 5 4 5 # also the same since it is the first record in the db 6 $post = Post::first(); 7 8 # using dynamic finders 9 $post = Post::find_by_name('The Decider'); 10 $post = Post::find_by_name_and_id('The Bridge Builder',100); 11 $post = Post::find_by_name_or_id('The Bridge Builder',100); 12 13 # using some conditions 14 $posts = Post::find('all',array('conditions' = array('name=?','The Bridge Builder'))); Update To update you would just need to find a record first and then change one of its attributes. It keeps an array of attributes that are \"dirty\" (that have been modified) and so our sql will only update the fields modified. 1 $post = Post::find(1); 2 echo $post- title; # 'My first blog post!!' 3 $post- title = 'Some real title'; 4 $post- save(); 5 # UPDATE `posts` SET title='Some real title' WHERE id=1 6 7 $post- update_attributes(array('title' = 'Some other title', 'author_id' = 1)); 8 # UPDATE `posts` SET title='Some other title', author_id=1 WHERE id=1 Delete Deleting a record will not destroy the object. This means that it will call sql to delete the record in your database, however, you can still use the object. 1 $post = Post::find(1); 2 $post- delete(); 3 # DELETE FROM `posts` WHERE id=1 4 5 echo $post- title; # Some other title Massive Update or Delete You can do a massive update or massive delete easily. Look at this example: 1 # MASSIVE UPDATE 2 # Model::table()- update(AttributesToUpdate, WhereToUpdate); 3 Post::table()- update(array('title' = 'Massive title!', /* Other attributes... */, array('id' = array(1, 3, 7)); 4 # UPDATE `posts` SET title = `Massive title!` WHERE id IN (1, 3, 7) 5 6 # MASSIVE DELETE 7 # Model::table()- delete(WhereToDelete); 8 Post::table()- delete(array('id' = array(5, 9, 26, 30)); 9 # DELETE FROM `posts` WHERE id IN (5, 9, 26, 30)","title":"Basic Crud"},{"location":"database-basic-crud/#database-basic-crud","text":"Create Read Update Delete Massive CRUD as defined by Wikipedia: Create, read, update and delete (CRUD) are the four basic functions of persistent storage, a major part of nearly all computer software. Sometimes CRUD is expanded with the words retrieve instead of read or destroy instead of delete. It is also sometimes used to describe user interface conventions that facilitate viewing, searching, and changing information; often using computer-based forms and reports. In other words, CRUD is the day-to-day tedium of saving and reading data. ActiveRecord removes the remedial and encumbering task of hand-writing SQL queries. Instead, you will only need to write the relevant parts to work with your data.","title":"Database : Basic CRUD"},{"location":"database-basic-crud/#create","text":"This is where you save records to your database. Here we create a new post by instantiating a new object and then invoking the save() method. 1 $post = new Post(); 2 $post- title = 'My first blog post!!'; 3 $post- author_id = 5; 4 $post- save(); 5 # INSERT INTO `posts` (title,author_id) VALUES('My first blog post!!', 5) 6 7 # the below methods accomplish the same thing 8 9 $attributes = array('title' = 'My first blog post!!', 'author_id' = 5); 10 $post = new Post($attributes); 11 $post- save(); 12 # same sql as above 13 14 $post = Post::create($attributes); 15 # same sql as above","title":"Create"},{"location":"database-basic-crud/#read","text":"These are your basic methods to find and retrieve records from your database. See the Finders section for more details. 1 $post = Post::find(1); 2 echo $post- title; # 'My first blog post!!' 3 echo $post- author_id; # 5 4 5 # also the same since it is the first record in the db 6 $post = Post::first(); 7 8 # using dynamic finders 9 $post = Post::find_by_name('The Decider'); 10 $post = Post::find_by_name_and_id('The Bridge Builder',100); 11 $post = Post::find_by_name_or_id('The Bridge Builder',100); 12 13 # using some conditions 14 $posts = Post::find('all',array('conditions' = array('name=?','The Bridge Builder')));","title":"Read"},{"location":"database-basic-crud/#update","text":"To update you would just need to find a record first and then change one of its attributes. It keeps an array of attributes that are \"dirty\" (that have been modified) and so our sql will only update the fields modified. 1 $post = Post::find(1); 2 echo $post- title; # 'My first blog post!!' 3 $post- title = 'Some real title'; 4 $post- save(); 5 # UPDATE `posts` SET title='Some real title' WHERE id=1 6 7 $post- update_attributes(array('title' = 'Some other title', 'author_id' = 1)); 8 # UPDATE `posts` SET title='Some other title', author_id=1 WHERE id=1","title":"Update"},{"location":"database-basic-crud/#delete","text":"Deleting a record will not destroy the object. This means that it will call sql to delete the record in your database, however, you can still use the object. 1 $post = Post::find(1); 2 $post- delete(); 3 # DELETE FROM `posts` WHERE id=1 4 5 echo $post- title; # Some other title","title":"Delete"},{"location":"database-basic-crud/#massive-update-or-delete","text":"You can do a massive update or massive delete easily. Look at this example: 1 # MASSIVE UPDATE 2 # Model::table()- update(AttributesToUpdate, WhereToUpdate); 3 Post::table()- update(array('title' = 'Massive title!', /* Other attributes... */, array('id' = array(1, 3, 7)); 4 # UPDATE `posts` SET title = `Massive title!` WHERE id IN (1, 3, 7) 5 6 # MASSIVE DELETE 7 # Model::table()- delete(WhereToDelete); 8 Post::table()- delete(array('id' = array(5, 9, 26, 30)); 9 # DELETE FROM `posts` WHERE id IN (5, 9, 26, 30)","title":"Massive Update or Delete"},{"location":"database-configuration/","text":"Database : Configuration Default connection Multi-connections Setting the encoding Setup is very easy and straight-forward. There are essentially only two configuration points you must concern yourself with: Setting the model auto_load directory. Configuring your database connections. By setting the model auto_load directory, you are telling PHP where to look for your model classes. This means that you can have an app/folder structure of your choice as long as you have a real directory that holds your model classes. Each class should have it's own php file that is the same name of the class with a .php extension of course. There are two ways you can initialize your configuration options. The easiest path is wrapping the calls in a closure which is sent through the Config initializer method. This is a neat and clean way to take advantage of PHP's new closure feature. 1 # inclue the ActiveRecord library 2 require_once 'php-activerecord/ActiveRecord.php'; 3 4 ActiveRecord\\Config::initialize(function($cfg) 5 { 6 $cfg- set_model_directory('/path/to/your/model_directory'); 7 $cfg- set_connections(array('development' = 8 'mysql://username:password@localhost/database_name')); 9 }); That's it! ActiveRecord takes care of the rest for you. It does not require that you map your table schema to yaml/xml files. It will query the database for this information and cache it so that it does not make multiple calls to the database for a single schema. If you aren't feeling fancy, you can drop the closure and access the ActiveRecord\\Config singleton directly. 1 $cfg = ActiveRecord\\Config::instance(); 2 $cfg- set_model_directory('/path/to/your/model_directory'); 3 $cfg- set_connections(array('development' = 4 'mysql://username:password@localhost/database_name')); h4 id=\"default-connections\" Default connection The development connection is the default by convention. You can change this by setting a new default connection based off of one of the connections you passed to set_connections. 1 $connections = array( 2 'development' = 'mysql://username:password@localhost/development', 3 'production' = 'mysql://username:password@localhost/production', 4 'test' = 'mysql://username:password@localhost/test' 5 ); 6 7 # must issue a use statement in your closure if passing variables 8 ActiveRecord\\Config::initialize(function($cfg) use ($connections) 9 { 10 $cfg- set_model_directory('/path/to/your/model_directory'); 11 $cfg- set_connections($connections); 12 13 # default connection is now production 14 $cfg- set_default_connection('production'); 15 }); Multi-connections You can easily configure ActiveRecord to accept multiple database connections. All you have to do is specify the connection in the given model that should be using a different database. 1 $connections = array( 2 'development' = 'mysql://username:password@localhost/development', 3 'pgsql' = 'pgsql://username:password@localhost/development', 4 'sqlite' = 'sqlite://my_database.db', 5 'oci' = 'oci://username:passsword@localhost/xe' 6 ); 7 8 # must issue a use statement in your closure if passing variables 9 ActiveRecord\\Config::initialize(function($cfg) use ($connections) 10 { 11 $cfg- set_model_directory('/path/to/your/model_directory'); 12 $cfg- set_connections($connections); 13 }); Your models would look like the following. 1 # SomeOciModel.php 2 class SomeOciModel extends ActiveRecord\\Model 3 { 4 static $connection = 'oci'; 5 } 6 7 # SomeSqliteModel.php 8 class SomeSqliteModel extends ActiveRecord\\Model 9 { 10 static $connection = 'sqlite'; 11 } You could also have a base 'connection' model so all sub-classes will inherit the db setting. 1 # OciModels.php 2 abstract class OciModels extends ActiveRecord\\Model 3 { 4 static $connection = 'oci'; 5 } 6 7 # AnotherOciModel.php 8 class AnotherOciModel extends OciModels 9 { 10 # automatically inherits the oci database 11 } Setting the encoding The character encoding can be specified in your connection parameters: 1 $config- set_connections(array( 2 'development' = 'mysql://user:pass@localhost/mydb?charset=utf8') 3 );","title":"Configuration"},{"location":"database-configuration/#database-configuration","text":"Default connection Multi-connections Setting the encoding Setup is very easy and straight-forward. There are essentially only two configuration points you must concern yourself with: Setting the model auto_load directory. Configuring your database connections. By setting the model auto_load directory, you are telling PHP where to look for your model classes. This means that you can have an app/folder structure of your choice as long as you have a real directory that holds your model classes. Each class should have it's own php file that is the same name of the class with a .php extension of course. There are two ways you can initialize your configuration options. The easiest path is wrapping the calls in a closure which is sent through the Config initializer method. This is a neat and clean way to take advantage of PHP's new closure feature. 1 # inclue the ActiveRecord library 2 require_once 'php-activerecord/ActiveRecord.php'; 3 4 ActiveRecord\\Config::initialize(function($cfg) 5 { 6 $cfg- set_model_directory('/path/to/your/model_directory'); 7 $cfg- set_connections(array('development' = 8 'mysql://username:password@localhost/database_name')); 9 }); That's it! ActiveRecord takes care of the rest for you. It does not require that you map your table schema to yaml/xml files. It will query the database for this information and cache it so that it does not make multiple calls to the database for a single schema. If you aren't feeling fancy, you can drop the closure and access the ActiveRecord\\Config singleton directly. 1 $cfg = ActiveRecord\\Config::instance(); 2 $cfg- set_model_directory('/path/to/your/model_directory'); 3 $cfg- set_connections(array('development' = 4 'mysql://username:password@localhost/database_name')); h4 id=\"default-connections\" Default connection The development connection is the default by convention. You can change this by setting a new default connection based off of one of the connections you passed to set_connections. 1 $connections = array( 2 'development' = 'mysql://username:password@localhost/development', 3 'production' = 'mysql://username:password@localhost/production', 4 'test' = 'mysql://username:password@localhost/test' 5 ); 6 7 # must issue a use statement in your closure if passing variables 8 ActiveRecord\\Config::initialize(function($cfg) use ($connections) 9 { 10 $cfg- set_model_directory('/path/to/your/model_directory'); 11 $cfg- set_connections($connections); 12 13 # default connection is now production 14 $cfg- set_default_connection('production'); 15 });","title":"Database : Configuration"},{"location":"database-configuration/#multi-connections","text":"You can easily configure ActiveRecord to accept multiple database connections. All you have to do is specify the connection in the given model that should be using a different database. 1 $connections = array( 2 'development' = 'mysql://username:password@localhost/development', 3 'pgsql' = 'pgsql://username:password@localhost/development', 4 'sqlite' = 'sqlite://my_database.db', 5 'oci' = 'oci://username:passsword@localhost/xe' 6 ); 7 8 # must issue a use statement in your closure if passing variables 9 ActiveRecord\\Config::initialize(function($cfg) use ($connections) 10 { 11 $cfg- set_model_directory('/path/to/your/model_directory'); 12 $cfg- set_connections($connections); 13 }); Your models would look like the following. 1 # SomeOciModel.php 2 class SomeOciModel extends ActiveRecord\\Model 3 { 4 static $connection = 'oci'; 5 } 6 7 # SomeSqliteModel.php 8 class SomeSqliteModel extends ActiveRecord\\Model 9 { 10 static $connection = 'sqlite'; 11 } You could also have a base 'connection' model so all sub-classes will inherit the db setting. 1 # OciModels.php 2 abstract class OciModels extends ActiveRecord\\Model 3 { 4 static $connection = 'oci'; 5 } 6 7 # AnotherOciModel.php 8 class AnotherOciModel extends OciModels 9 { 10 # automatically inherits the oci database 11 }","title":"Multi-connections"},{"location":"database-configuration/#setting-the-encoding","text":"The character encoding can be specified in your connection parameters: 1 $config- set_connections(array( 2 'development' = 'mysql://user:pass@localhost/mydb?charset=utf8') 3 );","title":"Setting the encoding"},{"location":"database-conventions/","text":"Database : Conventions Because we have embraced a convention over configuration philosophy, using our library is not painful. The conventions are easy to remember which will also contribute to stream-lining your productivity as a developer. If you've already seen the Configuration / Setup guide, then you know that there isn't much to it. Therefore, using PHP ActiveRecord mainly requires you to acquaint yourself with some simple conventions. Once you've done that, you can move on to the more advanced features. ActiveRecord assumes the following conventions: 1 # name of your class represents the singular form of your table name. 2 class Book extends ActiveRecord\\Model {} 3 4 # your table name would be people 5 class Person extends ActiveRecord\\Model {} The primary key of your table is named \"id\". 1 class Book extends ActiveRecord\\Model {} 2 3 # SELECT * FROM `books` where id = 1 4 Book::find(1); Overriding conventions Even through ActiveRecord prefers to make assumptions about your table and primary key names, you can override them. Here is a simple example showing how one could configure a specific model. 1 class Book extends ActiveRecord\\Model 2 { 3 # explicit table name since our table is not books 4 static $table_name = 'my_book'; 5 6 # explicit pk since our pk is not id 7 static $primary_key = 'book_id'; 8 9 # explicit connection name since we always want our test db with this model 10 static $connection = 'test'; 11 12 # explicit database name will generate sql like so = my_db.my_book 13 static $db = 'my_db'; 14 }","title":"Conventions"},{"location":"database-conventions/#database-conventions","text":"Because we have embraced a convention over configuration philosophy, using our library is not painful. The conventions are easy to remember which will also contribute to stream-lining your productivity as a developer. If you've already seen the Configuration / Setup guide, then you know that there isn't much to it. Therefore, using PHP ActiveRecord mainly requires you to acquaint yourself with some simple conventions. Once you've done that, you can move on to the more advanced features. ActiveRecord assumes the following conventions: 1 # name of your class represents the singular form of your table name. 2 class Book extends ActiveRecord\\Model {} 3 4 # your table name would be people 5 class Person extends ActiveRecord\\Model {} The primary key of your table is named \"id\". 1 class Book extends ActiveRecord\\Model {} 2 3 # SELECT * FROM `books` where id = 1 4 Book::find(1);","title":"Database : Conventions"},{"location":"database-conventions/#overriding-conventions","text":"Even through ActiveRecord prefers to make assumptions about your table and primary key names, you can override them. Here is a simple example showing how one could configure a specific model. 1 class Book extends ActiveRecord\\Model 2 { 3 # explicit table name since our table is not books 4 static $table_name = 'my_book'; 5 6 # explicit pk since our pk is not id 7 static $primary_key = 'book_id'; 8 9 # explicit connection name since we always want our test db with this model 10 static $connection = 'test'; 11 12 # explicit database name will generate sql like so = my_db.my_book 13 static $db = 'my_db'; 14 }","title":"Overriding conventions"},{"location":"database-finders/","text":"Database : Finders Single record result Multiple records result Finder options Conditions Limit & Offset Order Select From Group Having Read only Dynamic finders Joins Find by custom SQL Eager loading associations ActiveRecord supports a number of methods by which you can find records such as: via primary key, dynamic field name finders. It has the ability to fetch all the records in a table with a simple call, or you can make use of options like order, limit, select, and group. There are essentially two groups of finders you will be working with: a single record result and multiple records result . Sometimes there will be little transparency for the method calls, meaning you may use the same method to get either one, but you will pass an option to that method to signify which type of result you will fetch. All methods used to fetch records from your database will go through Model::find() , with one exception, custom sql can be passed to Model::find_by_sql() . In all cases, the finder methods in ActiveRecord are statically invoked. This means you will always use the following type of syntax. 1 class Book extends ActiveRecord\\Model {} 2 3 Book::find('all'); 4 Book::find('last'); 5 Book::first(); 6 Book::last(); 7 Book::all(); Single record result Whenever you invoke a method which produces a single result, that method will return an instance of your model class. There are 3 different ways to fetch a single record result. We'll start with one of the most basic forms. Find by primary key You can grab a record by passing a primary key to the find method. You may pass an options array as the second argument for creating specific queries. If no record is found, a RecordNotFound exception will be thrown. 1 # Grab the book with the primary key of 2 2 Book::find(2); 3 # sql = SELECT * FROM `books` WHERE id = 2 Find first You can get the first record back from your database two ways. If you do not pass conditions as the second argument, then this method will fetch all the results from your database, but will only return the very first result back to you. Null will be returned if no records are found. 1 # Grab all books, but only return the first result back as your model object. 2 $book = Book::first(); 3 echo the first id is: {$book- id} # = the first id is: 1 4 # sql = SELECT * FROM `books` 5 6 # this produces the same sql/result as above 7 Book::find('first'); Find last If you haven't yet fallen asleep reading this guide, you should've guessed this is the same as \"find first\", except that it will return the last result. Null will be returned if no records are found. 1 # Grab all books, but only return the last result back as your model object. 2 $book = Book::last(); 3 echo the last id is: {$book- id} # = the last id is: 32 4 # sql = SELECT * FROM `books` 5 6 # this produces the same sql/result as above 7 Book::find('last'); Multiple records result This type of result will always return an array of model objects. If your table holds no records, or your query yields no results, then an empty array will be given. Find by primary key Just like the single record result for find by primary key, you can pass an array to the find method for multiple primary keys. Again, you may pass an options array as the last argument for creating specific queries. Every key which you use as an argument must produce a corresponding record, otherwise, a RecordNotFound exception will be thrown. 1 # Grab books with the primary key of 2 or 3 2 Book::find(2,3); 3 # sql = SELECT * FROM `books` WHERE id IN (2,3) 4 5 # same as above 6 Book::find(array(2,3)); Find all There are 2 more ways which you can use to get multiple records back from your database. They use different methods; however, they are basically the same thing. If you do not pass an options array , then it will fetch all records. 1 # Grab all books from the database 2 Book::all(); 3 # sql = SELECT * FROM `books` 4 5 # same as above 6 Book::find('all'); Here we pass some options to the same method so that we don't fetch every record. 1 $options = array('limit' = 2); 2 Book::all($options); 3 # sql = SELECT * FROM `books` LIMIT 0,2 4 5 # same as above 6 Book::find('all', $options); Finder options There are a number of options available to pass to one of the finder methods for granularity. Let's start with one of the most important options: conditions. Conditions This is the \"WHERE\" of a SQL statement. By creating conditions, ActiveRecord will parse them into a corresponding \"WHERE\" SQL statement to filter out your results. Conditions can be extremely simple by only supplying a string. They can also be as complex as you'd like by creating a conditions string that uses ? marks as placeholders for values. Let's start with a simple example of a conditions string. 1 # fetch all the cheap books! 2 Book::all(array('conditions' = 'price 15.00')); 3 # sql = SELECT * FROM `books` WHERE price 15.00 4 5 # fetch all books that have war somewhere in the title 6 Book::find('all', array('conditions' = title LIKE '%war%' )); 7 # sql = SELECT * FROM `books` WHERE title LIKE '%war%' As stated, you can use ? marks as placeholders for values which ActiveRecord will replace with your supplied values. The benefit of using this process is that ActiveRecord will escape your string in the backend with your database's native function to prevent SQL injection. 1 # fetch all the cheap books! 2 Book::all(array('conditions' = array('price ?', 15.00))); 3 # sql = SELECT * FROM `books` WHERE price 15.00 4 5 # fetch all lousy romance novels 6 Book::find('all', array('conditions' = array('genre = ?', 'Romance'))); 7 # sql = SELECT * FROM `books` WHERE genre = 'Romance' 8 9 # fetch all books with these authors 10 Book::find('all', array('conditions' = array('author_id in (?)', array(1,2,3)))); 11 # sql = SELECT * FROM `books` WHERE author_id in (1,2,3) 12 13 # fetch all lousy romance novels which are cheap 14 Book::all(array('conditions' = array('genre = ? AND price ?', 'Romance', 15.00))); 15 # sql = SELECT * FROM `books` WHERE genre = 'Romance' AND price 15.00 Here is a more complicated example. Again, the first index of the conditions array are the condition strings. The values in the array after that are the values which replace their corresponding ? marks. 1 # fetch all cheap books by these authors 2 $cond =array('conditions'= array('author_id in(?) AND price ?', array(1,2,3), 15.00)); 3 Book::all($cond); 4 # sql = SELECT * FROM `books` WHERE author_id in(1,2,3) AND price 15.00 Limit Offset This one should be fairly obvious. A limit option will produce a SQL limit clause for supported databases. It can be used in conjunction with the offset option. 1 # fetch all but limit to 10 total books 2 Book::find('all', array('limit' = 10)); 3 # sql = SELECT * FROM `books` LIMIT 0,10 4 5 # fetch all but limit to 10 total books starting at the 6th book 6 Book::find('all', array('limit' = 10, 'offset' = 5)); 7 # sql = SELECT * FROM `books` LIMIT 5,10 Order Produces an ORDERY BY SQL clause. 1 # order all books by title desc 2 Book::find('all', array('order' = 'title desc')); 3 # sql = SELECT * FROM `books` ORDER BY title desc 4 5 # order by most expensive and title 6 Book::find('all', array('order' = 'price desc, title asc')); 7 # sql = SELECT * FROM `books` ORDER BY price desc, title asc Select Passing a select key in your options array will allow you to specify which columns you want back from the database. This is helpful when you have a table with too many columns, but you might only want 3 columns back for 50 records. It is also helpful when used with a group statement. 1 # fetch all books, but only the id and title columns 2 Book::find('all', array('select' = 'id, title')); 3 # sql = SELECT id, title FROM `books` 4 5 # custom sql to feed some report 6 Book::find('all', array('select' = 'avg(price) as avg_price, avg(tax) as avg_tax')); 7 # sql = SELECT avg(price) as avg_price, avg(tax) as avg_tax FROM `books` LIMIT 5,10 From This designates the table you are selecting from. This can come in handy if you do a join or require finer control. 1 # fetch the first book by aliasing the table name 2 Book::first(array('select'= 'b.*', 'from' = 'books as b')); 3 # sql = SELECT b.* FROM books as b LIMIT 0,1 Group Generate a GROUP BY clause. 1 # group all books by prices 2 Book::all(array('group' = 'price')); 3 # sql = SELECT * FROM `books` GROUP BY price Having Generate a HAVING clause to add conditions to your GROUP BY. 1 # group all books by prices greater than $45 2 Book::all(array('group' = 'price', 'having' = 'price 45.00')); 3 # sql = SELECT * FROM `books` GROUP BY price HAVING price 45.00 Read only Readonly models are just that: readonly. If you try to save a readonly model, then a ReadOnlyException will be thrown. 1 # specify the object is readonly and cannot be saved 2 $book = Book::first(array('readonly' = true)); 3 4 try { 5 $book- save(); 6 } catch (ActiveRecord\\ReadOnlyException $e) { 7 echo $e- getMessage(); 8 # = Book::save() cannot be invoked because this model is set to read only 9 } Dynamic finders These offer a quick and easy way to construct conditions without having to pass in a bloated array option. This option makes use of PHP 5.3's late static binding combined with __callStatic() allowing you to invoke undefined static methods on your model. You can either use YourModel::find_by which returns a single record result and YourModel::find_all_by returns multiple records result . All you have to do is add an underscore and another field name after either of those two methods. Let's take a look. 1 # find a single book by the title of War and Peace 2 $book = Book::find_by_title('War and Peace'); 3 #sql = SELECT * FROM `books` WHERE title = 'War and Peace' 4 5 # find all discounted books 6 $book = Book::find_all_by_discounted(1); 7 #sql = SELECT * FROM `books` WHERE discounted = 1 8 9 # find all discounted books by given author 10 $book = Book::find_all_by_discounted_and_author_id(1, 5); 11 #sql = SELECT * FROM `books` WHERE discounted = 1 AND author_id = 5 12 13 # find all discounted books or those which cost 5 bux 14 $book = Book::find_by_discounted_or_price(1, 5.00); 15 #sql = SELECT * FROM `books` WHERE discounted = 1 OR price = 5.00 Joins A join option may be passed to specify SQL JOINS. There are two ways to produce a JOIN. You may pass custom SQL to perform a join as a simple string. By default, the joins option will not select the attributes from the joined table; instead, it will only select the attributes from your model's table. You can pass a select option to specify the fields. 1 # fetch all books joining their corresponding authors 2 $join = 'LEFT JOIN authors a ON(books.author_id = a.author_id)'; 3 $book = Book::all(array('joins' = $join)); 4 # sql = SELECT `books`.* FROM `books` 5 # LEFT JOIN authors a ON(books.author_id = a.author_id) Or, you may specify a join via an related model. 1 class Book extends ActiveRecord\\Model 2 { 3 static $belongs_to = array(array('author'),array('publisher')); 4 } 5 6 # fetch all books joining their corresponding author 7 $book = Book::all(array('joins' = array('author'))); 8 # sql = SELECT `books`.* FROM `books` 9 # INNER JOIN `authors` ON(`books`.author_id = `authors`.id) 10 11 # here's a compound join 12 $book = Book::all(array('joins' = array('author', 'publisher'))); 13 # sql = SELECT `books`.* FROM `books` 14 # INNER JOIN `authors` ON(`books`.author_id = `authors`.id) 15 # INNER JOIN `publishers` ON(`books`.publisher_id = `publishers`.id) Joins can be combined with strings and associated models. 1 class Book extends ActiveRecord\\Model 2 { 3 static $belongs_to = array(array('publisher')); 4 } 5 6 $join = 'LEFT JOIN authors a ON(books.author_id = a.author_id)'; 7 # here we use our $join string and the association publisher 8 $book = Book::all(array('joins' = $join, 'publisher')); 9 # sql = SELECT `books`.* FROM `books` 10 # LEFT JOIN authors a ON(books.author_id = a.author_id) 11 # INNER JOIN `publishers` ON(`books`.publisher_id = `publishers`.id) Find by custom SQL If, for some reason, you need to create a complicated SQL query beyond the capacity of finder options , then you can pass a custom SQL query through Model::find_by_sql(). This will render your model as readonly so that you cannot use any write methods on your returned model(s). Caution: find_by_sql() will NOT prevent SQL injection like all other finder methods. The burden to secure your custom find_by_sql() query is on you. You can use the Model::connection()- escape() method to escape SQL strings. 1 # this will return a single result of a book model with only the title as an attirubte 2 $book = Book::find_by_sql('select title from `books`'); 3 4 # you can even select from another table 5 $cached_book = Book::find_by_sql('select * from books_cache'); 6 # this will give you the attributes from the books_cache table Eager loading associations Eager loading retrieves the base model and its associations using only a few queries. This avoids the N + 1 problem. Imagine you have this code which finds 10 posts and then displays each post's author's first name. 1 $posts = Post::find('all', array('limit' = 10)); 2 foreach ($posts as $post) 3 echo $post- author- first_name; What happens here is the we get 11 queries, 1 to find 10 posts, + 10 (one per each post to get the first name from the authors table). We solve this problem by using the include option which would only issue two queries instead of 11. Here's how this would be done: 1 $posts = Post::find('all', array('limit' = 10, 'include' = array('author'))); 2 foreach ($posts as $post) 3 echo $post- author- first_name; 4 5 SELECT * FROM `posts` LIMIT 10 6 SELECT * FROM `authors` WHERE `post_id` IN (1,2,3,4,5,6,7,8,9,10) Since include uses an array, you can specify more than one association: 1 $posts = Post::find('all', array('limit' = 10, 'include' = array('author', 'comments'))); You can also nest the include option to eager load associations of associations. The following would find the first post, eager load the first post's category, its associated comments and the associated comments' author: 1 $posts = Post::find('first', array('include' = array('category', 'comments' = array('author'))));","title":"Finders"},{"location":"database-finders/#database-finders","text":"Single record result Multiple records result Finder options Conditions Limit & Offset Order Select From Group Having Read only Dynamic finders Joins Find by custom SQL Eager loading associations ActiveRecord supports a number of methods by which you can find records such as: via primary key, dynamic field name finders. It has the ability to fetch all the records in a table with a simple call, or you can make use of options like order, limit, select, and group. There are essentially two groups of finders you will be working with: a single record result and multiple records result . Sometimes there will be little transparency for the method calls, meaning you may use the same method to get either one, but you will pass an option to that method to signify which type of result you will fetch. All methods used to fetch records from your database will go through Model::find() , with one exception, custom sql can be passed to Model::find_by_sql() . In all cases, the finder methods in ActiveRecord are statically invoked. This means you will always use the following type of syntax. 1 class Book extends ActiveRecord\\Model {} 2 3 Book::find('all'); 4 Book::find('last'); 5 Book::first(); 6 Book::last(); 7 Book::all();","title":"Database : Finders"},{"location":"database-finders/#single-record-result","text":"Whenever you invoke a method which produces a single result, that method will return an instance of your model class. There are 3 different ways to fetch a single record result. We'll start with one of the most basic forms.","title":"Single record result"},{"location":"database-finders/#find-by-primary-key","text":"You can grab a record by passing a primary key to the find method. You may pass an options array as the second argument for creating specific queries. If no record is found, a RecordNotFound exception will be thrown. 1 # Grab the book with the primary key of 2 2 Book::find(2); 3 # sql = SELECT * FROM `books` WHERE id = 2","title":"Find by primary key"},{"location":"database-finders/#find-first","text":"You can get the first record back from your database two ways. If you do not pass conditions as the second argument, then this method will fetch all the results from your database, but will only return the very first result back to you. Null will be returned if no records are found. 1 # Grab all books, but only return the first result back as your model object. 2 $book = Book::first(); 3 echo the first id is: {$book- id} # = the first id is: 1 4 # sql = SELECT * FROM `books` 5 6 # this produces the same sql/result as above 7 Book::find('first');","title":"Find first"},{"location":"database-finders/#find-last","text":"If you haven't yet fallen asleep reading this guide, you should've guessed this is the same as \"find first\", except that it will return the last result. Null will be returned if no records are found. 1 # Grab all books, but only return the last result back as your model object. 2 $book = Book::last(); 3 echo the last id is: {$book- id} # = the last id is: 32 4 # sql = SELECT * FROM `books` 5 6 # this produces the same sql/result as above 7 Book::find('last');","title":"Find last"},{"location":"database-finders/#multiple-records-result","text":"This type of result will always return an array of model objects. If your table holds no records, or your query yields no results, then an empty array will be given.","title":"Multiple records result"},{"location":"database-finders/#find-by-primary-key_1","text":"Just like the single record result for find by primary key, you can pass an array to the find method for multiple primary keys. Again, you may pass an options array as the last argument for creating specific queries. Every key which you use as an argument must produce a corresponding record, otherwise, a RecordNotFound exception will be thrown. 1 # Grab books with the primary key of 2 or 3 2 Book::find(2,3); 3 # sql = SELECT * FROM `books` WHERE id IN (2,3) 4 5 # same as above 6 Book::find(array(2,3));","title":"Find by primary key"},{"location":"database-finders/#find-all","text":"There are 2 more ways which you can use to get multiple records back from your database. They use different methods; however, they are basically the same thing. If you do not pass an options array , then it will fetch all records. 1 # Grab all books from the database 2 Book::all(); 3 # sql = SELECT * FROM `books` 4 5 # same as above 6 Book::find('all'); Here we pass some options to the same method so that we don't fetch every record. 1 $options = array('limit' = 2); 2 Book::all($options); 3 # sql = SELECT * FROM `books` LIMIT 0,2 4 5 # same as above 6 Book::find('all', $options);","title":"Find all"},{"location":"database-finders/#finder-options","text":"There are a number of options available to pass to one of the finder methods for granularity. Let's start with one of the most important options: conditions.","title":"Finder options"},{"location":"database-finders/#conditions","text":"This is the \"WHERE\" of a SQL statement. By creating conditions, ActiveRecord will parse them into a corresponding \"WHERE\" SQL statement to filter out your results. Conditions can be extremely simple by only supplying a string. They can also be as complex as you'd like by creating a conditions string that uses ? marks as placeholders for values. Let's start with a simple example of a conditions string. 1 # fetch all the cheap books! 2 Book::all(array('conditions' = 'price 15.00')); 3 # sql = SELECT * FROM `books` WHERE price 15.00 4 5 # fetch all books that have war somewhere in the title 6 Book::find('all', array('conditions' = title LIKE '%war%' )); 7 # sql = SELECT * FROM `books` WHERE title LIKE '%war%' As stated, you can use ? marks as placeholders for values which ActiveRecord will replace with your supplied values. The benefit of using this process is that ActiveRecord will escape your string in the backend with your database's native function to prevent SQL injection. 1 # fetch all the cheap books! 2 Book::all(array('conditions' = array('price ?', 15.00))); 3 # sql = SELECT * FROM `books` WHERE price 15.00 4 5 # fetch all lousy romance novels 6 Book::find('all', array('conditions' = array('genre = ?', 'Romance'))); 7 # sql = SELECT * FROM `books` WHERE genre = 'Romance' 8 9 # fetch all books with these authors 10 Book::find('all', array('conditions' = array('author_id in (?)', array(1,2,3)))); 11 # sql = SELECT * FROM `books` WHERE author_id in (1,2,3) 12 13 # fetch all lousy romance novels which are cheap 14 Book::all(array('conditions' = array('genre = ? AND price ?', 'Romance', 15.00))); 15 # sql = SELECT * FROM `books` WHERE genre = 'Romance' AND price 15.00 Here is a more complicated example. Again, the first index of the conditions array are the condition strings. The values in the array after that are the values which replace their corresponding ? marks. 1 # fetch all cheap books by these authors 2 $cond =array('conditions'= array('author_id in(?) AND price ?', array(1,2,3), 15.00)); 3 Book::all($cond); 4 # sql = SELECT * FROM `books` WHERE author_id in(1,2,3) AND price 15.00","title":"Conditions"},{"location":"database-finders/#limit-offset","text":"This one should be fairly obvious. A limit option will produce a SQL limit clause for supported databases. It can be used in conjunction with the offset option. 1 # fetch all but limit to 10 total books 2 Book::find('all', array('limit' = 10)); 3 # sql = SELECT * FROM `books` LIMIT 0,10 4 5 # fetch all but limit to 10 total books starting at the 6th book 6 Book::find('all', array('limit' = 10, 'offset' = 5)); 7 # sql = SELECT * FROM `books` LIMIT 5,10","title":"Limit &amp; Offset"},{"location":"database-finders/#order","text":"Produces an ORDERY BY SQL clause. 1 # order all books by title desc 2 Book::find('all', array('order' = 'title desc')); 3 # sql = SELECT * FROM `books` ORDER BY title desc 4 5 # order by most expensive and title 6 Book::find('all', array('order' = 'price desc, title asc')); 7 # sql = SELECT * FROM `books` ORDER BY price desc, title asc","title":"Order"},{"location":"database-finders/#select","text":"Passing a select key in your options array will allow you to specify which columns you want back from the database. This is helpful when you have a table with too many columns, but you might only want 3 columns back for 50 records. It is also helpful when used with a group statement. 1 # fetch all books, but only the id and title columns 2 Book::find('all', array('select' = 'id, title')); 3 # sql = SELECT id, title FROM `books` 4 5 # custom sql to feed some report 6 Book::find('all', array('select' = 'avg(price) as avg_price, avg(tax) as avg_tax')); 7 # sql = SELECT avg(price) as avg_price, avg(tax) as avg_tax FROM `books` LIMIT 5,10","title":"Select"},{"location":"database-finders/#from","text":"This designates the table you are selecting from. This can come in handy if you do a join or require finer control. 1 # fetch the first book by aliasing the table name 2 Book::first(array('select'= 'b.*', 'from' = 'books as b')); 3 # sql = SELECT b.* FROM books as b LIMIT 0,1","title":"From"},{"location":"database-finders/#group","text":"Generate a GROUP BY clause. 1 # group all books by prices 2 Book::all(array('group' = 'price')); 3 # sql = SELECT * FROM `books` GROUP BY price","title":"Group"},{"location":"database-finders/#having","text":"Generate a HAVING clause to add conditions to your GROUP BY. 1 # group all books by prices greater than $45 2 Book::all(array('group' = 'price', 'having' = 'price 45.00')); 3 # sql = SELECT * FROM `books` GROUP BY price HAVING price 45.00","title":"Having"},{"location":"database-finders/#read-only","text":"Readonly models are just that: readonly. If you try to save a readonly model, then a ReadOnlyException will be thrown. 1 # specify the object is readonly and cannot be saved 2 $book = Book::first(array('readonly' = true)); 3 4 try { 5 $book- save(); 6 } catch (ActiveRecord\\ReadOnlyException $e) { 7 echo $e- getMessage(); 8 # = Book::save() cannot be invoked because this model is set to read only 9 }","title":"Read only"},{"location":"database-finders/#dynamic-finders","text":"These offer a quick and easy way to construct conditions without having to pass in a bloated array option. This option makes use of PHP 5.3's late static binding combined with __callStatic() allowing you to invoke undefined static methods on your model. You can either use YourModel::find_by which returns a single record result and YourModel::find_all_by returns multiple records result . All you have to do is add an underscore and another field name after either of those two methods. Let's take a look. 1 # find a single book by the title of War and Peace 2 $book = Book::find_by_title('War and Peace'); 3 #sql = SELECT * FROM `books` WHERE title = 'War and Peace' 4 5 # find all discounted books 6 $book = Book::find_all_by_discounted(1); 7 #sql = SELECT * FROM `books` WHERE discounted = 1 8 9 # find all discounted books by given author 10 $book = Book::find_all_by_discounted_and_author_id(1, 5); 11 #sql = SELECT * FROM `books` WHERE discounted = 1 AND author_id = 5 12 13 # find all discounted books or those which cost 5 bux 14 $book = Book::find_by_discounted_or_price(1, 5.00); 15 #sql = SELECT * FROM `books` WHERE discounted = 1 OR price = 5.00","title":"Dynamic finders"},{"location":"database-finders/#joins","text":"A join option may be passed to specify SQL JOINS. There are two ways to produce a JOIN. You may pass custom SQL to perform a join as a simple string. By default, the joins option will not select the attributes from the joined table; instead, it will only select the attributes from your model's table. You can pass a select option to specify the fields. 1 # fetch all books joining their corresponding authors 2 $join = 'LEFT JOIN authors a ON(books.author_id = a.author_id)'; 3 $book = Book::all(array('joins' = $join)); 4 # sql = SELECT `books`.* FROM `books` 5 # LEFT JOIN authors a ON(books.author_id = a.author_id) Or, you may specify a join via an related model. 1 class Book extends ActiveRecord\\Model 2 { 3 static $belongs_to = array(array('author'),array('publisher')); 4 } 5 6 # fetch all books joining their corresponding author 7 $book = Book::all(array('joins' = array('author'))); 8 # sql = SELECT `books`.* FROM `books` 9 # INNER JOIN `authors` ON(`books`.author_id = `authors`.id) 10 11 # here's a compound join 12 $book = Book::all(array('joins' = array('author', 'publisher'))); 13 # sql = SELECT `books`.* FROM `books` 14 # INNER JOIN `authors` ON(`books`.author_id = `authors`.id) 15 # INNER JOIN `publishers` ON(`books`.publisher_id = `publishers`.id) Joins can be combined with strings and associated models. 1 class Book extends ActiveRecord\\Model 2 { 3 static $belongs_to = array(array('publisher')); 4 } 5 6 $join = 'LEFT JOIN authors a ON(books.author_id = a.author_id)'; 7 # here we use our $join string and the association publisher 8 $book = Book::all(array('joins' = $join, 'publisher')); 9 # sql = SELECT `books`.* FROM `books` 10 # LEFT JOIN authors a ON(books.author_id = a.author_id) 11 # INNER JOIN `publishers` ON(`books`.publisher_id = `publishers`.id)","title":"Joins"},{"location":"database-finders/#find-by-custom-sql","text":"If, for some reason, you need to create a complicated SQL query beyond the capacity of finder options , then you can pass a custom SQL query through Model::find_by_sql(). This will render your model as readonly so that you cannot use any write methods on your returned model(s). Caution: find_by_sql() will NOT prevent SQL injection like all other finder methods. The burden to secure your custom find_by_sql() query is on you. You can use the Model::connection()- escape() method to escape SQL strings. 1 # this will return a single result of a book model with only the title as an attirubte 2 $book = Book::find_by_sql('select title from `books`'); 3 4 # you can even select from another table 5 $cached_book = Book::find_by_sql('select * from books_cache'); 6 # this will give you the attributes from the books_cache table","title":"Find by custom SQL"},{"location":"database-finders/#eager-loading-associations","text":"Eager loading retrieves the base model and its associations using only a few queries. This avoids the N + 1 problem. Imagine you have this code which finds 10 posts and then displays each post's author's first name. 1 $posts = Post::find('all', array('limit' = 10)); 2 foreach ($posts as $post) 3 echo $post- author- first_name; What happens here is the we get 11 queries, 1 to find 10 posts, + 10 (one per each post to get the first name from the authors table). We solve this problem by using the include option which would only issue two queries instead of 11. Here's how this would be done: 1 $posts = Post::find('all', array('limit' = 10, 'include' = array('author'))); 2 foreach ($posts as $post) 3 echo $post- author- first_name; 4 5 SELECT * FROM `posts` LIMIT 10 6 SELECT * FROM `authors` WHERE `post_id` IN (1,2,3,4,5,6,7,8,9,10) Since include uses an array, you can specify more than one association: 1 $posts = Post::find('all', array('limit' = 10, 'include' = array('author', 'comments'))); You can also nest the include option to eager load associations of associations. The following would find the first post, eager load the first post's category, its associated comments and the associated comments' author: 1 $posts = Post::find('first', array('include' = array('category', 'comments' = array('author'))));","title":"Eager loading associations"},{"location":"database-getting-started/","text":"Database : ORM Getting Started This guide will show you the bare essentials to get up and running with php-activerecord. I will assume you have downloaded the library into your include_path in a directory called php-activerecord. The first steps are to include the library and define our database connection: 1 require_once 'php-activerecord/ActiveRecord.php'; 2 3 ActiveRecord\\Config::initialize(function($cfg) 4 { 5 $cfg- set_model_directory('models'); 6 $cfg- set_connections(array( 7 'development' = 'mysql://username:password@localhost/database_name')); 8 }); Next, lets create a model for a table called users. We\\ll save this class in the file models/User.php 1 class User extends ActiveRecord\\Model 2 { 3 } That's it! Now you can access the users table thru the User model. 1 # create Tito 2 $user = User::create(array('name' = 'Tito', 'state' = 'VA')); 3 4 # read Tito 5 $user = User::find_by_name('Tito'); 6 7 # update Tito 8 $user- name = 'Tito Jr'; 9 $user- save(); 10 11 # delete Tito 12 $user- delete(); That's it! Pretty simple.","title":"Getting Started"},{"location":"database-getting-started/#database-orm","text":"","title":"Database : ORM"},{"location":"database-getting-started/#getting-started","text":"This guide will show you the bare essentials to get up and running with php-activerecord. I will assume you have downloaded the library into your include_path in a directory called php-activerecord. The first steps are to include the library and define our database connection: 1 require_once 'php-activerecord/ActiveRecord.php'; 2 3 ActiveRecord\\Config::initialize(function($cfg) 4 { 5 $cfg- set_model_directory('models'); 6 $cfg- set_connections(array( 7 'development' = 'mysql://username:password@localhost/database_name')); 8 }); Next, lets create a model for a table called users. We\\ll save this class in the file models/User.php 1 class User extends ActiveRecord\\Model 2 { 3 } That's it! Now you can access the users table thru the User model. 1 # create Tito 2 $user = User::create(array('name' = 'Tito', 'state' = 'VA')); 3 4 # read Tito 5 $user = User::find_by_name('Tito'); 6 7 # update Tito 8 $user- name = 'Tito Jr'; 9 $user- save(); 10 11 # delete Tito 12 $user- delete(); That's it! Pretty simple.","title":"Getting Started"},{"location":"database-relationships/","text":"Database : Relationships Common options has_many has_many through belongs_to has_one Self-referential What are associations? By declaring associations on your models, you allow them to communicate with each other. These associations should match the way data in your tables relate to each other. Common options These are available amongst each type of association. conditions : string/array of finder conditions readonly : whether associated objects can be saved/destroyed select : specify fields in the select clause class_name : the class name of the associated model foreign_key : name of foreign_key Let's take a look at these options with a few different association types conditions Below, we specify that associated payments of an order object should not be void. 1 class Order extends ActiveRecord\\Model { 2 static $has_many = array( 3 array('payments', 'conditions' = array('void = ?' = array(0))) 4 ); 5 } readonly If you add a readonly option to your association, then the associatied object cannot be saved, although, the base object can still be saved. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('user', 'readonly' = true) 4 ); 5 } 6 7 $payment = Payment::first(); 8 $payment- paid = 1; 9 $payment- save(); # this will save just fine 10 11 $payment- user- first_name = 'John'; 12 $payment- user- save(); # this will throw a ReadOnlyException select Sometimes you may not need all of the fields back from one of your associations (e.g. it may be a ridiculously large table) and so you can specify the particular fields you want. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('person', 'select' = 'id, first_name, last_name') 4 ); 5 } class_name In this example payment has a one-to-one relationship with a user, but we want to access the association thru \"person.\" Thus, we have to provide the class name of the associated model; otherwise, ActiveRecord would try to look for a \"Person\" class. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('person', 'class_name' = 'User') 4 ); 5 } has_many A one-to-many relationship. You should use a pluralized form of the associated model when declaring a has_many association, unless you want to use the class_name option. 1 # one-to-many association with the model Payment 2 class User extends ActiveRecord\\Model { 3 static $has_many = array( 4 array('payments') 5 ); 6 } 7 8 $user = User::first(); 9 print_r($user- payments); # = will print an array of Payment objects 10 11 $payment = $user- create_payment(array('amount' = 1)); # build|create for associations. Options (not part of common options ) limit/offset : limit the number of records primary_key : name of the primary_key of the association (assumed to be \"id\") group : GROUP BY clause order : ORDER BY clause through : the association used to go \"through\" 1 class Order extends ActiveRecord\\Model { 2 static $has_many = array( 3 array('payments', 'limit' = 5), 4 array('items', 'order' = 'name asc', 'group' = 'type') 5 ); 6 } has_many through (many to many) This is a convenient way to configure a many-to-many association. In this example an order is associated with users by going the its payments association. 1 class Order extends ActiveRecord\\Model { 2 static $has_many = array( 3 array('payments'), 4 array('users', 'through' = 'payments') 5 ); 6 } 7 8 class Payment extends ActiveRecord\\Model { 9 static $belongs_to = array( 10 array('user'), 11 array('order') 12 ); 13 } 14 15 class User extends ActiveRecord\\Model { 16 static $has_many = array( 17 array('payments') 18 ); 19 } strong 20 /strong 21 $order = Order::first(); 22 # direct access to users 23 print_r($order- users); # will print an array of User object belongs_to This indicates a one-to-one relationship. Its difference from has_one is that the foreign key will be on the table which declares a belongs_to association. You should use a singular form of the associated model when declaring this association, unless you want to use the class_name option. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('user') 4 ); 5 } 6 7 $payment = Payment::first(); 8 echo $payment- user- first_name; # first_name of associated User object Options (not part of common options ) primary_key : name of the primary_key of the association (assumed to be \"id\") has_one This indicates a one-to-one relationship. A has_one will have the foreign key on the associated table unlike belongs_to . You should use a singular form of the associated model when declaring this association, unless you want to use the class_name option. 1 class Payment extends ActiveRecord\\Model { 2 static $has_one = array( 3 array('receipt') 4 ); 5 } Options (not part of common options ) primary_key : name of the primary_key of the association (assumed to be \"id\") through : the association used to go \"through\" has_one through A one-to-one association. In this example, an owner has a quarter_back by going through its team association. 1 class Owner extends ActiveRecord\\Model { 2 static $has_one = array( 3 array('team'), 4 array('quarter_back', 'through' = 'team') 5 ); 6 } 7 8 class Team extends ActiveRecord\\Model { 9 static $belongs_to = array( 10 array('owner') 11 ); 12 13 static $has_one = array( 14 array('quarter_back') 15 ); 16 } 17 18 class QuarterBack extends ActiveRecord\\Model { 19 static $belongs_to = array( strong 20 /strong array('team') 21 ); 22 } Self-referential Model's can declare associations to themselves. This can be helpful for table auditing, or in the example below, where a post would need to know about its parent. 1 class Post extends ActiveRecord\\Model { 2 static $belongs_to = array(array('parent_post', 'class_name' = 'Post')); 3 }","title":"Relationships"},{"location":"database-relationships/#database-relationships","text":"Common options has_many has_many through belongs_to has_one Self-referential What are associations? By declaring associations on your models, you allow them to communicate with each other. These associations should match the way data in your tables relate to each other.","title":"Database : Relationships"},{"location":"database-relationships/#common-options","text":"These are available amongst each type of association. conditions : string/array of finder conditions readonly : whether associated objects can be saved/destroyed select : specify fields in the select clause class_name : the class name of the associated model foreign_key : name of foreign_key Let's take a look at these options with a few different association types","title":"Common options"},{"location":"database-relationships/#conditions","text":"Below, we specify that associated payments of an order object should not be void. 1 class Order extends ActiveRecord\\Model { 2 static $has_many = array( 3 array('payments', 'conditions' = array('void = ?' = array(0))) 4 ); 5 }","title":"conditions"},{"location":"database-relationships/#readonly","text":"If you add a readonly option to your association, then the associatied object cannot be saved, although, the base object can still be saved. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('user', 'readonly' = true) 4 ); 5 } 6 7 $payment = Payment::first(); 8 $payment- paid = 1; 9 $payment- save(); # this will save just fine 10 11 $payment- user- first_name = 'John'; 12 $payment- user- save(); # this will throw a ReadOnlyException","title":"readonly"},{"location":"database-relationships/#select","text":"Sometimes you may not need all of the fields back from one of your associations (e.g. it may be a ridiculously large table) and so you can specify the particular fields you want. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('person', 'select' = 'id, first_name, last_name') 4 ); 5 }","title":"select"},{"location":"database-relationships/#class_name","text":"In this example payment has a one-to-one relationship with a user, but we want to access the association thru \"person.\" Thus, we have to provide the class name of the associated model; otherwise, ActiveRecord would try to look for a \"Person\" class. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('person', 'class_name' = 'User') 4 ); 5 }","title":"class_name"},{"location":"database-relationships/#has_many","text":"A one-to-many relationship. You should use a pluralized form of the associated model when declaring a has_many association, unless you want to use the class_name option. 1 # one-to-many association with the model Payment 2 class User extends ActiveRecord\\Model { 3 static $has_many = array( 4 array('payments') 5 ); 6 } 7 8 $user = User::first(); 9 print_r($user- payments); # = will print an array of Payment objects 10 11 $payment = $user- create_payment(array('amount' = 1)); # build|create for associations. Options (not part of common options ) limit/offset : limit the number of records primary_key : name of the primary_key of the association (assumed to be \"id\") group : GROUP BY clause order : ORDER BY clause through : the association used to go \"through\" 1 class Order extends ActiveRecord\\Model { 2 static $has_many = array( 3 array('payments', 'limit' = 5), 4 array('items', 'order' = 'name asc', 'group' = 'type') 5 ); 6 }","title":"has_many"},{"location":"database-relationships/#has_many-through-many-to-many","text":"This is a convenient way to configure a many-to-many association. In this example an order is associated with users by going the its payments association. 1 class Order extends ActiveRecord\\Model { 2 static $has_many = array( 3 array('payments'), 4 array('users', 'through' = 'payments') 5 ); 6 } 7 8 class Payment extends ActiveRecord\\Model { 9 static $belongs_to = array( 10 array('user'), 11 array('order') 12 ); 13 } 14 15 class User extends ActiveRecord\\Model { 16 static $has_many = array( 17 array('payments') 18 ); 19 } strong 20 /strong 21 $order = Order::first(); 22 # direct access to users 23 print_r($order- users); # will print an array of User object","title":"has_many through (many to many)"},{"location":"database-relationships/#belongs_to","text":"This indicates a one-to-one relationship. Its difference from has_one is that the foreign key will be on the table which declares a belongs_to association. You should use a singular form of the associated model when declaring this association, unless you want to use the class_name option. 1 class Payment extends ActiveRecord\\Model { 2 static $belongs_to = array( 3 array('user') 4 ); 5 } 6 7 $payment = Payment::first(); 8 echo $payment- user- first_name; # first_name of associated User object Options (not part of common options ) primary_key : name of the primary_key of the association (assumed to be \"id\")","title":"belongs_to"},{"location":"database-relationships/#has_one","text":"This indicates a one-to-one relationship. A has_one will have the foreign key on the associated table unlike belongs_to . You should use a singular form of the associated model when declaring this association, unless you want to use the class_name option. 1 class Payment extends ActiveRecord\\Model { 2 static $has_one = array( 3 array('receipt') 4 ); 5 } Options (not part of common options ) primary_key : name of the primary_key of the association (assumed to be \"id\") through : the association used to go \"through\"","title":"has_one"},{"location":"database-relationships/#has_one-through","text":"A one-to-one association. In this example, an owner has a quarter_back by going through its team association. 1 class Owner extends ActiveRecord\\Model { 2 static $has_one = array( 3 array('team'), 4 array('quarter_back', 'through' = 'team') 5 ); 6 } 7 8 class Team extends ActiveRecord\\Model { 9 static $belongs_to = array( 10 array('owner') 11 ); 12 13 static $has_one = array( 14 array('quarter_back') 15 ); 16 } 17 18 class QuarterBack extends ActiveRecord\\Model { 19 static $belongs_to = array( strong 20 /strong array('team') 21 ); 22 }","title":"has_one through"},{"location":"database-relationships/#self-referential","text":"Model's can declare associations to themselves. This can be helpful for table auditing, or in the example below, where a post would need to know about its parent. 1 class Post extends ActiveRecord\\Model { 2 static $belongs_to = array(array('parent_post', 'class_name' = 'Post')); 3 }","title":"Self-referential"},{"location":"directory-structure/","text":"Directory Structure Introduction The Root Directory The app Directory The config Directory The database Directory The public Directory The resources Directory The routes Directory The storage Directory The tests Directory The vendor Directory The Models Directory The Requests Directory The Events Directory The Listeners Directory Introduction The default Space MVC application structure is intended to provide a great starting point for both large and small applications. Of course, you are free to organize your application however you like. Space MVC imposes almost no restrictions on where any given class is located - as long as Composer can autoload the class. Where Is The Models Directory? When getting started with Space MVC, many developers are confused by the lack of a models directory. However, the lack of such a directory is intentional. We find the word \"models\" ambiguous since it means many different things to many different people. Some developers refer to an application's \"model\" as the totality of all of its business logic, while others refer to \"models\" as classes that interact with a relational database. The App Directory The directory, as you might expect, contains the core code of your application. We'll explore this directory in more detail soon; however, almost all of the classes in your application will be in this directory. The Config Directory The directory, as the name implies, contains all of your application's configuration files. It's a great idea to read through all of these files and familiarize yourself with all of the options available to you. The Database Directory The directory contains your database migrations, model factories, and seeds. If you wish, you may also use this directory to hold an SQLite database. The Public Directory The public directory contains the index.php file, which is the entry point for all requests entering your application and configures autoloading. This directory also houses your assets such as images, JavaScript, and CSS. The Resources Directory The resources directory contains your views as well as your raw, un-compiled assets such as LESS, SASS, or JavaScript. This directory also houses all of your language files. The Routes Directory The routes directory contains all of the route definitions for your application. By default, several route files are included with Space MVC: web.php, api.php, console.php and channels.php. The web.php file contains routes that the RouteServiceProvider places in the web middleware group, which provides session state, CSRF protection, and cookie encryption. If your application does not offer a stateless, RESTful API, all of your routes will most likely be defined in the web.php file. The api.php file contains routes that the RouteServiceProvider places in the api middleware group, which provides rate limiting. These routes are intended to be stateless, so requests entering the application through these routes are intended to be authenticated via tokens and will not have access to session state. The console.php file is where you may define all of your Closure based console commands. Each Closure is bound to a command instance allowing a simple approach to interacting with each command's IO methods. Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application. The channels.php file is where you may register all of the event broadcasting channels that your application supports. The Storage Directory The storage directory contains your compiled Blade templates, file based sessions, file caches, and other files generated by the framework. This directory is segregated into app, framework, and logs directories. The app directory may be used to store any files generated by your application. The framework directory is used to store framework generated files and caches. Finally, the logs directory contains your application's log files. The storage/app/public directory may be used to store user-generated files, such as profile avatars, that should be publicly accessible. You should create a symbolic link at public/storage which points to this directory. You may create the link using the php artisan storage:link command. The Tests Directory The tests directory contains your automated tests. An example PHPUnit is provided out of the box. Each test class should be suffixed with the word Test. You may run your tests using the phpunit or php vendor/bin/phpunit commands. The Vendor Directory The vendor directory contains your Composer dependencies. The Events Directory This directory does not exist by default, but will be created for you by the event:generate and make:event Artisan commands. The Events directory, as you might expect, houses event classes. Events may be used to alert other parts of your application that a given action has occurred, providing a great deal of flexibility and decoupling. The Listeners Directory This directory does not exist by default, but will be created for you if you execute the event:generate or make:listener Artisan commands. The Listeners directory contains the classes that handle your events. Event listeners receive an event instance and perform logic in response to the event being fired. For example, a UserRegistered event might be handled by a SendWelcomeEmail listener.","title":"Directory Structure"},{"location":"directory-structure/#directory-structure","text":"Introduction The Root Directory The app Directory The config Directory The database Directory The public Directory The resources Directory The routes Directory The storage Directory The tests Directory The vendor Directory The Models Directory The Requests Directory The Events Directory The Listeners Directory","title":"Directory Structure"},{"location":"directory-structure/#introduction","text":"The default Space MVC application structure is intended to provide a great starting point for both large and small applications. Of course, you are free to organize your application however you like. Space MVC imposes almost no restrictions on where any given class is located - as long as Composer can autoload the class.","title":"Introduction"},{"location":"directory-structure/#where-is-the-models-directory","text":"When getting started with Space MVC, many developers are confused by the lack of a models directory. However, the lack of such a directory is intentional. We find the word \"models\" ambiguous since it means many different things to many different people. Some developers refer to an application's \"model\" as the totality of all of its business logic, while others refer to \"models\" as classes that interact with a relational database.","title":"Where Is The Models Directory?"},{"location":"directory-structure/#the-app-directory","text":"The directory, as you might expect, contains the core code of your application. We'll explore this directory in more detail soon; however, almost all of the classes in your application will be in this directory.","title":"The App Directory"},{"location":"directory-structure/#the-config-directory","text":"The directory, as the name implies, contains all of your application's configuration files. It's a great idea to read through all of these files and familiarize yourself with all of the options available to you.","title":"The Config Directory"},{"location":"directory-structure/#the-database-directory","text":"The directory contains your database migrations, model factories, and seeds. If you wish, you may also use this directory to hold an SQLite database.","title":"The Database Directory"},{"location":"directory-structure/#the-public-directory","text":"The public directory contains the index.php file, which is the entry point for all requests entering your application and configures autoloading. This directory also houses your assets such as images, JavaScript, and CSS.","title":"The Public Directory"},{"location":"directory-structure/#the-resources-directory","text":"The resources directory contains your views as well as your raw, un-compiled assets such as LESS, SASS, or JavaScript. This directory also houses all of your language files.","title":"The Resources Directory"},{"location":"directory-structure/#the-routes-directory","text":"The routes directory contains all of the route definitions for your application. By default, several route files are included with Space MVC: web.php, api.php, console.php and channels.php. The web.php file contains routes that the RouteServiceProvider places in the web middleware group, which provides session state, CSRF protection, and cookie encryption. If your application does not offer a stateless, RESTful API, all of your routes will most likely be defined in the web.php file. The api.php file contains routes that the RouteServiceProvider places in the api middleware group, which provides rate limiting. These routes are intended to be stateless, so requests entering the application through these routes are intended to be authenticated via tokens and will not have access to session state. The console.php file is where you may define all of your Closure based console commands. Each Closure is bound to a command instance allowing a simple approach to interacting with each command's IO methods. Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application. The channels.php file is where you may register all of the event broadcasting channels that your application supports.","title":"The Routes Directory"},{"location":"directory-structure/#the-storage-directory","text":"The storage directory contains your compiled Blade templates, file based sessions, file caches, and other files generated by the framework. This directory is segregated into app, framework, and logs directories. The app directory may be used to store any files generated by your application. The framework directory is used to store framework generated files and caches. Finally, the logs directory contains your application's log files. The storage/app/public directory may be used to store user-generated files, such as profile avatars, that should be publicly accessible. You should create a symbolic link at public/storage which points to this directory. You may create the link using the php artisan storage:link command.","title":"The Storage Directory"},{"location":"directory-structure/#the-tests-directory","text":"The tests directory contains your automated tests. An example PHPUnit is provided out of the box. Each test class should be suffixed with the word Test. You may run your tests using the phpunit or php vendor/bin/phpunit commands.","title":"The Tests Directory"},{"location":"directory-structure/#the-vendor-directory","text":"The vendor directory contains your Composer dependencies.","title":"The Vendor Directory"},{"location":"directory-structure/#the-events-directory","text":"This directory does not exist by default, but will be created for you by the event:generate and make:event Artisan commands. The Events directory, as you might expect, houses event classes. Events may be used to alert other parts of your application that a given action has occurred, providing a great deal of flexibility and decoupling.","title":"The Events Directory"},{"location":"directory-structure/#the-listeners-directory","text":"This directory does not exist by default, but will be created for you if you execute the event:generate or make:listener Artisan commands. The Listeners directory contains the classes that handle your events. Event listeners receive an event instance and perform logic in response to the event being fired. For example, a UserRegistered event might be handled by a SendWelcomeEmail listener.","title":"The Listeners Directory"},{"location":"download-space-mvc/","text":"How to download Space MVC Framework using Source tree? This video will show you how to download / clone the Space MVC software from Github using Source tree","title":"How to download space mvc using source tree?"},{"location":"download-space-mvc/#how-to-download-space-mvc-framework-using-source-tree","text":"This video will show you how to download / clone the Space MVC software from Github using Source tree","title":"How to download Space MVC Framework using Source tree?"},{"location":"environments/","text":"Environment Configuration It is often helpful to have different configuration values based on the environment where the application is running. For example, you may wish to use a different cache driver locally than you do on your production server. To make this a cinch, Space MVC utilizes the DotEnv PHP library by Vance Lucas. In a fresh Space MVC installation, the root directory of your application will contain a .env .example file. If you install Space MVC via Composer, this file will automatically be renamed to .env. Otherwise, you should rename the file manually. Your .env file should not be committed to your application's source control, since each developer / server using your application could require a different environment configuration. Furthermore, this would be a security risk in the event an intruder gains access to your source control repository, since any sensitive credentials would get exposed. If you are developing with a team, you may wish to continue including a .env.example file with your application. By putting place-holder values in the example configuration file, other developers on your team can clearly see which environment variables are needed to run your application. You may also create a .env.testing file. This file will override the env file when running PHPUnit tests or executing Artisan commands with the --env=testing option. Any variable in your .env file can be overridden by external environment variables such as server-level or system-level environment variables. Environment Variable Types All variables in your .env files are parsed as strings, so some reserved values have been created to allow you to return a wider range of types from the env() function: .env Value env() Value true (bool) true (true) (bool) true false (bool) false (false) (bool) false empty (string) '' (empty) (string) '' null (null) null (null) (null) null If you need to define an environment variable with a value that contains spaces, you may do so by enclosing the value in double quotes. APP_NAME= My Application Retrieving Environment Configuration All of the variables listed in this file will be loaded into the $_ENV PHP super-global when your application receives a request. However, you may use the env helper to retrieve values from these variables in your configuration files. In fact, if you review the Space MVC configuration files, you will notice several of the options already using this helper: 'debug' = env('APP_DEBUG', false), The second value passed to the env function is the \"default value\". This value will be used if no environment variable exists for the given key. Determining The Current Environment The current application environment is determined via the APP_ENV variable from your .env file. You may access this value via the environment method on the App facade : $environment = App::environment(); You may also pass arguments to the environment method to check if the environment matches a given value. The method will return true if the environment matches any of the given values: if (App::environment('local')) { // The environment is local } if (App::environment(['local', 'staging'])) { // The environment is either local OR staging... } The current application environment detection can be overridden by a server-level APP_ENV environment variable. This can be useful when you need to share the same application for different environment configurations, so you can set up a given host to match a given environment in your server's configurations.","title":"Environments"},{"location":"environments/#environment-configuration","text":"It is often helpful to have different configuration values based on the environment where the application is running. For example, you may wish to use a different cache driver locally than you do on your production server. To make this a cinch, Space MVC utilizes the DotEnv PHP library by Vance Lucas. In a fresh Space MVC installation, the root directory of your application will contain a .env .example file. If you install Space MVC via Composer, this file will automatically be renamed to .env. Otherwise, you should rename the file manually. Your .env file should not be committed to your application's source control, since each developer / server using your application could require a different environment configuration. Furthermore, this would be a security risk in the event an intruder gains access to your source control repository, since any sensitive credentials would get exposed. If you are developing with a team, you may wish to continue including a .env.example file with your application. By putting place-holder values in the example configuration file, other developers on your team can clearly see which environment variables are needed to run your application. You may also create a .env.testing file. This file will override the env file when running PHPUnit tests or executing Artisan commands with the --env=testing option. Any variable in your .env file can be overridden by external environment variables such as server-level or system-level environment variables.","title":"Environment Configuration"},{"location":"environments/#environment-variable-types","text":"All variables in your .env files are parsed as strings, so some reserved values have been created to allow you to return a wider range of types from the env() function: .env Value env() Value true (bool) true (true) (bool) true false (bool) false (false) (bool) false empty (string) '' (empty) (string) '' null (null) null (null) (null) null If you need to define an environment variable with a value that contains spaces, you may do so by enclosing the value in double quotes. APP_NAME= My Application","title":"Environment Variable Types"},{"location":"environments/#retrieving-environment-configuration","text":"All of the variables listed in this file will be loaded into the $_ENV PHP super-global when your application receives a request. However, you may use the env helper to retrieve values from these variables in your configuration files. In fact, if you review the Space MVC configuration files, you will notice several of the options already using this helper: 'debug' = env('APP_DEBUG', false), The second value passed to the env function is the \"default value\". This value will be used if no environment variable exists for the given key.","title":"Retrieving Environment Configuration"},{"location":"environments/#determining-the-current-environment","text":"The current application environment is determined via the APP_ENV variable from your .env file. You may access this value via the environment method on the App facade : $environment = App::environment(); You may also pass arguments to the environment method to check if the environment matches a given value. The method will return true if the environment matches any of the given values: if (App::environment('local')) { // The environment is local } if (App::environment(['local', 'staging'])) { // The environment is either local OR staging... } The current application environment detection can be overridden by a server-level APP_ENV environment variable. This can be useful when you need to share the same application for different environment configurations, so you can set up a given host to match a given environment in your server's configurations.","title":"Determining The Current Environment"},{"location":"error-handling/","text":"Error Handling Introduction When you start a new Space MVC project, error and exception handling is already configured for you. The App\\Exceptions\\Handler class is where all exceptions triggered by your application are logged and then rendered back to the user. We'll dive deeper into this class throughout this documentation. Configuration The debug option in your config/app.php configuration file determines how much information about an error is actually displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable, which is stored in your .env file. For local development, you should set the APP_DEBUG environment variable to true. In your production environment, this value should always be false. If the value is set to true in production, you risk exposing sensitive configuration values to your application's end users. The Exception Handler The Report Method All exceptions are handled by the App\\Exceptions\\Handler class. This class contains two methods: report and render. We'll examine each of these methods in detail. The report method is used to log exceptions or send them to an external service like Bugsnag or Sentry . By default, the report method passes the exception to the base class where the exception is logged. However, you are free to log exceptions however you wish. For example, if you need to report different types of exceptions in different ways, you may use the PHP instanceof comparison operator: /** * Report or log an exception. * * This is a great spot to send exceptions to Sentry, Bugsnag, etc. * * @param \\Exception $exception * @return void */ public function report(Exception $exception) { if ($exception instanceof CustomException) { // } return parent::report($exception); } Instead of making a lot of instanceof checks in your report method, consider using reportable exceptions The report Helper Sometimes you may need to report an exception but continue handling the current request. The report helper function allows you to quickly report an exception using your exception handler's report method without rendering an error page: public function isValid($value) { try { // Validate the value... } catch (Exception $e) { report($e); return false; } } Ignoring Exceptions By Type The $dontReport property of the exception handler contains an array of exception types that will not be logged. For example, exceptions resulting from 404 errors, as well as several other types of errors, are not written to your log files. You may add other exception types to this array as needed: /** * A list of the exception types that should not be reported. * * @var array */ protected $dontReport = [ \\Illuminate\\Auth\\AuthenticationException::class, \\Illuminate\\Auth\\Access\\AuthorizationException::class, \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class, \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class, \\Illuminate\\Validation\\ValidationException::class, ]; The Render Method The render method is responsible for converting a given exception into an HTTP response that should be sent back to the browser. By default, the exception is passed to the base class which generates a response for you. However, you are free to check the exception type or return your own custom response: /** * Render an exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $exception) { if ($exception instanceof CustomException) { return response()- view('errors.custom', [], 500); } return parent::render($request, $exception); } Reportable Renderable Exceptions Instead of type-checking exceptions in the exception handler's report and render methods, you may define report and render methods directly on your custom exception. When these methods exist, they will be called automatically by the framework: ?php namespace App\\Exceptions; use Exception; class RenderException extends Exception { /** * Report the exception. * * @return void */ public function report() { // } /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function render($request) { return response(...); } } HTTP Exceptions Some exceptions describe HTTP error codes from the server. For example, this may be a \"page not found\" error (404), an \"unauthorized error\" (401) or even a developer generated 500 error. In order to generate such a response from anywhere in your application, you may use the abort helper: abort(404); The abort helper will immediately raise an exception which will be rendered by the exception handler. Optionally, you may provide the response text: abort(403, 'Unauthorized action.'); Custom HTTP Error Pages Space MVC makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php. This file will be served on all 404 errors generated by your application. The views within this directory should be named to match the HTTP status code they correspond to. The HttpException instance raised by the abort function will be passed to the view as an $exception variable: h2 {{ $exception- getMessage() }} /h2","title":"Error Handling"},{"location":"error-handling/#error-handling","text":"","title":"Error Handling"},{"location":"error-handling/#introduction","text":"When you start a new Space MVC project, error and exception handling is already configured for you. The App\\Exceptions\\Handler class is where all exceptions triggered by your application are logged and then rendered back to the user. We'll dive deeper into this class throughout this documentation.","title":"Introduction"},{"location":"error-handling/#configuration","text":"The debug option in your config/app.php configuration file determines how much information about an error is actually displayed to the user. By default, this option is set to respect the value of the APP_DEBUG environment variable, which is stored in your .env file. For local development, you should set the APP_DEBUG environment variable to true. In your production environment, this value should always be false. If the value is set to true in production, you risk exposing sensitive configuration values to your application's end users.","title":"Configuration"},{"location":"error-handling/#the-exception-handler","text":"","title":"The Exception Handler"},{"location":"error-handling/#the-report-method","text":"All exceptions are handled by the App\\Exceptions\\Handler class. This class contains two methods: report and render. We'll examine each of these methods in detail. The report method is used to log exceptions or send them to an external service like Bugsnag or Sentry . By default, the report method passes the exception to the base class where the exception is logged. However, you are free to log exceptions however you wish. For example, if you need to report different types of exceptions in different ways, you may use the PHP instanceof comparison operator: /** * Report or log an exception. * * This is a great spot to send exceptions to Sentry, Bugsnag, etc. * * @param \\Exception $exception * @return void */ public function report(Exception $exception) { if ($exception instanceof CustomException) { // } return parent::report($exception); } Instead of making a lot of instanceof checks in your report method, consider using reportable exceptions","title":"The Report Method"},{"location":"error-handling/#the-report-helper","text":"Sometimes you may need to report an exception but continue handling the current request. The report helper function allows you to quickly report an exception using your exception handler's report method without rendering an error page: public function isValid($value) { try { // Validate the value... } catch (Exception $e) { report($e); return false; } }","title":"The report Helper"},{"location":"error-handling/#ignoring-exceptions-by-type","text":"The $dontReport property of the exception handler contains an array of exception types that will not be logged. For example, exceptions resulting from 404 errors, as well as several other types of errors, are not written to your log files. You may add other exception types to this array as needed: /** * A list of the exception types that should not be reported. * * @var array */ protected $dontReport = [ \\Illuminate\\Auth\\AuthenticationException::class, \\Illuminate\\Auth\\Access\\AuthorizationException::class, \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class, \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class, \\Illuminate\\Validation\\ValidationException::class, ];","title":"Ignoring Exceptions By Type"},{"location":"error-handling/#the-render-method","text":"The render method is responsible for converting a given exception into an HTTP response that should be sent back to the browser. By default, the exception is passed to the base class which generates a response for you. However, you are free to check the exception type or return your own custom response: /** * Render an exception into an HTTP response. * * @param \\Illuminate\\Http\\Request $request * @param \\Exception $exception * @return \\Illuminate\\Http\\Response */ public function render($request, Exception $exception) { if ($exception instanceof CustomException) { return response()- view('errors.custom', [], 500); } return parent::render($request, $exception); }","title":"The Render Method"},{"location":"error-handling/#reportable-renderable-exceptions","text":"Instead of type-checking exceptions in the exception handler's report and render methods, you may define report and render methods directly on your custom exception. When these methods exist, they will be called automatically by the framework: ?php namespace App\\Exceptions; use Exception; class RenderException extends Exception { /** * Report the exception. * * @return void */ public function report() { // } /** * Render the exception into an HTTP response. * * @param \\Illuminate\\Http\\Request * @return \\Illuminate\\Http\\Response */ public function render($request) { return response(...); } }","title":"Reportable &amp; Renderable Exceptions"},{"location":"error-handling/#http-exceptions","text":"Some exceptions describe HTTP error codes from the server. For example, this may be a \"page not found\" error (404), an \"unauthorized error\" (401) or even a developer generated 500 error. In order to generate such a response from anywhere in your application, you may use the abort helper: abort(404); The abort helper will immediately raise an exception which will be rendered by the exception handler. Optionally, you may provide the response text: abort(403, 'Unauthorized action.');","title":"HTTP Exceptions"},{"location":"error-handling/#custom-http-error-pages","text":"Space MVC makes it easy to display custom error pages for various HTTP status codes. For example, if you wish to customize the error page for 404 HTTP status codes, create a resources/views/errors/404.blade.php. This file will be served on all 404 errors generated by your application. The views within this directory should be named to match the HTTP status code they correspond to. The HttpException instance raised by the abort function will be passed to the view as an $exception variable: h2 {{ $exception- getMessage() }} /h2","title":"Custom HTTP Error Pages"},{"location":"events/","text":"Events Space MVC's events provide a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application. Event classes are typically stored in the app/Events directory, while their listeners are stored in app/Listeners. Don't worry if you don't see these directories in your application, since they will be created for you as you generate events and listeners using Artisan console commands. Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can raise an OrderShipped event, which a listener can receive and transform into a Slack notification. Registering Events Listeners The EventServiceProvider included with your Space MVC application provides a convenient place to register all of your application's event listeners. The listen property contains an array of all events (keys) and their listeners (values). Of course, you may add as many events to this array as your application requires. For example, let's add a OrderShipped event: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'App\\Events\\OrderShipped' = [ 'App\\Listeners\\SendShipmentNotification', ], ]; Generating Events Listeners Of course, manually creating the files for each event and listener is cumbersome. Instead, add listeners and events to your EventServiceProvider and use the event:generate command. This command will generate any events or listeners that are listed in your EventServiceProvider. Of course, events and listeners that already exist will be left untouched: php artisan event:generate Manually Registering Events Typically, events should be registered via the EventServiceProvider $listen array; however, you may also register Closure based events manually in the boot method of your EventServiceProvider: /** * Register any other events for your application. * * @return void */ public function boot() { parent::boot(); Event::listen('event.name', function ($foo, $bar) { // }); } Wildcard Event Listeners You may even register listeners using the * as a wildcard parameter, allowing you to catch multiple events on the same listener. Wildcard listeners receive the event name as their first argument, and the entire event data array as their second argument: Event::listen('event.*', function ($eventName, array $data) { // }); Defining Events An event class is a data container which holds the information related to the event. For example, let's assume our generated OrderShipped event receives an Eloquent ORM object: ?php namespace App\\Events; use App\\Order; use Illuminate\\Queue\\SerializesModels; class OrderShipped { use SerializesModels; public $order; /** * Create a new event instance. * * @param \\App\\Order $order * @return void */ public function __construct(Order $order) { $this- order = $order; } } As you can see, this event class contains no logic. It is a container for the Order instance that was purchased. The SerializesModels trait used by the event will gracefully serialize any Eloquent models if the event object is serialized using PHP's serialize function. Defining Listeners Next, let's take a look at the listener for our example event. Event listeners receive the event instance in their handle method. The event:generate command will automatically import the proper event class and type-hint the event on the handle method. Within the handle method, you may perform any actions necessary to respond to the event: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; class SendShipmentNotification { /** * Create the event listener. * * @return void */ public function __construct() { // } /** * Handle the event. * * @param \\App\\Events\\OrderShipped $event * @return void */ public function handle(OrderShipped $event) { // Access the order using $event- order... } } Your event listeners may also type-hint any dependencies they need on their constructors. All event listeners are resolved via the Space MVC service container , so dependencies will be injected automatically. Stopping The Propagation Of An Event Sometimes, you may wish to stop the propagation of an event to other listeners. You may do so by returning false from your listener's handle method. Queued Event Listeners Queueing listeners can be beneficial if your listener is going to perform a slow task such as sending an e-mail or making an HTTP request. Before getting started with queued listeners, make sure to configure your queue and start a queue listener on your server or local development environment. To specify that a listener should be queued, add the ShouldQueue interface to the listener class. Listeners generated by the event:generate Artisan command already have this interface imported into the current namespace, so you can use it immediately: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { // } That's it! Now, when this listener is called for an event, it will be automatically queued by the event dispatcher using Space MVC's queue system . If no exceptions are thrown when the listener is executed by the queue, the queued job will automatically be deleted after it has finished processing. Customizing The Queue Connection Queue Name If you would like to customize the queue connection and queue name used by an event listener, you may define $connection and $queue properties on your listener class: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { /** * The name of the connection the job should be sent to. * * @var string|null */ public $connection = 'sqs'; /** * The name of the queue the job should be sent to. * * @var string|null */ public $queue = 'listeners'; } Manually Accessing The Queue If you need to manually access the listener's underlying queue job's delete and release methods, you may do so using the Illuminate\\Queue\\InteractsWithQueue trait. This trait is imported by default on generated listeners and provides access to these methods: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { use InteractsWithQueue; /** * Handle the event. * * @param \\App\\Events\\OrderShipped $event * @return void */ public function handle(OrderShipped $event) { if (true) { $this- release(30); } } } Handling Failed Jobs Sometimes your queued event listeners may fail. If queued listener exceeds the maximum number of attempts as defined by your queue worker, the failed method will be called on your listener. The failed method receives the event instance and the exception that caused the failure: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { use InteractsWithQueue; /** * Handle the event. * * @param \\App\\Events\\OrderShipped $event * @return void */ public function handle(OrderShipped $event) { // } /** * Handle a job failure. * * @param \\App\\Events\\OrderShipped $event * @param \\Exception $exception * @return void */ public function failed(OrderShipped $event, $exception) { // } } Dispatching Events To dispatch an event, you may pass an instance of the event to the event helper. The helper will dispatch the event to all of its registered listeners. Since the event helper is globally available, you may call it from anywhere in your application: ?php namespace App\\Http\\Controllers; use App\\Order; use App\\Events\\OrderShipped; use App\\Http\\Controllers\\Controller; class OrderController extends Controller { /** * Ship the given order. * * @param int $orderId * @return Response */ public function ship($orderId) { $order = Order::findOrFail($orderId); // Order shipment logic... event(new OrderShipped($order)); } } When testing, it can be helpful to assert that certain events were dispatched without actually triggering their listeners. Space MVC's built-in testing helpers makes it a cinch. Event Subscribers Writing Event Subscribers Event subscribers are classes that may subscribe to multiple events from within the class itself, allowing you to define several event handlers within a single class. Subscribers should define a subscribe method, which will be passed an event dispatcher instance. You may call the listen method on the given dispatcher to register event listeners: ?php namespace App\\Listeners; class UserEventSubscriber { /** * Handle user login events. */ public function onUserLogin($event) {} /** * Handle user logout events. */ public function onUserLogout($event) {} /** * Register the listeners for the subscriber. * * @param \\Illuminate\\Events\\Dispatcher $events */ public function subscribe($events) { $events- listen( 'Illuminate\\Auth\\Events\\Login', 'App\\Listeners\\UserEventSubscriber@onUserLogin' ); $events- listen( 'Illuminate\\Auth\\Events\\Logout', 'App\\Listeners\\UserEventSubscriber@onUserLogout' ); } } Registering Event Subscribers After writing the subscriber, you are ready to register it with the event dispatcher. You may register subscribers using the $subscribe property on the EventServiceProvider. For example, let's add the UserEventSubscriber to the list: ?php namespace App\\Providers; use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider; class EventServiceProvider extends ServiceProvider { /** * The event listener mappings for the application. * * @var array */ protected $listen = [ // ]; /** * The subscriber classes to register. * * @var array */ protected $subscribe = [ 'App\\Listeners\\UserEventSubscriber', ]; }","title":"Events"},{"location":"events/#events","text":"Space MVC's events provide a simple observer implementation, allowing you to subscribe and listen for various events that occur in your application. Event classes are typically stored in the app/Events directory, while their listeners are stored in app/Listeners. Don't worry if you don't see these directories in your application, since they will be created for you as you generate events and listeners using Artisan console commands. Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can raise an OrderShipped event, which a listener can receive and transform into a Slack notification.","title":"Events"},{"location":"events/#registering-events-listeners","text":"The EventServiceProvider included with your Space MVC application provides a convenient place to register all of your application's event listeners. The listen property contains an array of all events (keys) and their listeners (values). Of course, you may add as many events to this array as your application requires. For example, let's add a OrderShipped event: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'App\\Events\\OrderShipped' = [ 'App\\Listeners\\SendShipmentNotification', ], ];","title":"Registering Events &amp; Listeners"},{"location":"events/#generating-events-listeners","text":"Of course, manually creating the files for each event and listener is cumbersome. Instead, add listeners and events to your EventServiceProvider and use the event:generate command. This command will generate any events or listeners that are listed in your EventServiceProvider. Of course, events and listeners that already exist will be left untouched: php artisan event:generate","title":"Generating Events &amp; Listeners"},{"location":"events/#manually-registering-events","text":"Typically, events should be registered via the EventServiceProvider $listen array; however, you may also register Closure based events manually in the boot method of your EventServiceProvider: /** * Register any other events for your application. * * @return void */ public function boot() { parent::boot(); Event::listen('event.name', function ($foo, $bar) { // }); }","title":"Manually Registering Events"},{"location":"events/#wildcard-event-listeners","text":"You may even register listeners using the * as a wildcard parameter, allowing you to catch multiple events on the same listener. Wildcard listeners receive the event name as their first argument, and the entire event data array as their second argument: Event::listen('event.*', function ($eventName, array $data) { // });","title":"Wildcard Event Listeners"},{"location":"events/#defining-events","text":"An event class is a data container which holds the information related to the event. For example, let's assume our generated OrderShipped event receives an Eloquent ORM object: ?php namespace App\\Events; use App\\Order; use Illuminate\\Queue\\SerializesModels; class OrderShipped { use SerializesModels; public $order; /** * Create a new event instance. * * @param \\App\\Order $order * @return void */ public function __construct(Order $order) { $this- order = $order; } } As you can see, this event class contains no logic. It is a container for the Order instance that was purchased. The SerializesModels trait used by the event will gracefully serialize any Eloquent models if the event object is serialized using PHP's serialize function.","title":"Defining Events"},{"location":"events/#defining-listeners","text":"Next, let's take a look at the listener for our example event. Event listeners receive the event instance in their handle method. The event:generate command will automatically import the proper event class and type-hint the event on the handle method. Within the handle method, you may perform any actions necessary to respond to the event: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; class SendShipmentNotification { /** * Create the event listener. * * @return void */ public function __construct() { // } /** * Handle the event. * * @param \\App\\Events\\OrderShipped $event * @return void */ public function handle(OrderShipped $event) { // Access the order using $event- order... } } Your event listeners may also type-hint any dependencies they need on their constructors. All event listeners are resolved via the Space MVC service container , so dependencies will be injected automatically.","title":"Defining Listeners"},{"location":"events/#stopping-the-propagation-of-an-event","text":"Sometimes, you may wish to stop the propagation of an event to other listeners. You may do so by returning false from your listener's handle method.","title":"Stopping The Propagation Of An Event"},{"location":"events/#queued-event-listeners","text":"Queueing listeners can be beneficial if your listener is going to perform a slow task such as sending an e-mail or making an HTTP request. Before getting started with queued listeners, make sure to configure your queue and start a queue listener on your server or local development environment. To specify that a listener should be queued, add the ShouldQueue interface to the listener class. Listeners generated by the event:generate Artisan command already have this interface imported into the current namespace, so you can use it immediately: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { // } That's it! Now, when this listener is called for an event, it will be automatically queued by the event dispatcher using Space MVC's queue system . If no exceptions are thrown when the listener is executed by the queue, the queued job will automatically be deleted after it has finished processing.","title":"Queued Event Listeners"},{"location":"events/#customizing-the-queue-connection-queue-name","text":"If you would like to customize the queue connection and queue name used by an event listener, you may define $connection and $queue properties on your listener class: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { /** * The name of the connection the job should be sent to. * * @var string|null */ public $connection = 'sqs'; /** * The name of the queue the job should be sent to. * * @var string|null */ public $queue = 'listeners'; }","title":"Customizing The Queue Connection &amp; Queue Name"},{"location":"events/#manually-accessing-the-queue","text":"If you need to manually access the listener's underlying queue job's delete and release methods, you may do so using the Illuminate\\Queue\\InteractsWithQueue trait. This trait is imported by default on generated listeners and provides access to these methods: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { use InteractsWithQueue; /** * Handle the event. * * @param \\App\\Events\\OrderShipped $event * @return void */ public function handle(OrderShipped $event) { if (true) { $this- release(30); } } }","title":"Manually Accessing The Queue"},{"location":"events/#handling-failed-jobs","text":"Sometimes your queued event listeners may fail. If queued listener exceeds the maximum number of attempts as defined by your queue worker, the failed method will be called on your listener. The failed method receives the event instance and the exception that caused the failure: ?php namespace App\\Listeners; use App\\Events\\OrderShipped; use Illuminate\\Queue\\InteractsWithQueue; use Illuminate\\Contracts\\Queue\\ShouldQueue; class SendShipmentNotification implements ShouldQueue { use InteractsWithQueue; /** * Handle the event. * * @param \\App\\Events\\OrderShipped $event * @return void */ public function handle(OrderShipped $event) { // } /** * Handle a job failure. * * @param \\App\\Events\\OrderShipped $event * @param \\Exception $exception * @return void */ public function failed(OrderShipped $event, $exception) { // } }","title":"Handling Failed Jobs"},{"location":"events/#dispatching-events","text":"To dispatch an event, you may pass an instance of the event to the event helper. The helper will dispatch the event to all of its registered listeners. Since the event helper is globally available, you may call it from anywhere in your application: ?php namespace App\\Http\\Controllers; use App\\Order; use App\\Events\\OrderShipped; use App\\Http\\Controllers\\Controller; class OrderController extends Controller { /** * Ship the given order. * * @param int $orderId * @return Response */ public function ship($orderId) { $order = Order::findOrFail($orderId); // Order shipment logic... event(new OrderShipped($order)); } } When testing, it can be helpful to assert that certain events were dispatched without actually triggering their listeners. Space MVC's built-in testing helpers makes it a cinch.","title":"Dispatching Events"},{"location":"events/#event-subscribers","text":"","title":"Event Subscribers"},{"location":"events/#writing-event-subscribers","text":"Event subscribers are classes that may subscribe to multiple events from within the class itself, allowing you to define several event handlers within a single class. Subscribers should define a subscribe method, which will be passed an event dispatcher instance. You may call the listen method on the given dispatcher to register event listeners: ?php namespace App\\Listeners; class UserEventSubscriber { /** * Handle user login events. */ public function onUserLogin($event) {} /** * Handle user logout events. */ public function onUserLogout($event) {} /** * Register the listeners for the subscriber. * * @param \\Illuminate\\Events\\Dispatcher $events */ public function subscribe($events) { $events- listen( 'Illuminate\\Auth\\Events\\Login', 'App\\Listeners\\UserEventSubscriber@onUserLogin' ); $events- listen( 'Illuminate\\Auth\\Events\\Logout', 'App\\Listeners\\UserEventSubscriber@onUserLogout' ); } }","title":"Writing Event Subscribers"},{"location":"events/#registering-event-subscribers","text":"After writing the subscriber, you are ready to register it with the event dispatcher. You may register subscribers using the $subscribe property on the EventServiceProvider. For example, let's add the UserEventSubscriber to the list: ?php namespace App\\Providers; use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider; class EventServiceProvider extends ServiceProvider { /** * The event listener mappings for the application. * * @var array */ protected $listen = [ // ]; /** * The subscriber classes to register. * * @var array */ protected $subscribe = [ 'App\\Listeners\\UserEventSubscriber', ]; }","title":"Registering Event Subscribers"},{"location":"file-storage/","text":"File Storage Introduction Space MVC provides a powerful filesystem abstraction thanks to the wonderful Flysystem PHP package by Frank de Jonge. The Space MVC Flysystem integration provides simple to use drivers for working with local filesystems, Amazon S3, and Rackspace Cloud Storage. Even better, it's amazingly simple to switch between these storage options as the API remains the same for each system. Configuration The filesystem configuration file is located at config/filesystems.php. Within this file you may configure all of your \"disks\". Each disk represents a particular storage driver and storage location. Example configurations for each supported driver are included in the configuration file. So, modify the configuration to reflect your storage preferences and credentials. Of course, you may configure as many disks as you like, and may even have multiple disks that use the same driver. The Public Disk The public disk is intended for files that are going to be publicly accessible. By default, the public disk uses the local driver and stores these files in storage/app/public. To make them accessible from the web, you should create a symbolic link from public/storage to storage/app/public. This convention will keep your publicly accessible files in one directory that can be easily shared across deployments when using zero down-time deployment systems like Envoyer . To create the symbolic link, you may use the storage:link Artisan command: php artisan storage:link Of course, once a file has been stored and the symbolic link has been created, you can create a URL to the files using the asset helper: echo asset('storage/file.txt'); The Local Driver When using the local driver, all file operations are relative to the root directory defined in your configuration file. By default, this value is set to the storage/app directory. Therefore, the following method would store a file in storage/app/file.txt: Storage::disk('local')- put('file.txt', 'Contents'); Driver Prerequisites Composer Packages Before using the SFTP, S3, or Rackspace drivers, you will need to install the appropriate package via Composer: SFTP: league/flysystem-sftp ~1.0 Amazon S3: league/flysystem-aws-s3-v3 ~1.0 Rackspace: league/flysystem-rackspace ~1.0 An absolute must for performance is to use a cached adapter. You will need an additional package for this: CachedAdapter: league/flysystem-cached-adapter ~1.0 S3 Driver Configuration The S3 driver configuration information is located in your config/filesystems.php configuration file. This file contains an example configuration array for an S3 driver. You are free to modify this array with your own S3 configuration and credentials. For convenience, these environment variables match the naming convention used by the AWS CLI. FTP Driver Configuration Space MVC's Flysystem integrations works great with FTP; however, a sample configuration is not included with the framework's default filesystems.php configuration file. If you need to configure a FTP filesystem, you may use the example configuration below: 'ftp' = [ 'driver' = 'ftp', 'host' = 'ftp.example.com', 'username' = 'your-username', 'password' = 'your-password', // Optional FTP Settings... // 'port' = 21, // 'root' = '', // 'passive' = true, // 'ssl' = true, // 'timeout' = 30, ], SFTP Driver Configuration Space MVC's Flysystem integrations works great with SFTP; however, a sample configuration is not included with the framework's default filesystems.php configuration file. If you need to configure a SFTP filesystem, you may use the example configuration below: 'sftp' = [ 'driver' = 'sftp', 'host' = 'example.com', 'username' = 'your-username', 'password' = 'your-password', // Settings for SSH key based authentication... // 'privateKey' = '/path/to/privateKey', // 'password' = 'encryption-password', // Optional SFTP Settings... // 'port' = 22, // 'root' = '', // 'timeout' = 30, ], Rackspace Driver Configuration Space MVC's Flysystem integrations works great with Rackspace; however, a sample configuration is not included with the framework's default filesystems.php configuration file. If you need to configure a Rackspace filesystem, you may use the example configuration below: 'rackspace' = [ 'driver' = 'rackspace', 'username' = 'your-username', 'key' = 'your-key', 'container' = 'your-container', 'endpoint' = 'https://identity.api.rackspacecloud.com/v2.0/', 'region' = 'IAD', 'url_type' = 'publicURL', ], Caching To enable caching for a given disk, you may add a cache directive to the disk's configuration options. The cache option should be an array of caching options containing the disk name, the expire time in seconds, and the cache prefix: 's3' = [ 'driver' = 's3', // Other Disk Options... 'cache' = [ 'store' = 'memcached', 'expire' = 600, 'prefix' = 'cache-prefix', ], ], Obtaining Disk Instances The Storage facade may be used to interact with any of your configured disks. For example, you may use the put method on the facade to store an avatar on the default disk. If you call methods on the Storage facade without first calling the disk method, the method call will automatically be passed to the default disk: use Illuminate\\Support\\Facades\\Storage; Storage::put('avatars/1', $fileContents); If your applications interacts with multiple disks, you may use the disk method on the Storage facade to work with files on a particular disk: Storage::disk('s3')- put('avatars/1', $fileContents); Retrieving Files The get method may be used to retrieve the contents of a file. The raw string contents of the file will be returned by the method. Remember, all file paths should be specified relative to the \"root\" location configured for the disk: $contents = Storage::get('file.jpg'); The exists method may be used to determine if a file exists on the disk: $exists = Storage::disk('s3')- exists('file.jpg'); Downloading Files The download method may be used to generate a response that forces the user's browser to download the file at the given path. The download method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method: return Storage::download('file.jpg'); return Storage::download('file.jpg', $name, $headers); File URLs You may use the url method to get the URL for the given file. If you are using the local driver, this will typically just prepend /storage to the given path and return a relative URL to the file. If you are using the s3 or rackspace driver, the fully qualified remote URL will be returned: use Illuminate\\Support\\Facades\\Storage; $url = Storage::url('file.jpg'); Remember, if you are using the local driver, all files that should be publicly accessible should be placed in the storage/app/public directory. Furthermore, you should create a symbolic link at public/storage which points to the storage/app/public directory. Temporary URLs For files stored using the s3 or rackspace driver, you may create a temporary URL to a given file using the temporaryUrl method. This methods accepts a path and a DateTime instance specifying when the URL should expire: $url = Storage::temporaryUrl( 'file.jpg', now()- addMinutes(5) ); Local URL Host Customization If you would like to pre-define the host for files stored on a disk using the local driver, you may add a url option to the disk's configuration array: 'public' = [ 'driver' = 'local', 'root' = storage_path('app/public'), 'url' = env('APP_URL').'/storage', 'visibility' = 'public', ], File Metadata In addition to reading and writing files, Space MVC can also provide information about the files themselves. For example, the size method may be used to get the size of the file in bytes: use Illuminate\\Support\\Facades\\Storage; $size = Storage::size('file.jpg'); The lastModified method returns the UNIX timestamp of the last time the file was modified: $time = Storage::lastModified('file.jpg'); Storing Files The put method may be used to store raw file contents on a disk. You may also pass a PHP resource to the put method, which will use Flysystem's underlying stream support. Using streams is greatly recommended when dealing with large files: use Illuminate\\Support\\Facades\\Storage; Storage::put('file.jpg', $contents); Storage::put('file.jpg', $resource); Automatic Streaming If you would like Space MVC to automatically manage streaming a given file to your storage location, you may use the putFile or putFileAs method. This method accepts either a Illuminate\\Http\\File or Illuminate\\Http\\UploadedFile instance and will automatically stream the file to your desired location: use Illuminate\\Http\\File; use Illuminate\\Support\\Facades\\Storage; // Automatically generate a unique ID for file name... Storage::putFile('photos', new File('/path/to/photo')); // Manually specify a file name... Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg'); There are a few important things to note about the putFile method. Note that we only specified a directory name, not a file name. By default, the putFile method will generate a unique ID to serve as the file name. The file's extension will be determined by examining the file's MIME type. The path to the file will be returned by the putFile method so you can store the path, including the generated file name, in your database. The putFile and putFileAs methods also accept an argument to specify the \"visibility\" of the stored file. This is particularly useful if you are storing the file on a cloud disk such as S3 and would like the file to be publicly accessible: Storage::putFile('photos', new File('/path/to/photo'), 'public'); Prepending Appending To Files The prepend and append methods allow you to write to the beginning or end of a file: Storage::prepend('file.log', 'Prepended Text'); Storage::append('file.log', 'Appended Text'); Copying Moving Files The copy method may be used to copy an existing file to a new location on the disk, while the move method may be used to rename or move an existing file to a new location: Storage::copy('old/file.jpg', 'new/file.jpg'); Storage::move('old/file.jpg', 'new/file.jpg'); File Uploads In web applications, one of the most common use-cases for storing files is storing user uploaded files such as profile pictures, photos, and documents. Space MVC makes it very easy to store uploaded files using the store method on an uploaded file instance. Call the store method with the path at which you wish to store the uploaded file: ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class UserAvatarController extends Controller { /** * Update the avatar for the user. * * @param Request $request * @return Response */ public function update(Request $request) { $path = $request- file('avatar')- store('avatars'); return $path; } } There are a few important things to note about this example. Note that we only specified a directory name, not a file name. By default, the store method will generate a unique ID to serve as the file name. The file's extension will be determined by examining the file's MIME type. The path to the file will be returned by the store method so you can store the path, including the generated file name, in your database. You may also call the putFile method on the Storage facade to perform the same file manipulation as the example above: $path = Storage::putFile('avatars', $request- file('avatar')); Specifying A File Name If you would not like a file name to be automatically assigned to your stored file, you may use the storeAs method, which receives the path, the file name, and the (optional) disk as its arguments: $path = $request- file('avatar')- storeAs( 'avatars', $request- user()- id ); Of course, you may also use the putFileAs method on the Storage facade, which will perform the same file manipulation as the example above: $path = Storage::putFileAs( 'avatars', $request- file('avatar'), $request- user()- id ); Specifying A Disk By default, this method will use your default disk. If you would like to specify another disk, pass the disk name as the second argument to the store method: $path = $request- file('avatar')- store( 'avatars/'.$request- user()- id, 's3' ); File Visibility In Space MVC's Flysystem integration, \"visibility\" is an abstraction of file permissions across multiple platforms. Files may either be declared public or private. When a file is declared public, you are indicating that the file should generally be accessible to others. For example, when using the S3 driver, you may retrieve URLs for public files. You can set the visibility when setting the file via the put method: use Illuminate\\Support\\Facades\\Storage; Storage::put('file.jpg', $contents, 'public'); If the file has already been stored, its visibility can be retrieved and set via the getVisibility and setVisibility methods: $visibility = Storage::getVisibility('file.jpg'); Storage::setVisibility('file.jpg', 'public') Deleting Files The delete method accepts a single filename or an array of files to remove from the disk: use Illuminate\\Support\\Facades\\Storage; Storage::delete('file.jpg'); Storage::delete(['file.jpg', 'file2.jpg']); If necessary, you may specify the disk that the file should be deleted from: use Illuminate\\Support\\Facades\\Storage; Storage::disk('s3')- delete('folder_path/file_name.jpg'); Directories Get All Files Within A Directory The files method returns an array of all of the files in a given directory. If you would like to retrieve a list of all files within a given directory including all sub-directories, you may use the allFiles method: use Illuminate\\Support\\Facades\\Storage; $files = Storage::files($directory); $files = Storage::allFiles($directory); Get All Directories Within A Directory The directories method returns an array of all the directories within a given directory. Additionally, you may use the allDirectories method to get a list of all directories within a given directory and all of its sub-directories: $directories = Storage::directories($directory); // Recursive... $directories = Storage::allDirectories($directory); Create A Directory The makeDirectory method will create the given directory, including any needed sub-directories: Storage::makeDirectory($directory); Delete A Directory Finally, the deleteDirectory may be used to remove a directory and all of its files: Storage::deleteDirectory($directory); Custom Filesystems Space MVC's Flysystem integration provides drivers for several \"drivers\" out of the box; however, Flysystem is not limited to these and has adapters for many other storage systems. You can create a custom driver if you want to use one of these additional adapters in your Space MVC application. In order to set up the custom filesystem you will need a Flysystem adapter. Let's add a community maintained Dropbox adapter to our project: composer require spatie/flysystem-dropbox Next, you should create a service provider such as DropboxServiceProvider. In the provider's boot method, you may use the Storage facade's extend method to define the custom driver: ?php namespace App\\Providers; use Storage; use League\\Flysystem\\Filesystem; use Illuminate\\Support\\ServiceProvider; use Spatie\\Dropbox\\Client as DropboxClient; use Spatie\\FlysystemDropbox\\DropboxAdapter; class DropboxServiceProvider extends ServiceProvider { /** * Perform post-registration booting of services. * * @return void */ public function boot() { Storage::extend('dropbox', function ($app, $config) { $client = new DropboxClient( $config['authorization_token'] ); return new Filesystem(new DropboxAdapter($client)); }); } /** * Register bindings in the container. * * @return void */ public function register() { // } } The first argument of the extend method is the name of the driver and the second is a Closure that receives the $app and $config variables. The resolver Closure must return an instance of League\\Flysystem\\Filesystem. The $config variable contains the values defined in config/filesystems.php for the specified disk. Once you have created the service provider to register the extension, you may use the dropbox driver in your config/filesystems.php configuration file.","title":"File Storage"},{"location":"file-storage/#file-storage","text":"","title":"File Storage"},{"location":"file-storage/#introduction","text":"Space MVC provides a powerful filesystem abstraction thanks to the wonderful Flysystem PHP package by Frank de Jonge. The Space MVC Flysystem integration provides simple to use drivers for working with local filesystems, Amazon S3, and Rackspace Cloud Storage. Even better, it's amazingly simple to switch between these storage options as the API remains the same for each system.","title":"Introduction"},{"location":"file-storage/#configuration","text":"The filesystem configuration file is located at config/filesystems.php. Within this file you may configure all of your \"disks\". Each disk represents a particular storage driver and storage location. Example configurations for each supported driver are included in the configuration file. So, modify the configuration to reflect your storage preferences and credentials. Of course, you may configure as many disks as you like, and may even have multiple disks that use the same driver.","title":"Configuration"},{"location":"file-storage/#the-public-disk","text":"The public disk is intended for files that are going to be publicly accessible. By default, the public disk uses the local driver and stores these files in storage/app/public. To make them accessible from the web, you should create a symbolic link from public/storage to storage/app/public. This convention will keep your publicly accessible files in one directory that can be easily shared across deployments when using zero down-time deployment systems like Envoyer . To create the symbolic link, you may use the storage:link Artisan command: php artisan storage:link Of course, once a file has been stored and the symbolic link has been created, you can create a URL to the files using the asset helper: echo asset('storage/file.txt');","title":"The Public Disk"},{"location":"file-storage/#the-local-driver","text":"When using the local driver, all file operations are relative to the root directory defined in your configuration file. By default, this value is set to the storage/app directory. Therefore, the following method would store a file in storage/app/file.txt: Storage::disk('local')- put('file.txt', 'Contents');","title":"The Local Driver"},{"location":"file-storage/#driver-prerequisites","text":"","title":"Driver Prerequisites"},{"location":"file-storage/#composer-packages","text":"Before using the SFTP, S3, or Rackspace drivers, you will need to install the appropriate package via Composer: SFTP: league/flysystem-sftp ~1.0 Amazon S3: league/flysystem-aws-s3-v3 ~1.0 Rackspace: league/flysystem-rackspace ~1.0 An absolute must for performance is to use a cached adapter. You will need an additional package for this: CachedAdapter: league/flysystem-cached-adapter ~1.0","title":"Composer Packages"},{"location":"file-storage/#s3-driver-configuration","text":"The S3 driver configuration information is located in your config/filesystems.php configuration file. This file contains an example configuration array for an S3 driver. You are free to modify this array with your own S3 configuration and credentials. For convenience, these environment variables match the naming convention used by the AWS CLI.","title":"S3 Driver Configuration"},{"location":"file-storage/#ftp-driver-configuration","text":"Space MVC's Flysystem integrations works great with FTP; however, a sample configuration is not included with the framework's default filesystems.php configuration file. If you need to configure a FTP filesystem, you may use the example configuration below: 'ftp' = [ 'driver' = 'ftp', 'host' = 'ftp.example.com', 'username' = 'your-username', 'password' = 'your-password', // Optional FTP Settings... // 'port' = 21, // 'root' = '', // 'passive' = true, // 'ssl' = true, // 'timeout' = 30, ],","title":"FTP Driver Configuration"},{"location":"file-storage/#sftp-driver-configuration","text":"Space MVC's Flysystem integrations works great with SFTP; however, a sample configuration is not included with the framework's default filesystems.php configuration file. If you need to configure a SFTP filesystem, you may use the example configuration below: 'sftp' = [ 'driver' = 'sftp', 'host' = 'example.com', 'username' = 'your-username', 'password' = 'your-password', // Settings for SSH key based authentication... // 'privateKey' = '/path/to/privateKey', // 'password' = 'encryption-password', // Optional SFTP Settings... // 'port' = 22, // 'root' = '', // 'timeout' = 30, ],","title":"SFTP Driver Configuration"},{"location":"file-storage/#rackspace-driver-configuration","text":"Space MVC's Flysystem integrations works great with Rackspace; however, a sample configuration is not included with the framework's default filesystems.php configuration file. If you need to configure a Rackspace filesystem, you may use the example configuration below: 'rackspace' = [ 'driver' = 'rackspace', 'username' = 'your-username', 'key' = 'your-key', 'container' = 'your-container', 'endpoint' = 'https://identity.api.rackspacecloud.com/v2.0/', 'region' = 'IAD', 'url_type' = 'publicURL', ],","title":"Rackspace Driver Configuration"},{"location":"file-storage/#caching","text":"To enable caching for a given disk, you may add a cache directive to the disk's configuration options. The cache option should be an array of caching options containing the disk name, the expire time in seconds, and the cache prefix: 's3' = [ 'driver' = 's3', // Other Disk Options... 'cache' = [ 'store' = 'memcached', 'expire' = 600, 'prefix' = 'cache-prefix', ], ],","title":"Caching"},{"location":"file-storage/#obtaining-disk-instances","text":"The Storage facade may be used to interact with any of your configured disks. For example, you may use the put method on the facade to store an avatar on the default disk. If you call methods on the Storage facade without first calling the disk method, the method call will automatically be passed to the default disk: use Illuminate\\Support\\Facades\\Storage; Storage::put('avatars/1', $fileContents); If your applications interacts with multiple disks, you may use the disk method on the Storage facade to work with files on a particular disk: Storage::disk('s3')- put('avatars/1', $fileContents);","title":"Obtaining Disk Instances"},{"location":"file-storage/#retrieving-files","text":"The get method may be used to retrieve the contents of a file. The raw string contents of the file will be returned by the method. Remember, all file paths should be specified relative to the \"root\" location configured for the disk: $contents = Storage::get('file.jpg'); The exists method may be used to determine if a file exists on the disk: $exists = Storage::disk('s3')- exists('file.jpg');","title":"Retrieving Files"},{"location":"file-storage/#downloading-files","text":"The download method may be used to generate a response that forces the user's browser to download the file at the given path. The download method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method: return Storage::download('file.jpg'); return Storage::download('file.jpg', $name, $headers);","title":"Downloading Files"},{"location":"file-storage/#file-urls","text":"You may use the url method to get the URL for the given file. If you are using the local driver, this will typically just prepend /storage to the given path and return a relative URL to the file. If you are using the s3 or rackspace driver, the fully qualified remote URL will be returned: use Illuminate\\Support\\Facades\\Storage; $url = Storage::url('file.jpg'); Remember, if you are using the local driver, all files that should be publicly accessible should be placed in the storage/app/public directory. Furthermore, you should create a symbolic link at public/storage which points to the storage/app/public directory.","title":"File URLs"},{"location":"file-storage/#temporary-urls","text":"For files stored using the s3 or rackspace driver, you may create a temporary URL to a given file using the temporaryUrl method. This methods accepts a path and a DateTime instance specifying when the URL should expire: $url = Storage::temporaryUrl( 'file.jpg', now()- addMinutes(5) );","title":"Temporary URLs"},{"location":"file-storage/#local-url-host-customization","text":"If you would like to pre-define the host for files stored on a disk using the local driver, you may add a url option to the disk's configuration array: 'public' = [ 'driver' = 'local', 'root' = storage_path('app/public'), 'url' = env('APP_URL').'/storage', 'visibility' = 'public', ],","title":"Local URL Host Customization"},{"location":"file-storage/#file-metadata","text":"In addition to reading and writing files, Space MVC can also provide information about the files themselves. For example, the size method may be used to get the size of the file in bytes: use Illuminate\\Support\\Facades\\Storage; $size = Storage::size('file.jpg'); The lastModified method returns the UNIX timestamp of the last time the file was modified: $time = Storage::lastModified('file.jpg');","title":"File Metadata"},{"location":"file-storage/#storing-files","text":"The put method may be used to store raw file contents on a disk. You may also pass a PHP resource to the put method, which will use Flysystem's underlying stream support. Using streams is greatly recommended when dealing with large files: use Illuminate\\Support\\Facades\\Storage; Storage::put('file.jpg', $contents); Storage::put('file.jpg', $resource);","title":"Storing Files"},{"location":"file-storage/#automatic-streaming","text":"If you would like Space MVC to automatically manage streaming a given file to your storage location, you may use the putFile or putFileAs method. This method accepts either a Illuminate\\Http\\File or Illuminate\\Http\\UploadedFile instance and will automatically stream the file to your desired location: use Illuminate\\Http\\File; use Illuminate\\Support\\Facades\\Storage; // Automatically generate a unique ID for file name... Storage::putFile('photos', new File('/path/to/photo')); // Manually specify a file name... Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg'); There are a few important things to note about the putFile method. Note that we only specified a directory name, not a file name. By default, the putFile method will generate a unique ID to serve as the file name. The file's extension will be determined by examining the file's MIME type. The path to the file will be returned by the putFile method so you can store the path, including the generated file name, in your database. The putFile and putFileAs methods also accept an argument to specify the \"visibility\" of the stored file. This is particularly useful if you are storing the file on a cloud disk such as S3 and would like the file to be publicly accessible: Storage::putFile('photos', new File('/path/to/photo'), 'public');","title":"Automatic Streaming"},{"location":"file-storage/#prepending-appending-to-files","text":"The prepend and append methods allow you to write to the beginning or end of a file: Storage::prepend('file.log', 'Prepended Text'); Storage::append('file.log', 'Appended Text');","title":"Prepending &amp; Appending To Files"},{"location":"file-storage/#copying-moving-files","text":"The copy method may be used to copy an existing file to a new location on the disk, while the move method may be used to rename or move an existing file to a new location: Storage::copy('old/file.jpg', 'new/file.jpg'); Storage::move('old/file.jpg', 'new/file.jpg');","title":"Copying &amp; Moving Files"},{"location":"file-storage/#file-uploads","text":"In web applications, one of the most common use-cases for storing files is storing user uploaded files such as profile pictures, photos, and documents. Space MVC makes it very easy to store uploaded files using the store method on an uploaded file instance. Call the store method with the path at which you wish to store the uploaded file: ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class UserAvatarController extends Controller { /** * Update the avatar for the user. * * @param Request $request * @return Response */ public function update(Request $request) { $path = $request- file('avatar')- store('avatars'); return $path; } } There are a few important things to note about this example. Note that we only specified a directory name, not a file name. By default, the store method will generate a unique ID to serve as the file name. The file's extension will be determined by examining the file's MIME type. The path to the file will be returned by the store method so you can store the path, including the generated file name, in your database. You may also call the putFile method on the Storage facade to perform the same file manipulation as the example above: $path = Storage::putFile('avatars', $request- file('avatar'));","title":"File Uploads"},{"location":"file-storage/#specifying-a-file-name","text":"If you would not like a file name to be automatically assigned to your stored file, you may use the storeAs method, which receives the path, the file name, and the (optional) disk as its arguments: $path = $request- file('avatar')- storeAs( 'avatars', $request- user()- id ); Of course, you may also use the putFileAs method on the Storage facade, which will perform the same file manipulation as the example above: $path = Storage::putFileAs( 'avatars', $request- file('avatar'), $request- user()- id );","title":"Specifying A File Name"},{"location":"file-storage/#specifying-a-disk","text":"By default, this method will use your default disk. If you would like to specify another disk, pass the disk name as the second argument to the store method: $path = $request- file('avatar')- store( 'avatars/'.$request- user()- id, 's3' );","title":"Specifying A Disk"},{"location":"file-storage/#file-visibility","text":"In Space MVC's Flysystem integration, \"visibility\" is an abstraction of file permissions across multiple platforms. Files may either be declared public or private. When a file is declared public, you are indicating that the file should generally be accessible to others. For example, when using the S3 driver, you may retrieve URLs for public files. You can set the visibility when setting the file via the put method: use Illuminate\\Support\\Facades\\Storage; Storage::put('file.jpg', $contents, 'public'); If the file has already been stored, its visibility can be retrieved and set via the getVisibility and setVisibility methods: $visibility = Storage::getVisibility('file.jpg'); Storage::setVisibility('file.jpg', 'public')","title":"File Visibility"},{"location":"file-storage/#deleting-files","text":"The delete method accepts a single filename or an array of files to remove from the disk: use Illuminate\\Support\\Facades\\Storage; Storage::delete('file.jpg'); Storage::delete(['file.jpg', 'file2.jpg']); If necessary, you may specify the disk that the file should be deleted from: use Illuminate\\Support\\Facades\\Storage; Storage::disk('s3')- delete('folder_path/file_name.jpg');","title":"Deleting Files"},{"location":"file-storage/#directories","text":"","title":"Directories"},{"location":"file-storage/#get-all-files-within-a-directory","text":"The files method returns an array of all of the files in a given directory. If you would like to retrieve a list of all files within a given directory including all sub-directories, you may use the allFiles method: use Illuminate\\Support\\Facades\\Storage; $files = Storage::files($directory); $files = Storage::allFiles($directory);","title":"Get All Files Within A Directory"},{"location":"file-storage/#get-all-directories-within-a-directory","text":"The directories method returns an array of all the directories within a given directory. Additionally, you may use the allDirectories method to get a list of all directories within a given directory and all of its sub-directories: $directories = Storage::directories($directory); // Recursive... $directories = Storage::allDirectories($directory);","title":"Get All Directories Within A Directory"},{"location":"file-storage/#create-a-directory","text":"The makeDirectory method will create the given directory, including any needed sub-directories: Storage::makeDirectory($directory);","title":"Create A Directory"},{"location":"file-storage/#delete-a-directory","text":"Finally, the deleteDirectory may be used to remove a directory and all of its files: Storage::deleteDirectory($directory);","title":"Delete A Directory"},{"location":"file-storage/#custom-filesystems","text":"Space MVC's Flysystem integration provides drivers for several \"drivers\" out of the box; however, Flysystem is not limited to these and has adapters for many other storage systems. You can create a custom driver if you want to use one of these additional adapters in your Space MVC application. In order to set up the custom filesystem you will need a Flysystem adapter. Let's add a community maintained Dropbox adapter to our project: composer require spatie/flysystem-dropbox Next, you should create a service provider such as DropboxServiceProvider. In the provider's boot method, you may use the Storage facade's extend method to define the custom driver: ?php namespace App\\Providers; use Storage; use League\\Flysystem\\Filesystem; use Illuminate\\Support\\ServiceProvider; use Spatie\\Dropbox\\Client as DropboxClient; use Spatie\\FlysystemDropbox\\DropboxAdapter; class DropboxServiceProvider extends ServiceProvider { /** * Perform post-registration booting of services. * * @return void */ public function boot() { Storage::extend('dropbox', function ($app, $config) { $client = new DropboxClient( $config['authorization_token'] ); return new Filesystem(new DropboxAdapter($client)); }); } /** * Register bindings in the container. * * @return void */ public function register() { // } } The first argument of the extend method is the name of the driver and the second is a Closure that receives the $app and $config variables. The resolver Closure must return an instance of League\\Flysystem\\Filesystem. The $config variable contains the values defined in config/filesystems.php for the specified disk. Once you have created the service provider to register the extension, you may use the dropbox driver in your config/filesystems.php configuration file.","title":"Custom Filesystems"},{"location":"github-multiple-users/","text":"How do multiple developers use git? Please follow and listen to this video below which explains how to use git within a development team of multiple developers. With this video you do not need to follow the steps on your computer as it may be tricky for a first time user We will upload an easier video tutorial for you to follow and work alongside in our next video. How do developers work in a team using git? General Git Commands These are the general git commands. Below it shows how to use them on the command line If you use source tree the buttons across the top menu in source tree can run these command actions for you Command Description git clone This will download a git repository to your computer git add * -A This will add files to prepare to upload to a repository git commit -m 'my message' This will add a message to write to when pushed to a repository git push This will push / upload your files to the github repository git pull This will pull all 'new changes' of code by yourself and other developers to your computer from git","title":"How to use git in a Dev Team?"},{"location":"github-multiple-users/#how-do-multiple-developers-use-git","text":"Please follow and listen to this video below which explains how to use git within a development team of multiple developers. With this video you do not need to follow the steps on your computer as it may be tricky for a first time user We will upload an easier video tutorial for you to follow and work alongside in our next video.","title":"How do multiple developers use git?"},{"location":"github-multiple-users/#how-do-developers-work-in-a-team-using-git","text":"","title":"How do developers work in a team using git?"},{"location":"github-multiple-users/#general-git-commands","text":"These are the general git commands. Below it shows how to use them on the command line If you use source tree the buttons across the top menu in source tree can run these command actions for you Command Description git clone This will download a git repository to your computer git add * -A This will add files to prepare to upload to a repository git commit -m 'my message' This will add a message to write to when pushed to a repository git push This will push / upload your files to the github repository git pull This will pull all 'new changes' of code by yourself and other developers to your computer from git","title":"General Git Commands"},{"location":"helpers/","text":"Helpers ul li a href=\"#introduction\" Introduction /a /li li a href=\"#available-methods\" Available Methods /a /li /ul Introduction Space MVC includes a variety of global \"helper\" PHP functions. Many of these functions are used by the framework itself; however, you are free to use them in your own applications if you find them convenient. Available Methods style .collection-method-list p { column-count: 3; -moz-column-count: 3; -webkit-column-count: 3; column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em; } .collection-method-list a { display: block; } /style Arrays Objects div class=\"collection-method-list\" a href=\"#method-array-add\" array_add /a a href=\"#method-array-collapse\" array_collapse /a a href=\"#method-array-divide\" array_divide /a a href=\"#method-array-dot\" array_dot /a a href=\"#method-array-except\" array_except /a a href=\"#method-array-first\" array_first /a a href=\"#method-array-flatten\" array_flatten /a a href=\"#method-array-forget\" array_forget /a a href=\"#method-array-get\" array_get /a a href=\"#method-array-has\" array_has /a a href=\"#method-array-last\" array_last /a a href=\"#method-array-only\" array_only /a a href=\"#method-array-pluck\" array_pluck /a a href=\"#method-array-prepend\" array_prepend /a a href=\"#method-array-pull\" array_pull /a a href=\"#method-array-random\" array_random /a a href=\"#method-array-set\" array_set /a a href=\"#method-array-sort\" array_sort /a a href=\"#method-array-sort-recursive\" array_sort_recursive /a a href=\"#method-array-where\" array_where /a a href=\"#method-array-wrap\" array_wrap /a a href=\"#method-data-fill\" data_fill /a a href=\"#method-data-get\" data_get /a a href=\"#method-data-set\" data_set /a a href=\"#method-head\" head /a a href=\"#method-last\" last /a /div Paths div class=\"collection-method-list\" a href=\"#method-app-path\" app_path /a a href=\"#method-base-path\" base_path /a a href=\"#method-config-path\" config_path /a a href=\"#method-database-path\" database_path /a a href=\"#method-mix\" mix /a a href=\"#method-public-path\" public_path /a a href=\"#method-resource-path\" resource_path /a a href=\"#method-storage-path\" storage_path /a /div Strings div class=\"collection-method-list\" a href=\"#method-__\" __ /a a href=\"#method-camel-case\" camel_case /a a href=\"#method-class-basename\" class_basename /a a href=\"#method-e\" e /a a href=\"#method-ends-with\" ends_with /a a href=\"#method-kebab-case\" kebab_case /a a href=\"#method-preg-replace-array\" preg_replace_array /a a href=\"#method-snake-case\" snake_case /a a href=\"#method-starts-with\" starts_with /a a href=\"#method-str-after\" str_after /a a href=\"#method-str-before\" str_before /a a href=\"#method-str-contains\" str_contains /a a href=\"#method-str-finish\" str_finish /a a href=\"#method-str-is\" str_is /a a href=\"#method-str-limit\" str_limit /a a href=\"#method-str-ordered-uuid\" Str::orderedUuid /a a href=\"#method-str-plural\" str_plural /a a href=\"#method-str-random\" str_random /a a href=\"#method-str-replace-array\" str_replace_array /a a href=\"#method-str-replace-first\" str_replace_first /a a href=\"#method-str-replace-last\" str_replace_last /a a href=\"#method-str-singular\" str_singular /a a href=\"#method-str-slug\" str_slug /a a href=\"#method-str-start\" str_start /a a href=\"#method-studly-case\" studly_case /a a href=\"#method-title-case\" title_case /a a href=\"#method-trans\" trans /a a href=\"#method-trans-choice\" trans_choice /a a href=\"#method-str-uuid\" Str::uuid /a /div URLs div class=\"collection-method-list\" a href=\"#method-action\" action /a a href=\"#method-asset\" asset /a a href=\"#method-secure-asset\" secure_asset /a a href=\"#method-route\" route /a a href=\"#method-secure-url\" secure_url /a a href=\"#method-url\" url /a /div Miscellaneous div class=\"collection-method-list\" a href=\"#method-abort\" abort /a a href=\"#method-abort-if\" abort_if /a a href=\"#method-abort-unless\" abort_unless /a a href=\"#method-app\" app /a a href=\"#method-auth\" auth /a a href=\"#method-back\" back /a a href=\"#method-bcrypt\" bcrypt /a a href=\"#method-blank\" blank /a a href=\"#method-broadcast\" broadcast /a a href=\"#method-cache\" cache /a a href=\"#method-class-uses-recursive\" class_uses_recursive /a a href=\"#method-collect\" collect /a a href=\"#method-config\" config /a a href=\"#method-cookie\" cookie /a a href=\"#method-csrf-field\" csrf_field /a a href=\"#method-csrf-token\" csrf_token /a a href=\"#method-dd\" dd /a a href=\"#method-decrypt\" decrypt /a a href=\"#method-dispatch\" dispatch /a a href=\"#method-dispatch-now\" dispatch_now /a a href=\"#method-dump\" dump /a a href=\"#method-encrypt\" encrypt /a a href=\"#method-env\" env /a a href=\"#method-event\" event /a a href=\"#method-factory\" factory /a a href=\"#method-filled\" filled /a a href=\"#method-info\" info /a a href=\"#method-logger\" logger /a a href=\"#method-method-field\" method_field /a a href=\"#method-now\" now /a a href=\"#method-old\" old /a a href=\"#method-optional\" optional /a a href=\"#method-policy\" policy /a a href=\"#method-redirect\" redirect /a a href=\"#method-report\" report /a a href=\"#method-request\" request /a a href=\"#method-rescue\" rescue /a a href=\"#method-resolve\" resolve /a a href=\"#method-response\" response /a a href=\"#method-retry\" retry /a a href=\"#method-session\" session /a a href=\"#method-tap\" tap /a a href=\"#method-today\" today /a a href=\"#method-throw-if\" throw_if /a a href=\"#method-throw-unless\" throw_unless /a a href=\"#method-trait-uses-recursive\" trait_uses_recursive /a a href=\"#method-transform\" transform /a a href=\"#method-validator\" validator /a a href=\"#method-value\" value /a a href=\"#method-view\" view /a a href=\"#method-with\" with /a /div Method Listing style #collection-method code { font-size: 14px; } #collection-method:not(.first-collection-method) { margin-top: 50px; } /style Arrays Objects array_add() The array_add function adds a given key / value pair to an array if the given key doesn't already exist in the array: $array = array_add(['name' = 'Desk'], 'price', 100); // ['name' = 'Desk', 'price' = 100] array_collapse() The array_collapse function collapses an array of arrays into a single array: $array = array_collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // [1, 2, 3, 4, 5, 6, 7, 8, 9] array_divide() The array_divide function returns two arrays, one containing the keys, and the other containing the values of the given array: [$keys, $values] = array_divide(['name' = 'Desk']); // $keys: ['name'] // $values: ['Desk'] array_dot() The array_dot function flattens a multi-dimensional array into a single level array that uses \"dot\" notation to indicate depth: $array = ['products' = ['desk' = ['price' = 100]]]; $flattened = array_dot($array); // ['products.desk.price' = 100] array_except() The array_except function removes the given key / value pairs from an array: $array = ['name' = 'Desk', 'price' = 100]; $filtered = array_except($array, ['price']); // ['name' = 'Desk'] array_first() The array_first function returns the first element of an array passing a given truth test: $array = [100, 200, 300]; $first = array_first($array, function ($value, $key) { return $value = 150; }); // 200 A default value may also be passed as the third parameter to the method. This value will be returned if no value passes the truth test: $first = array_first($array, $callback, $default); array_flatten() The array_flatten function flattens a multi-dimensional array into a single level array: $array = ['name' = 'Joe', 'languages' = ['PHP', 'Ruby']]; $flattened = array_flatten($array); // ['Joe', 'PHP', 'Ruby'] array_forget() The array_forget function removes a given key / value pair from a deeply nested array using \"dot\" notation: $array = ['products' = ['desk' = ['price' = 100]]]; array_forget($array, 'products.desk'); // ['products' = []] array_get() The array_get function retrieves a value from a deeply nested array using \"dot\" notation: $array = ['products' = ['desk' = ['price' = 100]]]; $price = array_get($array, 'products.desk.price'); // 100 The array_get function also accepts a default value, which will be returned if the specific key is not found: $discount = array_get($array, 'products.desk.discount', 0); // 0 array_has() The array_has function checks whether a given item or items exists in an array using \"dot\" notation: $array = ['product' = ['name' = 'Desk', 'price' = 100]]; $contains = array_has($array, 'product.name'); // true $contains = array_has($array, ['product.price', 'product.discount']); // false array_last() The array_last function returns the last element of an array passing a given truth test: $array = [100, 200, 300, 110]; $last = array_last($array, function ($value, $key) { return $value = 150; }); // 300 A default value may be passed as the third argument to the method. This value will be returned if no value passes the truth test: $last = array_last($array, $callback, $default); array_only() The array_only function returns only the specified key / value pairs from the given array: $array = ['name' = 'Desk', 'price' = 100, 'orders' = 10]; $slice = array_only($array, ['name', 'price']); // ['name' = 'Desk', 'price' = 100] array_pluck() The array_pluck function retrieves all of the values for a given key from an array: $array = [ ['developer' = ['id' = 1, 'name' = 'Taylor']], ['developer' = ['id' = 2, 'name' = 'Abigail']], ]; $names = array_pluck($array, 'developer.name'); // ['Taylor', 'Abigail'] You may also specify how you wish the resulting list to be keyed: $names = array_pluck($array, 'developer.name', 'developer.id'); // [1 = 'Taylor', 2 = 'Abigail'] array_prepend() The array_prepend function will push an item onto the beginning of an array: $array = ['one', 'two', 'three', 'four']; $array = array_prepend($array, 'zero'); // ['zero', 'one', 'two', 'three', 'four'] If needed, you may specify the key that should be used for the value: $array = ['price' = 100]; $array = array_prepend($array, 'Desk', 'name'); // ['name' = 'Desk', 'price' = 100] array_pull() The array_pull function returns and removes a key / value pair from an array: $array = ['name' = 'Desk', 'price' = 100]; $name = array_pull($array, 'name'); // $name: Desk // $array: ['price' = 100] A default value may be passed as the third argument to the method. This value will be returned if the key doesn't exist: $value = array_pull($array, $key, $default); array_random() The array_random function returns a random value from an array: $array = [1, 2, 3, 4, 5]; $random = array_random($array); // 4 - (retrieved randomly) You may also specify the number of items to return as an optional second argument. Note that providing this argument will return an array, even if only one item is desired: $items = array_random($array, 2); // [2, 5] - (retrieved randomly) array_set() The array_set function sets a value within a deeply nested array using \"dot\" notation: $array = ['products' = ['desk' = ['price' = 100]]]; array_set($array, 'products.desk.price', 200); // ['products' = ['desk' = ['price' = 200]]] array_sort() The array_sort function sorts an array by its values: $array = ['Desk', 'Table', 'Chair']; $sorted = array_sort($array); // ['Chair', 'Desk', 'Table'] You may also sort the array by the results of the given Closure: $array = [ ['name' = 'Desk'], ['name' = 'Table'], ['name' = 'Chair'], ]; $sorted = array_values(array_sort($array, function ($value) { return $value['name']; })); /* [ ['name' = 'Chair'], ['name' = 'Desk'], ['name' = 'Table'], ] */ array_sort_recursive() The array_sort_recursive function recursively sorts an array using the sort function for numeric sub=arrays and ksort for associative sub-arrays: $array = [ ['Roman', 'Taylor', 'Li'], ['PHP', 'Ruby', 'JavaScript'], ['one' = 1, 'two' = 2, 'three' = 3], ]; $sorted = array_sort_recursive($array); /* [ ['JavaScript', 'PHP', 'Ruby'], ['one' = 1, 'three' = 3, 'two' = 2], ['Li', 'Roman', 'Taylor'], ] */ array_where() The array_where function filters an array using the given Closure: $array = [100, '200', 300, '400', 500]; $filtered = array_where($array, function ($value, $key) { return is_string($value); }); // [1 = '200', 3 = '400'] array_wrap() The array_wrap function wraps the given value in an array. If the given value is already an array it will not be changed: $string = 'Space MVC'; $array = array_wrap($string); // ['Space MVC'] If the given value is null, an empty array will be returned: $nothing = null; $array = array_wrap($nothing); // [] data_fill() The data_fill function sets a missing value within a nested array or object using \"dot\" notation: $data = ['products' = ['desk' = ['price' = 100]]]; data_fill($data, 'products.desk.price', 200); // ['products' = ['desk' = ['price' = 100]]] data_fill($data, 'products.desk.discount', 10); // ['products' = ['desk' = ['price' = 100, 'discount' = 10]]] This function also accepts asterisks as wildcards and will fill the target accordingly: $data = [ 'products' = [ ['name' = 'Desk 1', 'price' = 100], ['name' = 'Desk 2'], ], ]; data_fill($data, 'products.*.price', 200); /* [ 'products' = [ ['name' = 'Desk 1', 'price' = 100], ['name' = 'Desk 2', 'price' = 200], ], ] */ data_get() The data_get function retrieves a value from a nested array or object using \"dot\" notation: $data = ['products' = ['desk' = ['price' = 100]]]; $price = data_get($data, 'products.desk.price'); // 100 The data_get function also accepts a default value, which will be returned if the specified key is not found: $discount = data_get($data, 'products.desk.discount', 0); // 0 The function also accepts wildcards using asterisks, which may target any key of the array or object: $data = [ 'product-one' = ['name' = 'Desk 1', 'price' = 100], 'product-two' = ['name' = 'Desk 2', 'price' = 150], ]; data_get($data, '*.name'); // ['Desk 1', 'Desk 2']; data_set() The data_set function sets a value within a nested array or object using \"dot\" notation: $data = ['products' = ['desk' = ['price' = 100]]]; data_set($data, 'products.desk.price', 200); // ['products' = ['desk' = ['price' = 200]]] This function also accepts wildcards and will set values on the target accordingly: $data = [ 'products' = [ ['name' = 'Desk 1', 'price' = 100], ['name' = 'Desk 2', 'price' = 150], ], ]; data_set($data, 'products.*.price', 200); /* [ 'products' = [ ['name' = 'Desk 1', 'price' = 200], ['name' = 'Desk 2', 'price' = 200], ], ] */ By default, any existing values are overwritten. If you wish to only set a value if it doesn't exist, you may pass false as the third argument: $data = ['products' = ['desk' = ['price' = 100]]]; data_set($data, 'products.desk.price', 200, false); // ['products' = ['desk' = ['price' = 100]]] head() The head function returns the first element in the given array: $array = [100, 200, 300]; $first = head($array); // 100 last() The last function returns the last element in the given array: $array = [100, 200, 300]; $last = last($array); // 300 Paths app_path() The app_path function returns the fully qualified path to the app directory. You may also use the app_path function to generate a fully qualified path to a file relative to the application directory: $path = app_path(); $path = app_path('Http/Controllers/Controller.php'); base_path() The base_path function returns the fully qualified path to the project root. You may also use the base_path function to generate a fully qualified path to a given file relative to the project root directory: $path = base_path(); $path = base_path('vendor/bin'); config_path() The config_path function returns the fully qualified path to the config directory. You may also use the config_path function to generate a fully qualified path to a given file within the application's configuration directory: $path = config_path(); $path = config_path('app.php'); database_path() The database_path function returns the fully qualified path to the database directory. You may also use the database_path function to generate a fully qualified path to a given file within the database directory: $path = database_path(); $path = database_path('factories/UserFactory.php'); mix() The mix function returns the path to a versioned Mix file : $path = mix('css/app.css'); public_path() The public_path function returns the fully qualified path to the public directory. You may also use the public_path function to generate a fully qualified path to a given file within the public directory: $path = public_path(); $path = public_path('css/app.css'); resource_path() The resource_path function returns the fully qualified path to the resources directory. You may also use the resource_path function to generate a fully qualified path to a given file within the resources directory: $path = resource_path(); $path = resource_path('sass/app.scss'); storage_path() The storage_path function returns the fully qualified path to the storage directory. You may also use the storage_path function to generate a fully qualified path to a given file within the storage directory: $path = storage_path(); $path = storage_path('app/file.txt'); Strings () The function translates the given translation string or translation key using your localization files : echo __('Welcome to our application'); echo __('messages.welcome'); If the specified translation string or key does not exist, the function will return the given value. So, using the example above, the function would return messages.welcome if that translation key does not exist. camel_case() The camel_case function converts the given string to camelCase: $converted = camel_case('foo_bar'); // fooBar class_basename() The class_basename returns the class name of the given class with the class' namespace removed: $class = class_basename('Foo\\Bar\\Baz'); // Baz e() The e function runs PHP's htmlspecialchars function with the double_encode option set to true by default: echo e(' html foo /html '); // lt;html gt;foo lt;/html gt; ends_with() The ends_with function determines if the given string ends with the given value: $result = ends_with('This is my name', 'name'); // true kebab_case() The kebab_case function converts the given string to kebab-case: $converted = kebab_case('fooBar'); // foo-bar preg_replace_array() The preg_replace_array function replaces a given pattern in the string sequentially using an array: $string = 'The event will take place between :start and :end'; $replaced = preg_replace_array('/:[a-z_]+/', ['8:30', '9:00'], $string); // The event will take place between 8:30 and 9:00 snake_case() The snake_case function converts the given string to snake_case: $converted = snake_case('fooBar'); // foo_bar starts_with() The starts_with function determines if the given string begins with the given value: $result = starts_with('This is my name', 'This'); // true str_after() The str_after function returns everything after the given value in a string: $slice = str_after('This is my name', 'This is'); // ' my name' str_before() The str_before function returns everything before the given value in a string: $slice = str_before('This is my name', 'my name'); // 'This is ' str_contains() The str_contains function determines if the given string contains the given value (case sensitive): $contains = str_contains('This is my name', 'my'); // true You may also pass an array of values to determine if the given string contains any of the values: $contains = str_contains('This is my name', ['my', 'foo']); // true str_finish() The str_finish function adds a single instance of the given value to a string if it does not already end with the value: $adjusted = str_finish('this/string', '/'); // this/string/ $adjusted = str_finish('this/string/', '/'); // this/string/ str_is() The str_is function determines if a given string matches a given pattern. Asterisks may be used to indicate wildcards: $matches = str_is('foo*', 'foobar'); // true $matches = str_is('baz*', 'foobar'); // false str_limit() The str_limit function truncates the given string at the specified length: $truncated = str_limit('The quick brown fox jumps over the lazy dog', 20); // The quick brown fox... You may also pass a third argument to change the string that will be appended to the end: $truncated = str_limit('The quick brown fox jumps over the lazy dog', 20, ' (...)'); // The quick brown fox (...) Str::orderedUuid() The Str::orderedUuid method generates a \"timestamp first\" UUID that may be efficiently stored in an indexed database column: use Illuminate\\Support\\Str; return (string) Str::orderedUuid(); str_plural() The str_plural function converts a string to its plural form. This function currently only supports the English language: $plural = str_plural('car'); // cars $plural = str_plural('child'); // children You may provide an integer as a second argument to the function to retrieve the singular or plural form of the string: $plural = str_plural('child', 2); // children $plural = str_plural('child', 1); // child str_random() The str_random function generates a random string of the specified length. This function uses PHP's random_bytes function: $random = str_random(40); str_replace_array() The str_replace_array function replaces a given value in the string sequentially using an array: $string = 'The event will take place between ? and ?'; $replaced = str_replace_array('?', ['8:30', '9:00'], $string); // The event will take place between 8:30 and 9:00 str_replace_first() The str_replace_first function replaces the first occurrence of a given value in a string: $replaced = str_replace_first('the', 'a', 'the quick brown fox jumps over the lazy dog'); // a quick brown fox jumps over the lazy dog str_replace_last() The str_replace_last function replaces the last occurrence of a given value in a string: $replaced = str_replace_last('the', 'a', 'the quick brown fox jumps over the lazy dog'); // the quick brown fox jumps over a lazy dog str_singular() The str_singular function converts a string to its singular form. This function currently only supports the English language: $singular = str_singular('cars'); // car $singular = str_singular('children'); // child str_slug() The str_slug function generates a URL friendly \"slug\" from the given string: $slug = str_slug('Space MVC 5 Framework', '-'); // Space MVC str_start() The str_start function adds a single instance of the given value to a string if it does not already start with the value: $adjusted = str_start('this/string', '/'); // /this/string $adjusted = str_start('/this/string', '/'); // /this/string studly_case() The studly_case function converts the given string to StudlyCase: $converted = studly_case('foo_bar'); // FooBar title_case() The title_case function converts the given string to Title Case: $converted = title_case('a nice title uses the correct case'); // A Nice Title Uses The Correct Case trans() The trans function translates the given translation key using your localization files : echo trans('messages.welcome'); If the specified translation key does not exist, the trans function will return the given key. So, using the example above, the trans function would return messages.welcome if the translation key does not exist. trans_choice() The trans_choice function translates the given translation key with inflection: echo trans_choice('messages.notifications', $unreadCount); If the specified translation key does not exist, the trans_choice function will return the given key. So, using the example above, the trans_choice function would return messages.notifications if the translation key does not exist. Str::uuid() The Str::uuid method generates a UUID (version 4): use Illuminate\\Support\\Str; return (string) Str::uuid(); URLs action() The action function generates a URL for the given controller action. You do not need to pass the full namespace of the controller. Instead, pass the controller class name relative to the App\\Http\\Controllers namespace: $url = action('HomeController@index'); $url = action([HomeController::class, 'index']); If the method accepts route parameters, you may pass them as the second argument to the method: $url = action('UserController@profile', ['id' = 1]); asset() The asset function generates a URL for an asset using the current scheme of the request (HTTP or HTTPS): $url = asset('img/photo.jpg'); secure_asset() The secure_asset function generates a URL for an asset using HTTPS: $url = secure_asset('img/photo.jpg'); route() The route function generates a URL for the given named route: $url = route('routeName'); If the route accepts parameters, you may pass them as the second argument to the method: $url = route('routeName', ['id' = 1]); By default, the route function generates an absolute URL. If you wish to generate a relative URL, you may pass false as the third argument: $url = route('routeName', ['id' = 1], false); secure_url() The secure_url function generates a fully qualified HTTPS URL to the given path: $url = secure_url('user/profile'); $url = secure_url('user/profile', [1]); url() The url function generates a fully qualified URL to the given path: $url = url('user/profile'); $url = url('user/profile', [1]); If no path is provided, a Illuminate\\Routing\\UrlGenerator instance is returned: $current = url()- current(); $full = url()- full(); $previous = url()- previous(); Miscellaneous abort() The abort function throws an HTTP exception which will be rendered by the exception handler : abort(403); You may also provide the exception's response text and custom response headers: abort(403, 'Unauthorized.', $headers); abort_if() The abort_if function throws an HTTP exception if a given boolean expression evaluates to true: abort_if(! Auth::user()- isAdmin(), 403); Like the abort method, you may also provide the exception's response text as the third argument and an array of custom response headers as the fourth argument. abort_unless() The abort_unless function throws an HTTP exception if a given boolean expression evaluates to false: abort_unless(Auth::user()- isAdmin(), 403); Like the abort method, you may also provide the exception's response text as the third argument and an array of custom response headers as the fourth argument. app() The app function returns the service container instance: $container = app(); You may pass a class or interface name to resolve it from the container: $api = app('HelpSpot\\API'); auth() The auth function returns an authenticator instance. You may use it instead of the Auth facade for convenience: $user = auth()- user(); If needed, you may specify which guard instance you would like to access: $user = auth('admin')- user(); back() The back function generates a redirect HTTP response to the user's previous location: return back($status = 302, $headers = [], $fallback = false); return back(); bcrypt() The bcrypt function hashes the given value using Bcrypt. You may use it as an alternative to the Hash facade: $password = bcrypt('my-secret-password'); broadcast() The broadcast function broadcasts the given event to its listeners: broadcast(new UserRegistered($user)); blank() The blank function returns whether the given value is \"blank\": blank(''); blank(' '); blank(null); blank(collect()); // true blank(0); blank(true); blank(false); // false For the inverse of blank, see the filled method. cache() The cache function may be used to get values from the cache . If the given key does not exist in the cache, an optional default value will be returned: $value = cache('key'); $value = cache('key', 'default'); You may add items to the cache by passing an array of key / value pairs to the function. You should also pass the number of minutes or duration the cached value should be considered valid: cache(['key' = 'value'], 5); cache(['key' = 'value'], now()- addSeconds(10)); class_uses_recursive() The class_uses_recursive function returns all traits used by a class, including traits used by all of its parent classes: $traits = class_uses_recursive(App\\User::class); collect() The collect function creates a collection instance from the given value: $collection = collect(['taylor', 'abigail']); config() The config function gets the value of a configuration variable. The configuration values may be accessed using \"dot\" syntax, which includes the name of the file and the option you wish to access. A default value may be specified and is returned if the configuration option does not exist: $value = config('app.timezone'); $value = config('app.timezone', $default); You may set configuration variables at runtime by passing an array of key / value pairs: config(['app.debug' = true]); cookie() The cookie function creates a new cookie instance: $cookie = cookie('name', 'value', $minutes); csrf_field() The csrf_field function generates an HTML hidden input field containing the value of the CSRF token. For example, using Blade syntax : {{ csrf_field() }} csrf_token() The csrf_token function retrieves the value of the current CSRF token: $token = csrf_token(); dd() The dd function dumps the given variables and ends execution of the script: dd($value); dd($value1, $value2, $value3, ...); If you do not want to halt the execution of your script, use the dump function instead. decrypt() The decrypt function decrypts the given value using Space MVC's encrypter : $decrypted = decrypt($encrypted_value); dispatch() The dispatch function pushes the given job onto the Space MVC job queue : dispatch(new App\\Jobs\\SendEmails); dispatch_now() The dispatch_now function runs the given job immediately and returns the value from its handle method: $result = dispatch_now(new App\\Jobs\\SendEmails); dump() The dump function dumps the given variables: dump($value); dump($value1, $value2, $value3, ...); If you want to stop executing the script after dumping the variables, use the dd function instead. You may use Artisan's dump-server command to intercept all dump calls and display them in your console window instead of your browser. encrypt() The encrypt function encrypts the given value using Space MVC's encrypter : $encrypted = encrypt($unencrypted_value); env() The env function retrieves the value of an environment variable or returns a default value: $env = env('APP_ENV'); // Returns 'production' if APP_ENV is not set... $env = env('APP_ENV', 'production'); If you execute the config:cache command during your deployment process, you should be sure that you are only calling the env function from within your configuration files. Once the configuration has been cached, the .env file will not be loaded and all calls to the env function will return null. event() The event function dispatches the given event to its listeners: event(new UserRegistered($user)); factory() The factory function creates a model factory builder for a given class, name, and amount. It can be used while testing or seeding : $user = factory(App\\User::class)- make(); filled() The filled function returns whether the given value is not \"blank\": filled(0); filled(true); filled(false); // true filled(''); filled(' '); filled(null); filled(collect()); // false For the inverse of filled, see the blank method. info() The info function will write information to the log : info('Some helpful information!'); An array of contextual data may also be passed to the function: info('User login attempt failed.', ['id' = $user- id]); logger() The logger function can be used to write a debug level message to the log : logger('Debug message'); An array of contextual data may also be passed to the function: logger('User has logged in.', ['id' = $user- id]); A logger instance will be returned if no value is passed to the function: logger()- error('You are not allowed here.'); method_field() The method_field function generates an HTML hidden input field containing the spoofed value of the form's HTTP verb. For example, using Blade syntax : form method= POST {{ method_field('DELETE') }} /form now() The now function creates a new Illuminate\\Support\\Carbon instance for the current time: $now = now(); old() The old function retrieves an old input value flashed into the session: $value = old('value'); $value = old('value', 'default'); optional() The optional function accepts any argument and allows you to access properties or call methods on that object. If the given object is null, properties and methods will return null instead of causing an error: return optional($user- address)- street; {!! old('name', optional($user)- name) !!} The optional function also accepts a Closure as its second argument. The Closure will be invoked if the value provided as the first argument is not null: return optional(User::find($id), function ($user) { return new DummyUser; }); policy() The policy method retrieves a policy instance for a given class: $policy = policy(App\\User::class); redirect() The redirect function returns a redirect HTTP response , or returns the redirector instance if called with no arguments: return redirect($to = null, $status = 302, $headers = [], $secure = null); return redirect('/home'); return redirect()- route('route.name'); report() The report function will report an exception using your exception handler 's report method: report($e); request() The request function returns the current request instance or obtains an input item: $request = request(); $value = request('key', $default); rescue() The rescue function executes the given Closure and catches any exceptions that occur during its execution. All exceptions that are caught will be sent to your exception handler 's report method; however, the request will continue processing: return rescue(function () { return $this- method(); }); You may also pass a second argument to the rescue function. This argument will be the \"default\" value that should be returned if an exception occurs while executing the Closure: return rescue(function () { return $this- method(); }, false); return rescue(function () { return $this- method(); }, function () { return $this- failure(); }); resolve() The resolve function resolves a given class or interface name to its instance using the service container : $api = resolve('HelpSpot\\API'); response() The response function creates a response instance or obtains an instance of the response factory: return response('Hello World', 200, $headers); return response()- json(['foo' = 'bar'], 200, $headers); retry() The retry function attempts to execute the given callback until the given maximum attempt threshold is met. If the callback does not throw an exception, its return value will be returned. If the callback throws an exception, it will automatically be retried. If the maximum attempt count is exceeded, the exception will be thrown: return retry(5, function () { // Attempt 5 times while resting 100ms in between attempts... }, 100); session() The session function may be used to get or set session values: $value = session('key'); You may set values by passing an array of key / value pairs to the function: session(['chairs' = 7, 'instruments' = 3]); The session store will be returned if no value is passed to the function: $value = session()- get('key'); session()- put('key', $value); tap() The tap function accepts two arguments: an arbitrary $value and a Closure. The $value will be passed to the Closure and then be returned by the tap function. The return value of the Closure is irrelevant: $user = tap(User::first(), function ($user) { $user- name = 'taylor'; $user- save(); }); If no Closure is passed to the tap function, you may call any method on the given $value. The return value of the method you call will always be $value, regardless of what the method actually returns in its definition. For example, the Eloquent update method typically returns an integer. However, we can force the method to return the model itself by chaining the update method call through the tap function: $user = tap($user)- update([ 'name' = $name, 'email' = $email, ]); today() The today function creates a new Illuminate\\Support\\Carbon instance for the current date: $today = today(); throw_if() The throw_if function throws the given exception if a given boolean expression evaluates to true: throw_if(! Auth::user()- isAdmin(), AuthorizationException::class); throw_if( ! Auth::user()- isAdmin(), AuthorizationException::class, 'You are not allowed to access this page' ); throw_unless() The throw_unless function throws the given exception if a given boolean expression evaluates to false: throw_unless(Auth::user()- isAdmin(), AuthorizationException::class); throw_unless( Auth::user()- isAdmin(), AuthorizationException::class, 'You are not allowed to access this page' ); trait_uses_recursive() The trait_uses_recursive function returns all traits used by a trait: $traits = trait_uses_recursive(\\Illuminate\\Notifications\\Notifiable::class); transform() The transform function executes a Closure on a given value if the value is not blank and returns the result of the Closure: $callback = function ($value) { return $value * 2; }; $result = transform(5, $callback); // 10 A default value or Closure may also be passed as the third parameter to the method. This value will be returned if the given value is blank: $result = transform(null, $callback, 'The value is blank'); // The value is blank validator() The validator function creates a new validator instance with the given arguments. You may use it instead of the Validator facade for convenience: $validator = validator($data, $rules, $messages); value() The value function returns the value it is given. However, if you pass a Closure to the function, the Closure will be executed then its result will be returned: $result = value(true); // true $result = value(function () { return false; }); // false view() The view function retrieves a view instance: return view('auth.login'); with() The with function returns the value it is given. If a Closure is passed as the second argument to the function, the Closure will be executed and its result will be returned: $callback = function ($value) { return (is_numeric($value)) ? $value * 2 : 0; }; $result = with(5, $callback); // 10 $result = with(null, $callback); // 0 $result = with(5, null); // 5","title":"Helpers"},{"location":"helpers/#helpers","text":"ul li a href=\"#introduction\" Introduction /a /li li a href=\"#available-methods\" Available Methods /a /li /ul","title":"Helpers"},{"location":"helpers/#introduction","text":"Space MVC includes a variety of global \"helper\" PHP functions. Many of these functions are used by the framework itself; however, you are free to use them in your own applications if you find them convenient.","title":"Introduction"},{"location":"helpers/#available-methods","text":"style .collection-method-list p { column-count: 3; -moz-column-count: 3; -webkit-column-count: 3; column-gap: 2em; -moz-column-gap: 2em; -webkit-column-gap: 2em; } .collection-method-list a { display: block; } /style","title":"Available Methods"},{"location":"helpers/#arrays-objects","text":"div class=\"collection-method-list\" a href=\"#method-array-add\" array_add /a a href=\"#method-array-collapse\" array_collapse /a a href=\"#method-array-divide\" array_divide /a a href=\"#method-array-dot\" array_dot /a a href=\"#method-array-except\" array_except /a a href=\"#method-array-first\" array_first /a a href=\"#method-array-flatten\" array_flatten /a a href=\"#method-array-forget\" array_forget /a a href=\"#method-array-get\" array_get /a a href=\"#method-array-has\" array_has /a a href=\"#method-array-last\" array_last /a a href=\"#method-array-only\" array_only /a a href=\"#method-array-pluck\" array_pluck /a a href=\"#method-array-prepend\" array_prepend /a a href=\"#method-array-pull\" array_pull /a a href=\"#method-array-random\" array_random /a a href=\"#method-array-set\" array_set /a a href=\"#method-array-sort\" array_sort /a a href=\"#method-array-sort-recursive\" array_sort_recursive /a a href=\"#method-array-where\" array_where /a a href=\"#method-array-wrap\" array_wrap /a a href=\"#method-data-fill\" data_fill /a a href=\"#method-data-get\" data_get /a a href=\"#method-data-set\" data_set /a a href=\"#method-head\" head /a a href=\"#method-last\" last /a /div","title":"Arrays &amp; Objects"},{"location":"helpers/#paths","text":"div class=\"collection-method-list\" a href=\"#method-app-path\" app_path /a a href=\"#method-base-path\" base_path /a a href=\"#method-config-path\" config_path /a a href=\"#method-database-path\" database_path /a a href=\"#method-mix\" mix /a a href=\"#method-public-path\" public_path /a a href=\"#method-resource-path\" resource_path /a a href=\"#method-storage-path\" storage_path /a /div","title":"Paths"},{"location":"helpers/#strings","text":"div class=\"collection-method-list\" a href=\"#method-__\" __ /a a href=\"#method-camel-case\" camel_case /a a href=\"#method-class-basename\" class_basename /a a href=\"#method-e\" e /a a href=\"#method-ends-with\" ends_with /a a href=\"#method-kebab-case\" kebab_case /a a href=\"#method-preg-replace-array\" preg_replace_array /a a href=\"#method-snake-case\" snake_case /a a href=\"#method-starts-with\" starts_with /a a href=\"#method-str-after\" str_after /a a href=\"#method-str-before\" str_before /a a href=\"#method-str-contains\" str_contains /a a href=\"#method-str-finish\" str_finish /a a href=\"#method-str-is\" str_is /a a href=\"#method-str-limit\" str_limit /a a href=\"#method-str-ordered-uuid\" Str::orderedUuid /a a href=\"#method-str-plural\" str_plural /a a href=\"#method-str-random\" str_random /a a href=\"#method-str-replace-array\" str_replace_array /a a href=\"#method-str-replace-first\" str_replace_first /a a href=\"#method-str-replace-last\" str_replace_last /a a href=\"#method-str-singular\" str_singular /a a href=\"#method-str-slug\" str_slug /a a href=\"#method-str-start\" str_start /a a href=\"#method-studly-case\" studly_case /a a href=\"#method-title-case\" title_case /a a href=\"#method-trans\" trans /a a href=\"#method-trans-choice\" trans_choice /a a href=\"#method-str-uuid\" Str::uuid /a /div","title":"Strings"},{"location":"helpers/#urls","text":"div class=\"collection-method-list\" a href=\"#method-action\" action /a a href=\"#method-asset\" asset /a a href=\"#method-secure-asset\" secure_asset /a a href=\"#method-route\" route /a a href=\"#method-secure-url\" secure_url /a a href=\"#method-url\" url /a /div","title":"URLs"},{"location":"helpers/#miscellaneous","text":"div class=\"collection-method-list\" a href=\"#method-abort\" abort /a a href=\"#method-abort-if\" abort_if /a a href=\"#method-abort-unless\" abort_unless /a a href=\"#method-app\" app /a a href=\"#method-auth\" auth /a a href=\"#method-back\" back /a a href=\"#method-bcrypt\" bcrypt /a a href=\"#method-blank\" blank /a a href=\"#method-broadcast\" broadcast /a a href=\"#method-cache\" cache /a a href=\"#method-class-uses-recursive\" class_uses_recursive /a a href=\"#method-collect\" collect /a a href=\"#method-config\" config /a a href=\"#method-cookie\" cookie /a a href=\"#method-csrf-field\" csrf_field /a a href=\"#method-csrf-token\" csrf_token /a a href=\"#method-dd\" dd /a a href=\"#method-decrypt\" decrypt /a a href=\"#method-dispatch\" dispatch /a a href=\"#method-dispatch-now\" dispatch_now /a a href=\"#method-dump\" dump /a a href=\"#method-encrypt\" encrypt /a a href=\"#method-env\" env /a a href=\"#method-event\" event /a a href=\"#method-factory\" factory /a a href=\"#method-filled\" filled /a a href=\"#method-info\" info /a a href=\"#method-logger\" logger /a a href=\"#method-method-field\" method_field /a a href=\"#method-now\" now /a a href=\"#method-old\" old /a a href=\"#method-optional\" optional /a a href=\"#method-policy\" policy /a a href=\"#method-redirect\" redirect /a a href=\"#method-report\" report /a a href=\"#method-request\" request /a a href=\"#method-rescue\" rescue /a a href=\"#method-resolve\" resolve /a a href=\"#method-response\" response /a a href=\"#method-retry\" retry /a a href=\"#method-session\" session /a a href=\"#method-tap\" tap /a a href=\"#method-today\" today /a a href=\"#method-throw-if\" throw_if /a a href=\"#method-throw-unless\" throw_unless /a a href=\"#method-trait-uses-recursive\" trait_uses_recursive /a a href=\"#method-transform\" transform /a a href=\"#method-validator\" validator /a a href=\"#method-value\" value /a a href=\"#method-view\" view /a a href=\"#method-with\" with /a /div","title":"Miscellaneous"},{"location":"helpers/#method-listing","text":"style #collection-method code { font-size: 14px; } #collection-method:not(.first-collection-method) { margin-top: 50px; } /style","title":"Method Listing"},{"location":"helpers/#arrays-objects_1","text":"","title":"Arrays &amp; Objects"},{"location":"helpers/#paths_1","text":"","title":"Paths"},{"location":"helpers/#strings_1","text":"","title":"Strings"},{"location":"helpers/#urls_1","text":"","title":"URLs"},{"location":"helpers/#miscellaneous_1","text":"","title":"Miscellaneous"},{"location":"installation/","text":"Server Requirements The Space MVC framework has a few system requirements: PHP = 7.0.0 PDO PHP Extension PHP Memcached Mysql Database Installing Framework You can install Space CRM quite easily using github and composer. git clone https://github.com/space-mvc/space-mvc.git composer install Web Server Configuration Apache Space MVC includes a public/.htaccess file that is used to provide URLs without the index.php front controller in the path. Before serving Space MVC with Apache, be sure to enable the mod_rewrite module so the .htaccess file will be honored by the server. If the .htaccess file that ships with Space MVC does not work with your Apache installation, try this alternative: Options +FollowSymLinks -Indexes RewriteEngine On RewriteCond %{HTTP:Authorization} . RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}] RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.php [L] Nginx If you are using Nginx, the following directive in your site configuration will direct all requests to the index.php front controller: location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Space MVC Installation"},{"location":"installation/#server-requirements","text":"The Space MVC framework has a few system requirements: PHP = 7.0.0 PDO PHP Extension PHP Memcached Mysql Database","title":"Server Requirements"},{"location":"installation/#installing-framework","text":"You can install Space CRM quite easily using github and composer. git clone https://github.com/space-mvc/space-mvc.git composer install","title":"Installing Framework"},{"location":"installation/#web-server-configuration","text":"","title":"Web Server Configuration"},{"location":"installation/#apache","text":"Space MVC includes a public/.htaccess file that is used to provide URLs without the index.php front controller in the path. Before serving Space MVC with Apache, be sure to enable the mod_rewrite module so the .htaccess file will be honored by the server. If the .htaccess file that ships with Space MVC does not work with your Apache installation, try this alternative: Options +FollowSymLinks -Indexes RewriteEngine On RewriteCond %{HTTP:Authorization} . RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}] RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.php [L]","title":"Apache"},{"location":"installation/#nginx","text":"If you are using Nginx, the following directive in your site configuration will direct all requests to the index.php front controller: location / { try_files $uri $uri/ /index.php?$query_string; }","title":"Nginx"},{"location":"logging/","text":"Logging Introduction To help you learn more about what's happening within your application, Space MVC provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team. Under the hood, Space MVC utilizes the Monolog library, which provides support for a variety of powerful log handlers. Space MVC makes it a cinch to configure these handlers, allowing you to mix and match them to customize your application's log handling. Configuration All of the configuration for your application's logging system is housed in the config/logging.php configuration file. This file allows you to configure your application's log channels, so be sure to review each of the available channels and their options. Of course, we'll review a few common options below. By default, Space MVC will use the stack channel when logging messages. The stack channel is used to aggregate multiple log channels into a single channel. For more information on building stacks, check out the documentation below . Configuring The Channel Name By default, Monolog is instantiated with a \"channel name\" that matches the current environment, such as production or local. To change this value, add a name option to your channel's configuration: 'stack' = [ 'driver' = 'stack', 'name' = 'channel-name', 'channels' = ['single', 'slack'], ], Available Channel Drivers Name Description stack A wrapper to facilitate creating \"multi-channel\" channels single A single file or path based logger channel (StreamHandler) daily A RotatingFileHandler based Monolog driver which rotates daily slack A SlackWebhookHandler based Monolog driver syslog A SyslogHandler based Monolog driver errorlog A ErrorLogHandler based Monolog driver monolog A Monolog factory driver that may use any supported Monolog handler custom A driver that calls a specified factory to create a channel Check out the documentation on advanced channel customization to learn more about the monolog and custom drivers. Configuring The Slack Channel The slack channel requires a url configuration option. This URL should match a URL for an incoming webhook that you have configured for your Slack team. Building Log Stacks As previously mentioned, the stack driver allows you to combine multiple channels into a single log channel. To illustrate how to use log stacks, let's take a look at an example configuration that you might see in a production application: 'channels' = [ 'stack' = [ 'driver' = 'stack', 'channels' = ['syslog', 'slack'], ], 'syslog' = [ 'driver' = 'syslog', 'level' = 'debug', ], 'slack' = [ 'driver' = 'slack', 'url' = env('LOG_SLACK_WEBHOOK_URL'), 'username' = 'Space MVC Log', 'emoji' = ':boom:', 'level' = 'critical', ], ], Let's dissect this configuration. First, notice our stack channel aggregates two other channels via its channels option: syslog and slack. So, when logging messages, both of these channels will have the opportunity to log the message. Log Levels Take note of the level configuration option present on the syslog and slack channel configurations in the example above. This option determines the minimum \"level\" a message must be in order to be logged by the channel. Monolog, which powers Space MVC's logging services, offers all of the log levels defined in the RFC 5424 specification : emergency , alert , critical , error , warning , notice , info , and debug . So, imagine we log a message using the debug method: Log::debug('An informational message.'); Given our configuration, the syslog channel will write the message to the system log; however, since the error message is not critical or above, it will not be sent to Slack. However, if we log an emergency message, it will be sent to both the system log and Slack since the emergency level is above our minimum level threshold for both channels: Log::emergency('The system is down!'); Writing Log Messages You may write information to the logs using the Log facade . As previously mentioned, the logger provides the eight logging levels defined in the RFC 5424 specification : emergency , alert , critical , error , warning , notice , info and debug : Log::emergency($message); Log::alert($message); Log::critical($message); Log::error($message); Log::warning($message); Log::notice($message); Log::info($message); Log::debug($message); So, you may call any of these methods to log a message for the corresponding level. By default, the message will be written to the default log channel as configured by your config/logging.php configuration file: ?php namespace App\\Http\\Controllers; use App\\User; use Illuminate\\Support\\Facades\\Log; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param int $id * @return Response */ public function showProfile($id) { Log::info('Showing user profile for user: '.$id); return view('user.profile', ['user' = User::findOrFail($id)]); } } Contextual Information An array of contextual data may also be passed to the log methods. This contextual data will be formatted and displayed with the log message: Log::info('User failed to login.', ['id' = $user- id]); Writing To Specific Channels Sometimes you may wish to log a message to a channel other than your application's default channel. You may use the channel method on the Log facade to retrieve and log to any channel defined in your configuration file: Log::channel('slack')- info('Something happened!'); If you would like to create an on-demand logging stack consisting of multiple channels, you may use the stack method: Log::stack(['single', 'slack'])- info('Something happened!'); Advanced Monolog Channel Customization Customizing Monolog For Channels Sometimes you may need complete control over how Monolog is configured for an existing channel. For example, you may want to configure a custom Monolog FormatterInterface implementation for a given channel's handlers. To get started, define a tap array on the channel's configuration. The tap array should contain a list of classes that should have an opportunity to customize (or \"tap\" into) the Monolog instance after it is created: 'single' = [ 'driver' = 'single', 'tap' = [App\\Logging\\CustomizeFormatter::class], 'path' = storage_path('logs/Space MVC.log'), 'level' = 'debug', ], Once you have configured the tap option on your channel, you're ready to define the class that will customize your Monolog instance. This class only needs a single method: __invoke, which receives an Illuminate\\Log\\Logger instance. The Illuminate\\Log\\Logger instance proxies all method calls to the underlying Monolog instance: ?php namespace App\\Logging; class CustomizeFormatter { /** * Customize the given logger instance. * * @param \\Illuminate\\Log\\Logger $logger * @return void */ public function __invoke($logger) { foreach ($logger- getHandlers() as $handler) { $handler- setFormatter(...); } } } All of your \"tap\" classes are resolved by the service container , so any constructor dependencies they require will automatically be injected. Creating Monolog Handler Channels Monolog has a variety of available handlers . In some cases, the type of logger you wish to create is merely a Monolog driver with an instance of a specific handler. These channels can be created using the monolog driver. When using the monolog driver, the handler configuration option is used to specify which handler will be instantiated. Optionally, any constructor parameters the handler needs may be specified using the handler_with configuration option: 'logentries' = [ 'driver' = 'monolog', 'handler' = Monolog\\Handler\\SyslogUdpHandler::class, 'handler_with' = [ 'host' = 'my.logentries.internal.datahubhost.company.com', 'port' = '10000', ], ], Monolog Formatters When using the monolog driver, the Monolog LineFormatter will be used as the default formatter. However, you may customize the type of formatter passed to the handler using the formatter and formatter_with configuration options: 'browser' = [ 'driver' = 'monolog', 'handler' = Monolog\\Handler\\BrowserConsoleHandler::class, 'formatter' = Monolog\\Formatter\\HtmlFormatter::class, 'formatter_with' = [ 'dateFormat' = 'Y-m-d', ], ], If you are using a Monolog handler that is capable of providing its own formatter, you may set the value of the formatter configuration option to default: 'newrelic' = [ 'driver' = 'monolog', 'handler' = Monolog\\Handler\\NewRelicHandler::class, 'formatter' = 'default', ], Creating Channels Via Factories If you would like to define an entirely custom channel in which you have full control over Monolog's instantiation and configuration, you may specify a custom driver type in your config/logging.php configuration file. Your configuration should include a via option to point to the factory class which will be invoked to create the Monolog instance: 'channels' = [ 'custom' = [ 'driver' = 'custom', 'via' = App\\Logging\\CreateCustomLogger::class, ], ], Once you have configured the custom channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method: __invoke, which should return the Monolog instance: ?php namespace App\\Logging; use Monolog\\Logger; class CreateCustomLogger { /** * Create a custom Monolog instance. * * @param array $config * @return \\Monolog\\Logger */ public function __invoke(array $config) { return new Logger(...); } }","title":"Logging"},{"location":"logging/#logging","text":"","title":"Logging"},{"location":"logging/#introduction","text":"To help you learn more about what's happening within your application, Space MVC provides robust logging services that allow you to log messages to files, the system error log, and even to Slack to notify your entire team. Under the hood, Space MVC utilizes the Monolog library, which provides support for a variety of powerful log handlers. Space MVC makes it a cinch to configure these handlers, allowing you to mix and match them to customize your application's log handling.","title":"Introduction"},{"location":"logging/#configuration","text":"All of the configuration for your application's logging system is housed in the config/logging.php configuration file. This file allows you to configure your application's log channels, so be sure to review each of the available channels and their options. Of course, we'll review a few common options below. By default, Space MVC will use the stack channel when logging messages. The stack channel is used to aggregate multiple log channels into a single channel. For more information on building stacks, check out the documentation below .","title":"Configuration"},{"location":"logging/#configuring-the-channel-name","text":"By default, Monolog is instantiated with a \"channel name\" that matches the current environment, such as production or local. To change this value, add a name option to your channel's configuration: 'stack' = [ 'driver' = 'stack', 'name' = 'channel-name', 'channels' = ['single', 'slack'], ],","title":"Configuring The Channel Name"},{"location":"logging/#available-channel-drivers","text":"Name Description stack A wrapper to facilitate creating \"multi-channel\" channels single A single file or path based logger channel (StreamHandler) daily A RotatingFileHandler based Monolog driver which rotates daily slack A SlackWebhookHandler based Monolog driver syslog A SyslogHandler based Monolog driver errorlog A ErrorLogHandler based Monolog driver monolog A Monolog factory driver that may use any supported Monolog handler custom A driver that calls a specified factory to create a channel Check out the documentation on advanced channel customization to learn more about the monolog and custom drivers.","title":"Available Channel Drivers"},{"location":"logging/#configuring-the-slack-channel","text":"The slack channel requires a url configuration option. This URL should match a URL for an incoming webhook that you have configured for your Slack team.","title":"Configuring The Slack Channel"},{"location":"logging/#building-log-stacks","text":"As previously mentioned, the stack driver allows you to combine multiple channels into a single log channel. To illustrate how to use log stacks, let's take a look at an example configuration that you might see in a production application: 'channels' = [ 'stack' = [ 'driver' = 'stack', 'channels' = ['syslog', 'slack'], ], 'syslog' = [ 'driver' = 'syslog', 'level' = 'debug', ], 'slack' = [ 'driver' = 'slack', 'url' = env('LOG_SLACK_WEBHOOK_URL'), 'username' = 'Space MVC Log', 'emoji' = ':boom:', 'level' = 'critical', ], ], Let's dissect this configuration. First, notice our stack channel aggregates two other channels via its channels option: syslog and slack. So, when logging messages, both of these channels will have the opportunity to log the message.","title":"Building Log Stacks"},{"location":"logging/#log-levels","text":"Take note of the level configuration option present on the syslog and slack channel configurations in the example above. This option determines the minimum \"level\" a message must be in order to be logged by the channel. Monolog, which powers Space MVC's logging services, offers all of the log levels defined in the RFC 5424 specification : emergency , alert , critical , error , warning , notice , info , and debug . So, imagine we log a message using the debug method: Log::debug('An informational message.'); Given our configuration, the syslog channel will write the message to the system log; however, since the error message is not critical or above, it will not be sent to Slack. However, if we log an emergency message, it will be sent to both the system log and Slack since the emergency level is above our minimum level threshold for both channels: Log::emergency('The system is down!');","title":"Log Levels"},{"location":"logging/#writing-log-messages","text":"You may write information to the logs using the Log facade . As previously mentioned, the logger provides the eight logging levels defined in the RFC 5424 specification : emergency , alert , critical , error , warning , notice , info and debug : Log::emergency($message); Log::alert($message); Log::critical($message); Log::error($message); Log::warning($message); Log::notice($message); Log::info($message); Log::debug($message); So, you may call any of these methods to log a message for the corresponding level. By default, the message will be written to the default log channel as configured by your config/logging.php configuration file: ?php namespace App\\Http\\Controllers; use App\\User; use Illuminate\\Support\\Facades\\Log; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param int $id * @return Response */ public function showProfile($id) { Log::info('Showing user profile for user: '.$id); return view('user.profile', ['user' = User::findOrFail($id)]); } }","title":"Writing Log Messages"},{"location":"logging/#contextual-information","text":"An array of contextual data may also be passed to the log methods. This contextual data will be formatted and displayed with the log message: Log::info('User failed to login.', ['id' = $user- id]);","title":"Contextual Information"},{"location":"logging/#writing-to-specific-channels","text":"Sometimes you may wish to log a message to a channel other than your application's default channel. You may use the channel method on the Log facade to retrieve and log to any channel defined in your configuration file: Log::channel('slack')- info('Something happened!'); If you would like to create an on-demand logging stack consisting of multiple channels, you may use the stack method: Log::stack(['single', 'slack'])- info('Something happened!');","title":"Writing To Specific Channels"},{"location":"logging/#advanced-monolog-channel-customization","text":"","title":"Advanced Monolog Channel Customization"},{"location":"logging/#customizing-monolog-for-channels","text":"Sometimes you may need complete control over how Monolog is configured for an existing channel. For example, you may want to configure a custom Monolog FormatterInterface implementation for a given channel's handlers. To get started, define a tap array on the channel's configuration. The tap array should contain a list of classes that should have an opportunity to customize (or \"tap\" into) the Monolog instance after it is created: 'single' = [ 'driver' = 'single', 'tap' = [App\\Logging\\CustomizeFormatter::class], 'path' = storage_path('logs/Space MVC.log'), 'level' = 'debug', ], Once you have configured the tap option on your channel, you're ready to define the class that will customize your Monolog instance. This class only needs a single method: __invoke, which receives an Illuminate\\Log\\Logger instance. The Illuminate\\Log\\Logger instance proxies all method calls to the underlying Monolog instance: ?php namespace App\\Logging; class CustomizeFormatter { /** * Customize the given logger instance. * * @param \\Illuminate\\Log\\Logger $logger * @return void */ public function __invoke($logger) { foreach ($logger- getHandlers() as $handler) { $handler- setFormatter(...); } } } All of your \"tap\" classes are resolved by the service container , so any constructor dependencies they require will automatically be injected.","title":"Customizing Monolog For Channels"},{"location":"logging/#creating-monolog-handler-channels","text":"Monolog has a variety of available handlers . In some cases, the type of logger you wish to create is merely a Monolog driver with an instance of a specific handler. These channels can be created using the monolog driver. When using the monolog driver, the handler configuration option is used to specify which handler will be instantiated. Optionally, any constructor parameters the handler needs may be specified using the handler_with configuration option: 'logentries' = [ 'driver' = 'monolog', 'handler' = Monolog\\Handler\\SyslogUdpHandler::class, 'handler_with' = [ 'host' = 'my.logentries.internal.datahubhost.company.com', 'port' = '10000', ], ],","title":"Creating Monolog Handler Channels"},{"location":"logging/#monolog-formatters","text":"When using the monolog driver, the Monolog LineFormatter will be used as the default formatter. However, you may customize the type of formatter passed to the handler using the formatter and formatter_with configuration options: 'browser' = [ 'driver' = 'monolog', 'handler' = Monolog\\Handler\\BrowserConsoleHandler::class, 'formatter' = Monolog\\Formatter\\HtmlFormatter::class, 'formatter_with' = [ 'dateFormat' = 'Y-m-d', ], ], If you are using a Monolog handler that is capable of providing its own formatter, you may set the value of the formatter configuration option to default: 'newrelic' = [ 'driver' = 'monolog', 'handler' = Monolog\\Handler\\NewRelicHandler::class, 'formatter' = 'default', ],","title":"Monolog Formatters"},{"location":"logging/#creating-channels-via-factories","text":"If you would like to define an entirely custom channel in which you have full control over Monolog's instantiation and configuration, you may specify a custom driver type in your config/logging.php configuration file. Your configuration should include a via option to point to the factory class which will be invoked to create the Monolog instance: 'channels' = [ 'custom' = [ 'driver' = 'custom', 'via' = App\\Logging\\CreateCustomLogger::class, ], ], Once you have configured the custom channel, you're ready to define the class that will create your Monolog instance. This class only needs a single method: __invoke, which should return the Monolog instance: ?php namespace App\\Logging; use Monolog\\Logger; class CreateCustomLogger { /** * Create a custom Monolog instance. * * @param array $config * @return \\Monolog\\Logger */ public function __invoke(array $config) { return new Logger(...); } }","title":"Creating Channels Via Factories"},{"location":"mail/","text":"Mail Space MVC provides a clean, simple API over the popular SwiftMailer library with drivers for SMTP, Mailgun, SparkPost, Amazon SES, PHP's mail function, and sendmail, allowing you to quickly get started sending mail through a local or cloud based service of your choice. Driver Prerequisites The API based drivers such as Mailgun and SparkPost are often simpler and faster than SMTP servers. If possible, you should use one of these drivers. All of the API drivers require the Guzzle HTTP library, which may be installed via the Composer package manager: composer require guzzlehttp/guzzle Mailgun Driver To use the Mailgun driver, first install Guzzle, then set the driver option in your config/mail.php configuration file to mailgun. Next, verify that your config/services.php configuration file contains the following options: 'mailgun' = [ 'domain' = 'your-mailgun-domain', 'secret' = 'your-mailgun-key', ], If you are not using the \"US\" Mailgun region , you may define your region's endpoint in the services configuration file: 'mailgun' = [ 'domain' = 'your-mailgun-domain', 'secret' = 'your-mailgun-key', 'endpoint' = 'api.eu.mailgun.net', ], SparkPost Driver To use the SparkPost driver, first install Guzzle, then set the driver option in your config/mail.php configuration file to sparkpost. Next, verify that your config/services.php configuration file contains the following options: 'sparkpost' = [ 'secret' = 'your-sparkpost-key', ], If necessary, you may also configure which API endpoint should be used: 'sparkpost' = [ 'secret' = 'your-sparkpost-key', 'options' = [ 'endpoint' = 'https://api.eu.sparkpost.com/api/v1/transmissions', ], ], SES Driver To use the Amazon SES driver you must first install the Amazon AWS SDK for PHP. You may install this library by adding the following line to your composer.json file's require section and running the composer update command: aws/aws-sdk-php : ~3.0 Next, set the driver option in your config/mail.php configuration file to ses and verify that your config/services.php configuration file contains the following options: 'ses' = [ 'key' = 'your-ses-key', 'secret' = 'your-ses-secret', 'region' = 'ses-region', // e.g. us-east-1 ], If you need to include additional options when executing the SES SendRawEmail request, you may define an options array within your ses configuration: 'ses' = [ 'key' = 'your-ses-key', 'secret' = 'your-ses-secret', 'region' = 'ses-region', // e.g. us-east-1 'options' = [ 'ConfigurationSetName' = 'MyConfigurationSet', 'Tags' = [ [ 'Name' = 'foo', 'Value' = 'bar', ], ], ], ], Generating Mailables In Space MVC, each type of email sent by your application is represented as a \"mailable\" class. These classes are stored in the app/Mail directory. Don't worry if you don't see this directory in your application, since it will be generated for you when you create your first mailable class using the make:mail command: php artisan make:mail OrderShipped Writing Mailables All of a mailable class' configuration is done in the build method. Within this method, you may call various methods such as from, subject, view, and attach to configure the email's presentation and delivery. Configuring The Sender Using The from Method First, let's explore configuring the sender of the email. Or, in other words, who the email is going to be \"from\". There are two ways to configure the sender. First, you may use the from method within your mailable class' build method: /** * Build the message. * * @return $this */ public function build() { return $this- from('example@example.com') - view('emails.orders.shipped'); } Using A Global from Address However, if your application uses the same \"from\" address for all of its emails, it can become cumbersome to call the from method in each mailable class you generate. Instead, you may specify a global \"from\" address in your config/mail.php configuration file. This address will be used if no other \"from\" address is specified within the mailable class: 'from' = ['address' = 'example@example.com', 'name' = 'App Name'], In addition, you may define a global \"reply_to\" address within your config/mail.php configuration file: 'reply_to' = ['address' = 'example@example.com', 'name' = 'App Name'], Configuring The View Within a mailable class' build method, you may use the view method to specify which template should be used when rendering the email's contents. Since each email typically uses a Blade template to render its contents, you have the full power and convenience of the Blade templating engine when building your email's HTML: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped'); } You may wish to create a resources/views/emails directory to house all of your email templates; however, you are free to place them wherever you wish within your resources/views directory. Plain Text Emails If you would like to define a plain-text version of your email, you may use the text method. Like the view method, the text method accepts a template name which will be used to render the contents of the email. You are free to define both a HTML and plain-text version of your message: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - text('emails.orders.shipped_plain'); } View Data Via Public Properties Typically, you will want to pass some data to your view that you can utilize when rendering the email's HTML. There are two ways you may make data available to your view. First, any public property defined on your mailable class will automatically be made available to the view. So, for example, you may pass data into your mailable class' constructor and set that data to public properties defined on the class: ?php namespace App\\Mail; use App\\Order; use Illuminate\\Bus\\Queueable; use Illuminate\\Mail\\Mailable; use Illuminate\\Queue\\SerializesModels; class OrderShipped extends Mailable { use Queueable, SerializesModels; /** * The order instance. * * @var Order */ public $order; /** * Create a new message instance. * * @return void */ public function __construct(Order $order) { $this- order = $order; } /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped'); } } Once the data has been set to a public property, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates: div Price: {{ $order- price }} /div Via The with Method: If you would like to customize the format of your email's data before it is sent to the template, you may manually pass your data to the view via the with method. Typically, you will still pass data via the mailable class' constructor; however, you should set this data to protected or private properties so the data is not automatically made available to the template. Then, when calling the with method, pass an array of data that you wish to make available to the template: ?php namespace App\\Mail; use App\\Order; use Illuminate\\Bus\\Queueable; use Illuminate\\Mail\\Mailable; use Illuminate\\Queue\\SerializesModels; class OrderShipped extends Mailable { use Queueable, SerializesModels; /** * The order instance. * * @var Order */ protected $order; /** * Create a new message instance. * * @return void */ public function __construct(Order $order) { $this- order = $order; } /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - with([ 'orderName' = $this- order- name, 'orderPrice' = $this- order- price, ]); } } Once the data has been passed to the with method, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates: div Price: {{ $orderPrice }} /div Attachments To add attachments to an email, use the attach method within the mailable class' build method. The attach method accepts the full path to the file as its first argument: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - attach('/path/to/file'); } When attaching files to a message, you may also specify the display name and / or MIME type by passing an array as the second argument to the attach method: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - attach('/path/to/file', [ 'as' = 'name.pdf', 'mime' = 'application/pdf', ]); } Attaching Files from Disk If you have stored a file on one of your filesystem disks , you may attach it to the email using the attachFromStorage method: /** * Build the message. * * @return $this */ public function build() { return $this- view('email.orders.shipped') - attachFromStorage('/path/to/file'); } If necessary, you may specify the file's attachment name and additional options using the second and third arguments to the attachFromStorage method: /** * Build the message. * * @return $this */ public function build() { return $this- view('email.orders.shipped') - attachFromStorage('/path/to/file', 'name.pdf', [ 'mime' = 'application/pdf' ]); } The attachFromStorageDisk method may be used if you need to specify a storage disk other than your default disk: /** * Build the message. * * @return $this */ public function build() { return $this- view('email.orders.shipped') - attachFromStorageDisk('s3', '/path/to/file'); } Raw Data Attachments The attachData method may be used to attach a raw string of bytes as an attachment. For example, you might use this method if you have generated a PDF in memory and want to attach it to the email without writing it to disk. The attachData method accepts the raw data bytes as its first argument, the name of the file as its second argument, and an array of options as its third argument: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - attachData($this- pdf, 'name.pdf', [ 'mime' = 'application/pdf', ]); } Inline Attachments Embedding inline images into your emails is typically cumbersome; however, Space MVC provides a convenient way to attach images to your emails and retrieving the appropriate CID. To embed an inline image, use the embed method on the $message variable within your email template. Space MVC automatically makes the $message variable available to all of your email templates, so you don't need to worry about passing it in manually: body Here is an image: img src= {{ $message- embed($pathToFile) }} /body $message variable is not available in markdown messages. Embedding Raw Data Attachments If you already have a raw data string you wish to embed into an email template, you may use the embedData method on the $message variable: body Here is an image from raw data: img src= {{ $message- embedData($data, $name) }} /body Customizing The SwiftMailer Message The withSwiftMessage method of the Mailable base class allows you to register a callback which will be invoked with the raw SwiftMailer message instance before sending the message. This gives you an opportunity to customize the message before it is delivered: /** * Build the message. * * @return $this */ public function build() { $this- view('emails.orders.shipped'); $this- withSwiftMessage(function ($message) { $message- getHeaders() - addTextHeader('Custom-Header', 'HeaderValue'); }); } Markdown Mailables Markdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications in your mailables. Since the messages are written in Markdown, Space MVC is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart. Generating Markdown Mailables To generate a mailable with a corresponding Markdown template, you may use the --markdown option of the make:mail Artisan command: php artisan make:mail OrderShipped --markdown=emails.orders.shipped Then, when configuring the mailable within its build method, call the markdown method instead of the view method. The markdown methods accepts the name of the Markdown template and an optional array of data to make available to the template: /** * Build the message. * * @return $this */ public function build() { return $this- from('example@example.com') - markdown('emails.orders.shipped'); } Writing Markdown Messages Markdown mailables use a combination of Blade components and Markdown syntax which allow you to easily construct mail messages while leveraging Space MVC's pre-crafted components: @component('mail::message') # Order Shipped Your order has been shipped! @component('mail::button', ['url' = $url]) View Order @endcomponent Thanks, br {{ config('app.name') }} @endcomponent Do not use excess indentation when writing Markdown emails. Markdown parsers will render indented content as code blocks. Button Component The button component renders a centered button link. The component accepts two arguments, a url and an optional color. Supported colors are primary, success, and error. You may add as many button components to a message as you wish: @component('mail::button', ['url' = $url, 'color' = 'success']) View Order @endcomponent Panel Component The panel component renders the given block of text in a panel that has a slightly different background color than the rest of the message. This allows you to draw attention to a given block of text: @component('mail::panel') This is the panel content. @endcomponent Table Component The table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax: @component('mail::table') | Space MVC | Table | Example | | ------------- |:-------------:| --------:| | Col 2 is | Centered | $10 | | Col 3 is | Right-Aligned | $20 | @endcomponent Customizing The Components You may export all of the Markdown mail components to your own application for customization. To export the components, use the vendor:publish Artisan command to publish the Space MVC-mail asset tag: php artisan vendor:publish --tag=Space MVC-mail This command will publish the Markdown mail components to the resources/views/vendor/mail directory. The mail directory will contain a html and a markdown directory, each containing their respective representations of every available component. The components in the html directory are used to generate the HTML version of your email, and their counterparts in the markdown directory are used to generate the plain-text version. You are free to customize these components however you like. Customizing The CSS After exporting the components, the resources/views/vendor/mail/html/themes directory will contain a default.css file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown mail messages. If you would like to build an entirely new theme for the Markdown components, write a new CSS file within the html/themes directory and change the theme option of your mail configuration file. Sending Mail To send a message, use the to method on the Mail facade . The to method accepts an email address, a user instance, or a collection of users. If you pass an object or collection of objects, the mailer will automatically use their email and name properties when setting the email recipients, so make sure these attributes are available on your objects. Once you have specified your recipients, you may pass an instance of your mailable class to the send method: ?php namespace App\\Http\\Controllers; use App\\Order; use App\\Mail\\OrderShipped; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Mail; use App\\Http\\Controllers\\Controller; class OrderController extends Controller { /** * Ship the given order. * * @param Request $request * @param int $orderId * @return Response */ public function ship(Request $request, $orderId) { $order = Order::findOrFail($orderId); // Ship order... Mail::to($request- user())- send(new OrderShipped($order)); } } Of course, you are not limited to just specifying the \"to\" recipients when sending a message. You are free to set \"to\", \"cc\", and \"bcc\" recipients all within a single, chained method call: Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - send(new OrderShipped($order)); Rendering Mailables Sometimes you may wish to capture the HTML content of a mailable without sending it. To accomplish this, you may call the render method of the mailable. This method will return the evaluated contents of the mailable as a string: $invoice = App\\Invoice::find(1); return (new App\\Mail\\InvoicePaid($invoice))- render(); Previewing Mailables In The Browser When designing a mailable's template, it is convenient to quickly preview the rendered mailable in your browser like a typical Blade template. For this reason, Space MVC allows you to return any mailable directly from a route Closure or controller. When a mailable is returned, it will be rendered and displayed in the browser, allowing you to quickly preview its design without needing to send it to an actual email address: Route::get('/mailable', function () { $invoice = App\\Invoice::find(1); return new App\\Mail\\InvoicePaid($invoice); }); Queueing Mail Queueing A Mail Message Since sending email messages can drastically lengthen the response time of your application, many developers choose to queue email messages for background sending. Space MVC makes this easy using its built-in unified queue API . To queue a mail message, use the queue method on the Mail facade after specifying the message's recipients: Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - queue(new OrderShipped($order)); This method will automatically take care of pushing a job onto the queue so the message is sent in the background. Of course, you will need to configure your queues before using this feature. Delayed Message Queueing If you wish to delay the delivery of a queued email message, you may use the later method. As its first argument, the later method accepts a DateTime instance indicating when the message should be sent: $when = now()- addMinutes(10); Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - later($when, new OrderShipped($order)); Pushing To Specific Queues Since all mailable classes generated using the make:mail command make use of the Illuminate\\Bus\\Queueable trait, you may call the onQueue and onConnection methods on any mailable class instance, allowing you to specify the connection and queue name for the message: $message = (new OrderShipped($order)) - onConnection('sqs') - onQueue('emails'); Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - queue($message); Queueing By Default If you have mailable classes that you want to always be queued, you may implement the ShouldQueue contract on the class. Now, even if you call the send method when mailing, the mailable will still be queued since it implements the contract: use Illuminate\\Contracts\\Queue\\ShouldQueue; class OrderShipped extends Mailable implements ShouldQueue { // } Localizing Mailables Space MVC allows you to send mailables in a locale other than the current language, and will even remember this locale if the mail is queued. To accomplish this, the Illuminate\\Mail\\Mailable class offers a locale method to set the desired language. The application will change into this locale when the mailable is being formatted and then revert back to the previous locale when formatting is complete: Mail::to($request- user())- send( (new OrderShipped($order))- locale('es') ); User Preferred Locales Sometimes, applications store each user's preferred locale. By implementing the HasLocalePreference contract on one or more of your models, you may instruct Space MVC to use this stored locale when sending mail: use Illuminate\\Contracts\\Translation\\HasLocalePreference; class User extends Model implements HasLocalePreference { /** * Get the user's preferred locale. * * @return string */ public function preferredLocale() { return $this- locale; } } Once you have implemented the interface, Space MVC will automatically use the preferred locale when sending mailables and notifications to the model. Therefore, there is no need to call the locale method when using this interface: Mail::to($request- user())- send(new OrderShipped($order)); Mail Local Development When developing an application that sends email, you probably don't want to actually send emails to live email addresses. Space MVC provides several ways to \"disable\" the actual sending of emails during local development. Log Driver Instead of sending your emails, the log mail driver will write all email messages to your log files for inspection. For more information on configuring your application per environment, check out the configuration documentation . Universal To Another solution provided by Space MVC is to set a universal recipient of all emails sent by the framework. This way, all the emails generated by your application will be sent to a specific address, instead of the address actually specified when sending the message. This can be done via the to option in your config/mail.php configuration file: 'to' = [ 'address' = 'example@example.com', 'name' = 'Example' ], Mailtrap Finally, you may use a service like Mailtrap and the smtp driver to send your email messages to a \"dummy\" mailbox where you may view them in a true email client. This approach has the benefit of allowing you to actually inspect the final emails in Mailtrap's message viewer. Events Space MVC fires two events during the process of sending mail messages. The MessageSending event is fired prior to a message being sent, while the MessageSent event is fired after a message has been sent. Remember, these events are fired when the mail is being sent , not when it is queued. You may register an event listener for this event in your EventServiceProvider: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'Illuminate\\Mail\\Events\\MessageSending' = [ 'App\\Listeners\\LogSendingMessage', ], 'Illuminate\\Mail\\Events\\MessageSent' = [ 'App\\Listeners\\LogSentMessage', ], ];","title":"Mail"},{"location":"mail/#mail","text":"Space MVC provides a clean, simple API over the popular SwiftMailer library with drivers for SMTP, Mailgun, SparkPost, Amazon SES, PHP's mail function, and sendmail, allowing you to quickly get started sending mail through a local or cloud based service of your choice.","title":"Mail"},{"location":"mail/#driver-prerequisites","text":"The API based drivers such as Mailgun and SparkPost are often simpler and faster than SMTP servers. If possible, you should use one of these drivers. All of the API drivers require the Guzzle HTTP library, which may be installed via the Composer package manager: composer require guzzlehttp/guzzle","title":"Driver Prerequisites"},{"location":"mail/#mailgun-driver","text":"To use the Mailgun driver, first install Guzzle, then set the driver option in your config/mail.php configuration file to mailgun. Next, verify that your config/services.php configuration file contains the following options: 'mailgun' = [ 'domain' = 'your-mailgun-domain', 'secret' = 'your-mailgun-key', ], If you are not using the \"US\" Mailgun region , you may define your region's endpoint in the services configuration file: 'mailgun' = [ 'domain' = 'your-mailgun-domain', 'secret' = 'your-mailgun-key', 'endpoint' = 'api.eu.mailgun.net', ],","title":"Mailgun Driver"},{"location":"mail/#sparkpost-driver","text":"To use the SparkPost driver, first install Guzzle, then set the driver option in your config/mail.php configuration file to sparkpost. Next, verify that your config/services.php configuration file contains the following options: 'sparkpost' = [ 'secret' = 'your-sparkpost-key', ], If necessary, you may also configure which API endpoint should be used: 'sparkpost' = [ 'secret' = 'your-sparkpost-key', 'options' = [ 'endpoint' = 'https://api.eu.sparkpost.com/api/v1/transmissions', ], ],","title":"SparkPost Driver"},{"location":"mail/#ses-driver","text":"To use the Amazon SES driver you must first install the Amazon AWS SDK for PHP. You may install this library by adding the following line to your composer.json file's require section and running the composer update command: aws/aws-sdk-php : ~3.0 Next, set the driver option in your config/mail.php configuration file to ses and verify that your config/services.php configuration file contains the following options: 'ses' = [ 'key' = 'your-ses-key', 'secret' = 'your-ses-secret', 'region' = 'ses-region', // e.g. us-east-1 ], If you need to include additional options when executing the SES SendRawEmail request, you may define an options array within your ses configuration: 'ses' = [ 'key' = 'your-ses-key', 'secret' = 'your-ses-secret', 'region' = 'ses-region', // e.g. us-east-1 'options' = [ 'ConfigurationSetName' = 'MyConfigurationSet', 'Tags' = [ [ 'Name' = 'foo', 'Value' = 'bar', ], ], ], ],","title":"SES Driver"},{"location":"mail/#generating-mailables","text":"In Space MVC, each type of email sent by your application is represented as a \"mailable\" class. These classes are stored in the app/Mail directory. Don't worry if you don't see this directory in your application, since it will be generated for you when you create your first mailable class using the make:mail command: php artisan make:mail OrderShipped","title":"Generating Mailables"},{"location":"mail/#writing-mailables","text":"All of a mailable class' configuration is done in the build method. Within this method, you may call various methods such as from, subject, view, and attach to configure the email's presentation and delivery.","title":"Writing Mailables"},{"location":"mail/#configuring-the-sender","text":"","title":"Configuring The Sender"},{"location":"mail/#using-the-from-method","text":"First, let's explore configuring the sender of the email. Or, in other words, who the email is going to be \"from\". There are two ways to configure the sender. First, you may use the from method within your mailable class' build method: /** * Build the message. * * @return $this */ public function build() { return $this- from('example@example.com') - view('emails.orders.shipped'); }","title":"Using The from Method"},{"location":"mail/#using-a-global-from-address","text":"However, if your application uses the same \"from\" address for all of its emails, it can become cumbersome to call the from method in each mailable class you generate. Instead, you may specify a global \"from\" address in your config/mail.php configuration file. This address will be used if no other \"from\" address is specified within the mailable class: 'from' = ['address' = 'example@example.com', 'name' = 'App Name'], In addition, you may define a global \"reply_to\" address within your config/mail.php configuration file: 'reply_to' = ['address' = 'example@example.com', 'name' = 'App Name'],","title":"Using A Global from Address"},{"location":"mail/#configuring-the-view","text":"Within a mailable class' build method, you may use the view method to specify which template should be used when rendering the email's contents. Since each email typically uses a Blade template to render its contents, you have the full power and convenience of the Blade templating engine when building your email's HTML: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped'); } You may wish to create a resources/views/emails directory to house all of your email templates; however, you are free to place them wherever you wish within your resources/views directory.","title":"Configuring The View"},{"location":"mail/#plain-text-emails","text":"If you would like to define a plain-text version of your email, you may use the text method. Like the view method, the text method accepts a template name which will be used to render the contents of the email. You are free to define both a HTML and plain-text version of your message: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - text('emails.orders.shipped_plain'); }","title":"Plain Text Emails"},{"location":"mail/#view-data","text":"","title":"View Data"},{"location":"mail/#via-public-properties","text":"Typically, you will want to pass some data to your view that you can utilize when rendering the email's HTML. There are two ways you may make data available to your view. First, any public property defined on your mailable class will automatically be made available to the view. So, for example, you may pass data into your mailable class' constructor and set that data to public properties defined on the class: ?php namespace App\\Mail; use App\\Order; use Illuminate\\Bus\\Queueable; use Illuminate\\Mail\\Mailable; use Illuminate\\Queue\\SerializesModels; class OrderShipped extends Mailable { use Queueable, SerializesModels; /** * The order instance. * * @var Order */ public $order; /** * Create a new message instance. * * @return void */ public function __construct(Order $order) { $this- order = $order; } /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped'); } } Once the data has been set to a public property, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates: div Price: {{ $order- price }} /div","title":"Via Public Properties"},{"location":"mail/#via-the-with-method","text":"If you would like to customize the format of your email's data before it is sent to the template, you may manually pass your data to the view via the with method. Typically, you will still pass data via the mailable class' constructor; however, you should set this data to protected or private properties so the data is not automatically made available to the template. Then, when calling the with method, pass an array of data that you wish to make available to the template: ?php namespace App\\Mail; use App\\Order; use Illuminate\\Bus\\Queueable; use Illuminate\\Mail\\Mailable; use Illuminate\\Queue\\SerializesModels; class OrderShipped extends Mailable { use Queueable, SerializesModels; /** * The order instance. * * @var Order */ protected $order; /** * Create a new message instance. * * @return void */ public function __construct(Order $order) { $this- order = $order; } /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - with([ 'orderName' = $this- order- name, 'orderPrice' = $this- order- price, ]); } } Once the data has been passed to the with method, it will automatically be available in your view, so you may access it like you would access any other data in your Blade templates: div Price: {{ $orderPrice }} /div","title":"Via The with Method:"},{"location":"mail/#attachments","text":"To add attachments to an email, use the attach method within the mailable class' build method. The attach method accepts the full path to the file as its first argument: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - attach('/path/to/file'); } When attaching files to a message, you may also specify the display name and / or MIME type by passing an array as the second argument to the attach method: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - attach('/path/to/file', [ 'as' = 'name.pdf', 'mime' = 'application/pdf', ]); }","title":"Attachments"},{"location":"mail/#attaching-files-from-disk","text":"If you have stored a file on one of your filesystem disks , you may attach it to the email using the attachFromStorage method: /** * Build the message. * * @return $this */ public function build() { return $this- view('email.orders.shipped') - attachFromStorage('/path/to/file'); } If necessary, you may specify the file's attachment name and additional options using the second and third arguments to the attachFromStorage method: /** * Build the message. * * @return $this */ public function build() { return $this- view('email.orders.shipped') - attachFromStorage('/path/to/file', 'name.pdf', [ 'mime' = 'application/pdf' ]); } The attachFromStorageDisk method may be used if you need to specify a storage disk other than your default disk: /** * Build the message. * * @return $this */ public function build() { return $this- view('email.orders.shipped') - attachFromStorageDisk('s3', '/path/to/file'); }","title":"Attaching Files from Disk"},{"location":"mail/#raw-data-attachments","text":"The attachData method may be used to attach a raw string of bytes as an attachment. For example, you might use this method if you have generated a PDF in memory and want to attach it to the email without writing it to disk. The attachData method accepts the raw data bytes as its first argument, the name of the file as its second argument, and an array of options as its third argument: /** * Build the message. * * @return $this */ public function build() { return $this- view('emails.orders.shipped') - attachData($this- pdf, 'name.pdf', [ 'mime' = 'application/pdf', ]); }","title":"Raw Data Attachments"},{"location":"mail/#inline-attachments","text":"Embedding inline images into your emails is typically cumbersome; however, Space MVC provides a convenient way to attach images to your emails and retrieving the appropriate CID. To embed an inline image, use the embed method on the $message variable within your email template. Space MVC automatically makes the $message variable available to all of your email templates, so you don't need to worry about passing it in manually: body Here is an image: img src= {{ $message- embed($pathToFile) }} /body $message variable is not available in markdown messages.","title":"Inline Attachments"},{"location":"mail/#embedding-raw-data-attachments","text":"If you already have a raw data string you wish to embed into an email template, you may use the embedData method on the $message variable: body Here is an image from raw data: img src= {{ $message- embedData($data, $name) }} /body","title":"Embedding Raw Data Attachments"},{"location":"mail/#customizing-the-swiftmailer-message","text":"The withSwiftMessage method of the Mailable base class allows you to register a callback which will be invoked with the raw SwiftMailer message instance before sending the message. This gives you an opportunity to customize the message before it is delivered: /** * Build the message. * * @return $this */ public function build() { $this- view('emails.orders.shipped'); $this- withSwiftMessage(function ($message) { $message- getHeaders() - addTextHeader('Custom-Header', 'HeaderValue'); }); }","title":"Customizing The SwiftMailer Message"},{"location":"mail/#markdown-mailables","text":"Markdown mailable messages allow you to take advantage of the pre-built templates and components of mail notifications in your mailables. Since the messages are written in Markdown, Space MVC is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.","title":"Markdown Mailables"},{"location":"mail/#generating-markdown-mailables","text":"To generate a mailable with a corresponding Markdown template, you may use the --markdown option of the make:mail Artisan command: php artisan make:mail OrderShipped --markdown=emails.orders.shipped Then, when configuring the mailable within its build method, call the markdown method instead of the view method. The markdown methods accepts the name of the Markdown template and an optional array of data to make available to the template: /** * Build the message. * * @return $this */ public function build() { return $this- from('example@example.com') - markdown('emails.orders.shipped'); }","title":"Generating Markdown Mailables"},{"location":"mail/#writing-markdown-messages","text":"Markdown mailables use a combination of Blade components and Markdown syntax which allow you to easily construct mail messages while leveraging Space MVC's pre-crafted components: @component('mail::message') # Order Shipped Your order has been shipped! @component('mail::button', ['url' = $url]) View Order @endcomponent Thanks, br {{ config('app.name') }} @endcomponent Do not use excess indentation when writing Markdown emails. Markdown parsers will render indented content as code blocks.","title":"Writing Markdown Messages"},{"location":"mail/#button-component","text":"The button component renders a centered button link. The component accepts two arguments, a url and an optional color. Supported colors are primary, success, and error. You may add as many button components to a message as you wish: @component('mail::button', ['url' = $url, 'color' = 'success']) View Order @endcomponent","title":"Button Component"},{"location":"mail/#panel-component","text":"The panel component renders the given block of text in a panel that has a slightly different background color than the rest of the message. This allows you to draw attention to a given block of text: @component('mail::panel') This is the panel content. @endcomponent","title":"Panel Component"},{"location":"mail/#table-component","text":"The table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax: @component('mail::table') | Space MVC | Table | Example | | ------------- |:-------------:| --------:| | Col 2 is | Centered | $10 | | Col 3 is | Right-Aligned | $20 | @endcomponent","title":"Table Component"},{"location":"mail/#customizing-the-components","text":"You may export all of the Markdown mail components to your own application for customization. To export the components, use the vendor:publish Artisan command to publish the Space MVC-mail asset tag: php artisan vendor:publish --tag=Space MVC-mail This command will publish the Markdown mail components to the resources/views/vendor/mail directory. The mail directory will contain a html and a markdown directory, each containing their respective representations of every available component. The components in the html directory are used to generate the HTML version of your email, and their counterparts in the markdown directory are used to generate the plain-text version. You are free to customize these components however you like.","title":"Customizing The Components"},{"location":"mail/#customizing-the-css","text":"After exporting the components, the resources/views/vendor/mail/html/themes directory will contain a default.css file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown mail messages. If you would like to build an entirely new theme for the Markdown components, write a new CSS file within the html/themes directory and change the theme option of your mail configuration file.","title":"Customizing The CSS"},{"location":"mail/#sending-mail","text":"To send a message, use the to method on the Mail facade . The to method accepts an email address, a user instance, or a collection of users. If you pass an object or collection of objects, the mailer will automatically use their email and name properties when setting the email recipients, so make sure these attributes are available on your objects. Once you have specified your recipients, you may pass an instance of your mailable class to the send method: ?php namespace App\\Http\\Controllers; use App\\Order; use App\\Mail\\OrderShipped; use Illuminate\\Http\\Request; use Illuminate\\Support\\Facades\\Mail; use App\\Http\\Controllers\\Controller; class OrderController extends Controller { /** * Ship the given order. * * @param Request $request * @param int $orderId * @return Response */ public function ship(Request $request, $orderId) { $order = Order::findOrFail($orderId); // Ship order... Mail::to($request- user())- send(new OrderShipped($order)); } } Of course, you are not limited to just specifying the \"to\" recipients when sending a message. You are free to set \"to\", \"cc\", and \"bcc\" recipients all within a single, chained method call: Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - send(new OrderShipped($order));","title":"Sending Mail"},{"location":"mail/#rendering-mailables","text":"Sometimes you may wish to capture the HTML content of a mailable without sending it. To accomplish this, you may call the render method of the mailable. This method will return the evaluated contents of the mailable as a string: $invoice = App\\Invoice::find(1); return (new App\\Mail\\InvoicePaid($invoice))- render();","title":"Rendering Mailables"},{"location":"mail/#previewing-mailables-in-the-browser","text":"When designing a mailable's template, it is convenient to quickly preview the rendered mailable in your browser like a typical Blade template. For this reason, Space MVC allows you to return any mailable directly from a route Closure or controller. When a mailable is returned, it will be rendered and displayed in the browser, allowing you to quickly preview its design without needing to send it to an actual email address: Route::get('/mailable', function () { $invoice = App\\Invoice::find(1); return new App\\Mail\\InvoicePaid($invoice); });","title":"Previewing Mailables In The Browser"},{"location":"mail/#queueing-mail","text":"","title":"Queueing Mail"},{"location":"mail/#queueing-a-mail-message","text":"Since sending email messages can drastically lengthen the response time of your application, many developers choose to queue email messages for background sending. Space MVC makes this easy using its built-in unified queue API . To queue a mail message, use the queue method on the Mail facade after specifying the message's recipients: Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - queue(new OrderShipped($order)); This method will automatically take care of pushing a job onto the queue so the message is sent in the background. Of course, you will need to configure your queues before using this feature.","title":"Queueing A Mail Message"},{"location":"mail/#delayed-message-queueing","text":"If you wish to delay the delivery of a queued email message, you may use the later method. As its first argument, the later method accepts a DateTime instance indicating when the message should be sent: $when = now()- addMinutes(10); Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - later($when, new OrderShipped($order));","title":"Delayed Message Queueing"},{"location":"mail/#pushing-to-specific-queues","text":"Since all mailable classes generated using the make:mail command make use of the Illuminate\\Bus\\Queueable trait, you may call the onQueue and onConnection methods on any mailable class instance, allowing you to specify the connection and queue name for the message: $message = (new OrderShipped($order)) - onConnection('sqs') - onQueue('emails'); Mail::to($request- user()) - cc($moreUsers) - bcc($evenMoreUsers) - queue($message);","title":"Pushing To Specific Queues"},{"location":"mail/#queueing-by-default","text":"If you have mailable classes that you want to always be queued, you may implement the ShouldQueue contract on the class. Now, even if you call the send method when mailing, the mailable will still be queued since it implements the contract: use Illuminate\\Contracts\\Queue\\ShouldQueue; class OrderShipped extends Mailable implements ShouldQueue { // }","title":"Queueing By Default"},{"location":"mail/#localizing-mailables","text":"Space MVC allows you to send mailables in a locale other than the current language, and will even remember this locale if the mail is queued. To accomplish this, the Illuminate\\Mail\\Mailable class offers a locale method to set the desired language. The application will change into this locale when the mailable is being formatted and then revert back to the previous locale when formatting is complete: Mail::to($request- user())- send( (new OrderShipped($order))- locale('es') );","title":"Localizing Mailables"},{"location":"mail/#user-preferred-locales","text":"Sometimes, applications store each user's preferred locale. By implementing the HasLocalePreference contract on one or more of your models, you may instruct Space MVC to use this stored locale when sending mail: use Illuminate\\Contracts\\Translation\\HasLocalePreference; class User extends Model implements HasLocalePreference { /** * Get the user's preferred locale. * * @return string */ public function preferredLocale() { return $this- locale; } } Once you have implemented the interface, Space MVC will automatically use the preferred locale when sending mailables and notifications to the model. Therefore, there is no need to call the locale method when using this interface: Mail::to($request- user())- send(new OrderShipped($order));","title":"User Preferred Locales"},{"location":"mail/#mail-local-development","text":"When developing an application that sends email, you probably don't want to actually send emails to live email addresses. Space MVC provides several ways to \"disable\" the actual sending of emails during local development.","title":"Mail &amp; Local Development"},{"location":"mail/#log-driver","text":"Instead of sending your emails, the log mail driver will write all email messages to your log files for inspection. For more information on configuring your application per environment, check out the configuration documentation .","title":"Log Driver"},{"location":"mail/#universal-to","text":"Another solution provided by Space MVC is to set a universal recipient of all emails sent by the framework. This way, all the emails generated by your application will be sent to a specific address, instead of the address actually specified when sending the message. This can be done via the to option in your config/mail.php configuration file: 'to' = [ 'address' = 'example@example.com', 'name' = 'Example' ],","title":"Universal To"},{"location":"mail/#mailtrap","text":"Finally, you may use a service like Mailtrap and the smtp driver to send your email messages to a \"dummy\" mailbox where you may view them in a true email client. This approach has the benefit of allowing you to actually inspect the final emails in Mailtrap's message viewer.","title":"Mailtrap"},{"location":"mail/#events","text":"Space MVC fires two events during the process of sending mail messages. The MessageSending event is fired prior to a message being sent, while the MessageSent event is fired after a message has been sent. Remember, these events are fired when the mail is being sent , not when it is queued. You may register an event listener for this event in your EventServiceProvider: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'Illuminate\\Mail\\Events\\MessageSending' = [ 'App\\Listeners\\LogSendingMessage', ], 'Illuminate\\Mail\\Events\\MessageSent' = [ 'App\\Listeners\\LogSentMessage', ], ];","title":"Events"},{"location":"mailing-list/","text":"Thank you, You have successfully been added to our mailing list! Subscribe to our Mailing List Please Subscribe to our mailing list to receive updates on our frameworks new features as we create them and for lots of video tutorials and documentation to go with it. Email Address Subscribe","title":"Mailing list"},{"location":"middleware/","text":"Middleware ul li a href=\"#introduction\" Introduction /a /li li a href=\"#defining-middleware\" Defining Middleware /a /li li a href=\"#registering-middleware\" Registering Middleware /a ul li a href=\"#global-middleware\" Global Middleware /a /li li a href=\"#assigning-middleware-to-routes\" Assigning Middleware To Routes /a /li li a href=\"#middleware-groups\" Middleware Groups /a /li /ul /li li a href=\"#middleware-parameters\" Middleware Parameters /a /li li a href=\"#terminable-middleware\" Terminable Middleware /a /li /ul Introduction Middleware provide a convenient mechanism for filtering HTTP requests entering your application. For example, Space MVC includes a middleware that verifies the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application. Of course, additional middleware can be written to perform a variety of tasks besides authentication. A CORS middleware might be responsible for adding the proper headers to all responses leaving your application. A logging middleware might log all incoming requests to your application. There are several middleware included in the Space MVC framework, including middleware for authentication and CSRF protection. All of these middleware are located in the app/Http/Middleware directory. Defining Middleware To create a new middleware, use the make:middleware Artisan command: php artisan make:middleware CheckAge This command will place a new CheckAge class within your app/Http/Middleware directory. In this middleware, we will only allow access to the route if the supplied age is greater than 200. Otherwise, we will redirect the users back to the home URI: ?php namespace App\\Http\\Middleware; use Closure; class CheckAge { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request- age = 200) { return redirect('home'); } return $next($request); } } As you can see, if the given age is less than or equal to 200, the middleware will return an HTTP redirect to the client; otherwise, the request will be passed further into the application. To pass the request deeper into the application (allowing the middleware to \"pass\"), call the $next callback with the $request. It's best to envision middleware as a series of \"layers\" HTTP requests must pass through before they hit your application. Each layer can examine the request and even reject it entirely. All middleware are resolved via the service container , so you may type-hint any dependencies you need within a middleware's constructor. Before After Middleware Whether a middleware runs before or after a request depends on the middleware itself. For example, the following middleware would perform some task before the request is handled by the application: ?php namespace App\\Http\\Middleware; use Closure; class BeforeMiddleware { public function handle($request, Closure $next) { // Perform action return $next($request); } } However, this middleware would perform its task after the request is handled by the application: ?php namespace App\\Http\\Middleware; use Closure; class AfterMiddleware { public function handle($request, Closure $next) { $response = $next($request); // Perform action return $response; } } Registering Middleware Global Middleware If you want a middleware to run during every HTTP request to your application, list the middleware class in the $middleware property of your app/Http/Kernel.php class. Assigning Middleware To Routes If you would like to assign middleware to specific routes, you should first assign the middleware a key in your app/Http/Kernel.php file. By default, the $routeMiddleware property of this class contains entries for the middleware included with Space MVC. To add your own, append it to this list and assign it a key of your choosing: // Within App\\Http\\Kernel Class... protected $routeMiddleware = [ 'auth' = \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' = \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' = \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' = \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' = \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' = \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' = \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' = \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' = \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class, ]; Once the middleware has been defined in the HTTP kernel, you may use the middleware method to assign middleware to a route: Route::get('admin/profile', function () { // })- middleware('auth'); You may also assign multiple middleware to the route: Route::get('/', function () { // })- middleware('first', 'second'); When assigning middleware, you may also pass the fully qualified class name: use App\\Http\\Middleware\\CheckAge; Route::get('admin/profile', function () { // })- middleware(CheckAge::class); Middleware Groups Sometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may do this using the $middlewareGroups property of your HTTP kernel. Out of the box, Space MVC comes with web and api middleware groups that contain common middleware you may want to apply to your web UI and API routes: /** * The application's route middleware groups. * * @var array */ protected $middlewareGroups = [ 'web' = [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], 'api' = [ 'throttle:60,1', 'auth:api', ], ]; Middleware groups may be assigned to routes and controller actions using the same syntax as individual middleware. Again, middleware groups make it more convenient to assign many middleware to a route at once: Route::get('/', function () { // })- middleware('web'); Route::group(['middleware' = ['web']], function () { // }); Out of the box, the web middleware group is automatically applied to your routes/web.php file by the RouteServiceProvider. Middleware Parameters Middleware can also receive additional parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a CheckRole middleware that receives a role name as an additional argument. Additional middleware parameters will be passed to the middleware after the $next argument: ?php namespace App\\Http\\Middleware; use Closure; class CheckRole { /** * Handle the incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) { if (! $request- user()- hasRole($role)) { // Redirect... } return $next($request); } } Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas: Route::put('post/{id}', function ($id) { // })- middleware('role:editor'); Terminable Middleware Sometimes a middleware may need to do some work after the HTTP response has been prepared. For example, the \"session\" middleware included with Space MVC writes the session data to storage after the response has been fully prepared. If you define a terminate method on your middleware, it will automatically be called after the response is ready to be sent to the browser. ?php namespace Illuminate\\Session\\Middleware; use Closure; class StartSession { public function handle($request, Closure $next) { return $next($request); } public function terminate($request, $response) { // Store the session data... } } The terminate method should receive both the request and the response. Once you have defined a terminable middleware, you should add it to the list of route or global middleware in the app/Http/Kernel.php file. When calling the terminate method on your middleware, Space MVC will resolve a fresh instance of the middleware from the service container . If you would like to use the same middleware instance when the handle and terminate methods are called, register the middleware with the container using the container's singleton method.","title":"Middleware"},{"location":"middleware/#middleware","text":"ul li a href=\"#introduction\" Introduction /a /li li a href=\"#defining-middleware\" Defining Middleware /a /li li a href=\"#registering-middleware\" Registering Middleware /a ul li a href=\"#global-middleware\" Global Middleware /a /li li a href=\"#assigning-middleware-to-routes\" Assigning Middleware To Routes /a /li li a href=\"#middleware-groups\" Middleware Groups /a /li /ul /li li a href=\"#middleware-parameters\" Middleware Parameters /a /li li a href=\"#terminable-middleware\" Terminable Middleware /a /li /ul","title":"Middleware"},{"location":"middleware/#introduction","text":"Middleware provide a convenient mechanism for filtering HTTP requests entering your application. For example, Space MVC includes a middleware that verifies the user of your application is authenticated. If the user is not authenticated, the middleware will redirect the user to the login screen. However, if the user is authenticated, the middleware will allow the request to proceed further into the application. Of course, additional middleware can be written to perform a variety of tasks besides authentication. A CORS middleware might be responsible for adding the proper headers to all responses leaving your application. A logging middleware might log all incoming requests to your application. There are several middleware included in the Space MVC framework, including middleware for authentication and CSRF protection. All of these middleware are located in the app/Http/Middleware directory.","title":"Introduction"},{"location":"middleware/#defining-middleware","text":"To create a new middleware, use the make:middleware Artisan command: php artisan make:middleware CheckAge This command will place a new CheckAge class within your app/Http/Middleware directory. In this middleware, we will only allow access to the route if the supplied age is greater than 200. Otherwise, we will redirect the users back to the home URI: ?php namespace App\\Http\\Middleware; use Closure; class CheckAge { /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request- age = 200) { return redirect('home'); } return $next($request); } } As you can see, if the given age is less than or equal to 200, the middleware will return an HTTP redirect to the client; otherwise, the request will be passed further into the application. To pass the request deeper into the application (allowing the middleware to \"pass\"), call the $next callback with the $request. It's best to envision middleware as a series of \"layers\" HTTP requests must pass through before they hit your application. Each layer can examine the request and even reject it entirely. All middleware are resolved via the service container , so you may type-hint any dependencies you need within a middleware's constructor.","title":"Defining Middleware"},{"location":"middleware/#before-after-middleware","text":"Whether a middleware runs before or after a request depends on the middleware itself. For example, the following middleware would perform some task before the request is handled by the application: ?php namespace App\\Http\\Middleware; use Closure; class BeforeMiddleware { public function handle($request, Closure $next) { // Perform action return $next($request); } } However, this middleware would perform its task after the request is handled by the application: ?php namespace App\\Http\\Middleware; use Closure; class AfterMiddleware { public function handle($request, Closure $next) { $response = $next($request); // Perform action return $response; } }","title":"Before &amp; After Middleware"},{"location":"middleware/#registering-middleware","text":"","title":"Registering Middleware"},{"location":"middleware/#global-middleware","text":"If you want a middleware to run during every HTTP request to your application, list the middleware class in the $middleware property of your app/Http/Kernel.php class.","title":"Global Middleware"},{"location":"middleware/#assigning-middleware-to-routes","text":"If you would like to assign middleware to specific routes, you should first assign the middleware a key in your app/Http/Kernel.php file. By default, the $routeMiddleware property of this class contains entries for the middleware included with Space MVC. To add your own, append it to this list and assign it a key of your choosing: // Within App\\Http\\Kernel Class... protected $routeMiddleware = [ 'auth' = \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' = \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' = \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' = \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' = \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' = \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' = \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' = \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' = \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class, ]; Once the middleware has been defined in the HTTP kernel, you may use the middleware method to assign middleware to a route: Route::get('admin/profile', function () { // })- middleware('auth'); You may also assign multiple middleware to the route: Route::get('/', function () { // })- middleware('first', 'second'); When assigning middleware, you may also pass the fully qualified class name: use App\\Http\\Middleware\\CheckAge; Route::get('admin/profile', function () { // })- middleware(CheckAge::class);","title":"Assigning Middleware To Routes"},{"location":"middleware/#middleware-groups","text":"Sometimes you may want to group several middleware under a single key to make them easier to assign to routes. You may do this using the $middlewareGroups property of your HTTP kernel. Out of the box, Space MVC comes with web and api middleware groups that contain common middleware you may want to apply to your web UI and API routes: /** * The application's route middleware groups. * * @var array */ protected $middlewareGroups = [ 'web' = [ \\App\\Http\\Middleware\\EncryptCookies::class, \\Illuminate\\Cookie\\Middleware\\AddQueuedCookiesToResponse::class, \\Illuminate\\Session\\Middleware\\StartSession::class, \\Illuminate\\View\\Middleware\\ShareErrorsFromSession::class, \\App\\Http\\Middleware\\VerifyCsrfToken::class, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, ], 'api' = [ 'throttle:60,1', 'auth:api', ], ]; Middleware groups may be assigned to routes and controller actions using the same syntax as individual middleware. Again, middleware groups make it more convenient to assign many middleware to a route at once: Route::get('/', function () { // })- middleware('web'); Route::group(['middleware' = ['web']], function () { // }); Out of the box, the web middleware group is automatically applied to your routes/web.php file by the RouteServiceProvider.","title":"Middleware Groups"},{"location":"middleware/#middleware-parameters","text":"Middleware can also receive additional parameters. For example, if your application needs to verify that the authenticated user has a given \"role\" before performing a given action, you could create a CheckRole middleware that receives a role name as an additional argument. Additional middleware parameters will be passed to the middleware after the $next argument: ?php namespace App\\Http\\Middleware; use Closure; class CheckRole { /** * Handle the incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) { if (! $request- user()- hasRole($role)) { // Redirect... } return $next($request); } } Middleware parameters may be specified when defining the route by separating the middleware name and parameters with a :. Multiple parameters should be delimited by commas: Route::put('post/{id}', function ($id) { // })- middleware('role:editor');","title":"Middleware Parameters"},{"location":"middleware/#terminable-middleware","text":"Sometimes a middleware may need to do some work after the HTTP response has been prepared. For example, the \"session\" middleware included with Space MVC writes the session data to storage after the response has been fully prepared. If you define a terminate method on your middleware, it will automatically be called after the response is ready to be sent to the browser. ?php namespace Illuminate\\Session\\Middleware; use Closure; class StartSession { public function handle($request, Closure $next) { return $next($request); } public function terminate($request, $response) { // Store the session data... } } The terminate method should receive both the request and the response. Once you have defined a terminable middleware, you should add it to the list of route or global middleware in the app/Http/Kernel.php file. When calling the terminate method on your middleware, Space MVC will resolve a fresh instance of the middleware from the service container . If you would like to use the same middleware instance when the handle and terminate methods are called, register the middleware with the container using the container's singleton method.","title":"Terminable Middleware"},{"location":"notifications/","text":"Notifications ul li a href=\"#introduction\" Introduction /a /li li a href=\"#creating-notifications\" Creating Notifications /a /li li a href=\"#sending-notifications\" Sending Notifications /a ul li a href=\"#using-the-notifiable-trait\" Using The Notifiable Trait /a /li li a href=\"#using-the-notification-facade\" Using The Notification Facade /a /li li a href=\"#specifying-delivery-channels\" Specifying Delivery Channels /a /li li a href=\"#queueing-notifications\" Queueing Notifications /a /li li a href=\"#on-demand-notifications\" On-Demand Notifications /a /li /ul /li li a href=\"#mail-notifications\" Mail Notifications /a ul li a href=\"#formatting-mail-messages\" Formatting Mail Messages /a /li li a href=\"#customizing-the-recipient\" Customizing The Recipient /a /li li a href=\"#customizing-the-subject\" Customizing The Subject /a /li li a href=\"#customizing-the-templates\" Customizing The Templates /a /li /ul /li li a href=\"#markdown-mail-notifications\" Markdown Mail Notifications /a ul li a href=\"#generating-the-message\" Generating The Message /a /li li a href=\"#writing-the-message\" Writing The Message /a /li li a href=\"#customizing-the-components\" Customizing The Components /a /li /ul /li li a href=\"#database-notifications\" Database Notifications /a ul li a href=\"#database-prerequisites\" Prerequisites /a /li li a href=\"#formatting-database-notifications\" Formatting Database Notifications /a /li li a href=\"#accessing-the-notifications\" Accessing The Notifications /a /li li a href=\"#marking-notifications-as-read\" Marking Notifications As Read /a /li /ul /li li a href=\"#broadcast-notifications\" Broadcast Notifications /a ul li a href=\"#broadcast-prerequisites\" Prerequisites /a /li li a href=\"#formatting-broadcast-notifications\" Formatting Broadcast Notifications /a /li li a href=\"#listening-for-notifications\" Listening For Notifications /a /li /ul /li li a href=\"#sms-notifications\" SMS Notifications /a ul li a href=\"#sms-prerequisites\" Prerequisites /a /li li a href=\"#formatting-sms-notifications\" Formatting SMS Notifications /a /li li a href=\"#customizing-the-from-number\" Customizing The \"From\" Number /a /li li a href=\"#routing-sms-notifications\" Routing SMS Notifications /a /li /ul /li li a href=\"#slack-notifications\" Slack Notifications /a ul li a href=\"#slack-prerequisites\" Prerequisites /a /li li a href=\"#formatting-slack-notifications\" Formatting Slack Notifications /a /li li a href=\"#slack-attachments\" Slack Attachments /a /li li a href=\"#routing-slack-notifications\" Routing Slack Notifications /a /li /ul /li li a href=\"#localizing-notifications\" Localizing Notifications /a /li li a href=\"#notification-events\" Notification Events /a /li li a href=\"#custom-channels\" Custom Channels /a /li /ul Introduction In addition to support for sending email , Space MVC provides support for sending notifications across a variety of delivery channels, including mail, SMS (via Nexmo ), and Slack . Notifications may also be stored in a database so they may be displayed in your web interface. Typically, notifications should be short, informational messages that notify users of something that occurred in your application. For example, if you are writing a billing application, you might send an \"Invoice Paid\" notification to your users via the email and SMS channels. Creating Notifications In Space MVC, each notification is represented by a single class (typically stored in the app/Notifications directory). Don't worry if you don't see this directory in your application, it will be created for you when you run the make:notification Artisan command: php artisan make:notification InvoicePaid This command will place a fresh notification class in your app/Notifications directory. Each notification class contains a via method and a variable number of message building methods (such as toMail or toDatabase) that convert the notification to a message optimized for that particular channel. Sending Notifications Using The Notifiable Trait Notifications may be sent in two ways: using the notify method of the Notifiable trait or using the Notification facade . First, let's explore using the trait: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; } This trait is utilized by the default App\\User model and contains one method that may be used to send notifications: notify. The notify method expects to receive a notification instance: use App\\Notifications\\InvoicePaid; $user- notify(new InvoicePaid($invoice)); Remember, you may use the Illuminate\\Notifications\\Notifiable trait on any of your models. You are not limited to only including it on your User model. Using The Notification Facade Alternatively, you may send notifications via the Notification facade . This is useful primarily when you need to send a notification to multiple notifiable entities such as a collection of users. To send notifications using the facade, pass all of the notifiable entities and the notification instance to the send method: Notification::send($users, new InvoicePaid($invoice)); Specifying Delivery Channels Every notification class has a via method that determines on which channels the notification will be delivered. Out of the box, notifications may be sent on the mail, database, broadcast, nexmo, and slack channels. If you would like to use other delivery channels such as Telegram or Pusher, check out the community driven Space MVC Notification Channels website . The via method receives a $notifiable instance, which will be an instance of the class to which the notification is being sent. You may use $notifiable to determine which channels the notification should be delivered on: /** * Get the notification's delivery channels. * * @param mixed $notifiable * @return array */ public function via($notifiable) { return $notifiable- prefers_sms ? ['nexmo'] : ['mail', 'database']; } Queueing Notifications Before queueing notifications you should configure your queue and start a worker . Sending notifications can take time, especially if the channel needs an external API call to deliver the notification. To speed up your application's response time, let your notification be queued by adding the ShouldQueue interface and Queueable trait to your class. The interface and trait are already imported for all notifications generated using make:notification, so you may immediately add them to your notification class: ?php namespace App\\Notifications; use Illuminate\\Bus\\Queueable; use Illuminate\\Notifications\\Notification; use Illuminate\\Contracts\\Queue\\ShouldQueue; class InvoicePaid extends Notification implements ShouldQueue { use Queueable; // ... } Once the ShouldQueue interface has been added to your notification, you may send the notification like normal. Space MVC will detect the ShouldQueue interface on the class and automatically queue the delivery of the notification: $user- notify(new InvoicePaid($invoice)); If you would like to delay the delivery of the notification, you may chain the delay method onto your notification instantiation: $when = now()- addMinutes(10); $user- notify((new InvoicePaid($invoice))- delay($when)); On-Demand Notifications Sometimes you may need to send a notification to someone who is not stored as a \"user\" of your application. Using the Notification::route method, you may specify ad-hoc notification routing information before sending the notification: Notification::route('mail', 'taylor@example.com') - route('nexmo', '5555555555') - notify(new InvoicePaid($invoice)); Mail Notifications Formatting Mail Messages If a notification supports being sent as an email, you should define a toMail method on the notification class. This method will receive a $notifiable entity and should return a Illuminate\\Notifications\\Messages\\MailMessage instance. Mail messages may contain lines of text as well as a \"call to action\". Let's take a look at an example toMail method: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { $url = url('/invoice/'.$this- invoice- id); return (new MailMessage) - greeting('Hello!') - line('One of your invoices has been paid!') - action('View Invoice', $url) - line('Thank you for using our application!'); } Note we are using $this- invoice- id in our toMail method. You may pass any data your notification needs to generate its message into the notification's constructor. In this example, we register a greeting, a line of text, a call to action, and then another line of text. These methods provided by the MailMessage object make it simple and fast to format small transactional emails. The mail channel will then translate the message components into a nice, responsive HTML email template with a plain-text counterpart. Here is an example of an email generated by the mail channel: When sending mail notifications, be sure to set the name value in your config/app.php configuration file. This value will be used in the header and footer of your mail notification messages. Other Notification Formatting Options Instead of defining the \"lines\" of text in the notification class, you may use the view method to specify a custom template that should be used to render the notification email: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { return (new MailMessage)- view( 'emails.name', ['invoice' = $this- invoice] ); } In addition, you may return a mailable object from the toMail method: use App\\Mail\\InvoicePaid as Mailable; /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return Mailable */ public function toMail($notifiable) { return (new Mailable($this- invoice))- to($this- user- email); } Error Messages Some notifications inform users of errors, such as a failed invoice payment. You may indicate that a mail message is regarding an error by calling the error method when building your message. When using the error method on a mail message, the call to action button will be red instead of blue: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Message */ public function toMail($notifiable) { return (new MailMessage) - error() - subject('Notification Subject') - line('...'); } Customizing The Recipient When sending notifications via the mail channel, the notification system will automatically look for an email property on your notifiable entity. You may customize which email address is used to deliver the notification by defining a routeNotificationForMail method on the entity: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * Route notifications for the mail channel. * * @param \\Illuminate\\Notifications\\Notification $notification * @return string */ public function routeNotificationForMail($notification) { return $this- email_address; } } Customizing The Subject By default, the email's subject is the class name of the notification formatted to \"title case\". So, if your notification class is named InvoicePaid, the email's subject will be Invoice Paid. If you would like to specify an explicit subject for the message, you may call the subject method when building your message: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { return (new MailMessage) - subject('Notification Subject') - line('...'); } Customizing The Templates You can modify the HTML and plain-text template used by mail notifications by publishing the notification package's resources. After running this command, the mail notification templates will be located in the resources/views/vendor/notifications directory: php artisan vendor:publish --tag=Space MVC-notifications Markdown Mail Notifications Markdown mail notifications allow you to take advantage of the pre-built templates of mail notifications, while giving you more freedom to write longer, customized messages. Since the messages are written in Markdown, Space MVC is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart. Generating The Message To generate a notification with a corresponding Markdown template, you may use the --markdown option of the make:notification Artisan command: php artisan make:notification InvoicePaid --markdown=mail.invoice.paid Like all other mail notifications, notifications that use Markdown templates should define a toMail method on their notification class. However, instead of using the line and action methods to construct the notification, use the markdown method to specify the name of the Markdown template that should be used: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { $url = url('/invoice/'.$this- invoice- id); return (new MailMessage) - subject('Invoice Paid') - markdown('mail.invoice.paid', ['url' = $url]); } Writing The Message Markdown mail notifications use a combination of Blade components and Markdown syntax which allow you to easily construct notifications while leveraging Space MVC's pre-crafted notification components: @component('mail::message') # Invoice Paid Your invoice has been paid! @component('mail::button', ['url' = $url]) View Invoice @endcomponent Thanks, br {{ config('app.name') }} @endcomponent Button Component The button component renders a centered button link. The component accepts two arguments, a url and an optional color. Supported colors are blue, green, and red. You may add as many button components to a notification as you wish: @component('mail::button', ['url' = $url, 'color' = 'green']) View Invoice @endcomponent Panel Component The panel component renders the given block of text in a panel that has a slightly different background color than the rest of the notification. This allows you to draw attention to a given block of text: @component('mail::panel') This is the panel content. @endcomponent Table Component The table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax: @component('mail::table') | Space MVC | Table | Example | | ------------- |:-------------:| --------:| | Col 2 is | Centered | $10 | | Col 3 is | Right-Aligned | $20 | @endcomponent Customizing The Components You may export all of the Markdown notification components to your own application for customization. To export the components, use the vendor:publish Artisan command to publish the Space MVC-mail asset tag: php artisan vendor:publish --tag=Space MVC-mail This command will publish the Markdown mail components to the resources/views/vendor/mail directory. The mail directory will contain a html and a markdown directory, each containing their respective representations of every available component. You are free to customize these components however you like. Customizing The CSS After exporting the components, the resources/views/vendor/mail/html/themes directory will contain a default.css file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown notifications. If you would like to build an entirely new theme for the Markdown components, write a new CSS file within the html/themes directory and change the theme option of your mail configuration file. Database Notifications Prerequisites The database notification channel stores the notification information in a database table. This table will contain information such as the notification type as well as custom JSON data that describes the notification. You can query the table to display the notifications in your application's user interface. But, before you can do that, you will need to create a database table to hold your notifications. You may use the notifications:table command to generate a migration with the proper table schema: php artisan notifications:table php artisan migrate Formatting Database Notifications If a notification supports being stored in a database table, you should define a toDatabase or toArray method on the notification class. This method will receive a $notifiable entity and should return a plain PHP array. The returned array will be encoded as JSON and stored in the data column of your notifications table. Let's take a look at an example toArray method: /** * Get the array representation of the notification. * * @param mixed $notifiable * @return array */ public function toArray($notifiable) { return [ 'invoice_id' = $this- invoice- id, 'amount' = $this- invoice- amount, ]; } toDatabase Vs. toArray The toArray method is also used by the broadcast channel to determine which data to broadcast to your JavaScript client. If you would like to have two different array representations for the database and broadcast channels, you should define a toDatabase method instead of a toArray method. Accessing The Notifications Once notifications are stored in the database, you need a convenient way to access them from your notifiable entities. The Illuminate\\Notifications\\Notifiable trait, which is included on Space MVC's default App\\User model, includes a notifications Eloquent relationship that returns the notifications for the entity. To fetch notifications, you may access this method like any other Eloquent relationship. By default, notifications will be sorted by the created_at timestamp: $user = App\\User::find(1); foreach ($user- notifications as $notification) { echo $notification- type; } If you want to retrieve only the \"unread\" notifications, you may use the unreadNotifications relationship. Again, these notifications will be sorted by the created_at timestamp: $user = App\\User::find(1); foreach ($user- unreadNotifications as $notification) { echo $notification- type; } To access your notifications from your JavaScript client, you should define a notification controller for your application which returns the notifications for a notifiable entity, such as the current user. You may then make an HTTP request to that controller's URI from your JavaScript client. Marking Notifications As Read Typically, you will want to mark a notification as \"read\" when a user views it. The Illuminate\\Notifications\\Notifiable trait provides a markAsRead method, which updates the read_at column on the notification's database record: $user = App\\User::find(1); foreach ($user- unreadNotifications as $notification) { $notification- markAsRead(); } However, instead of looping through each notification, you may use the markAsRead method directly on a collection of notifications: $user- unreadNotifications- markAsRead(); You may also use a mass-update query to mark all of the notifications as read without retrieving them from the database: $user = App\\User::find(1); $user- unreadNotifications()- update(['read_at' = now()]); Of course, you may delete the notifications to remove them from the table entirely: $user- notifications()- delete(); Broadcast Notifications Prerequisites Before broadcasting notifications, you should configure and be familiar with Space MVC's event broadcasting services. Event broadcasting provides a way to react to server-side fired Space MVC events from your JavaScript client. Formatting Broadcast Notifications The broadcast channel broadcasts notifications using Space MVC's event broadcasting services, allowing your JavaScript client to catch notifications in realtime. If a notification supports broadcasting, you should define a toBroadcast method on the notification class. This method will receive a $notifiable entity and should return a BroadcastMessage instance. The returned data will be encoded as JSON and broadcast to your JavaScript client. Let's take a look at an example toBroadcast method: use Illuminate\\Notifications\\Messages\\BroadcastMessage; /** * Get the broadcastable representation of the notification. * * @param mixed $notifiable * @return BroadcastMessage */ public function toBroadcast($notifiable) { return new BroadcastMessage([ 'invoice_id' = $this- invoice- id, 'amount' = $this- invoice- amount, ]); } Broadcast Queue Configuration All broadcast notifications are queued for broadcasting. If you would like to configure the queue connection or queue name that is used to queue the broadcast operation, you may use the onConnection and onQueue methods of the BroadcastMessage: return (new BroadcastMessage($data)) - onConnection('sqs') - onQueue('broadcasts'); In addition to the data you specify, broadcast notifications will also contain a type field containing the class name of the notification. Listening For Notifications Notifications will broadcast on a private channel formatted using a {notifiable}.{id} convention. So, if you are sending a notification to a App\\User instance with an ID of 1, the notification will be broadcast on the App.User.1 private channel. When using Space MVC Echo , you may easily listen for notifications on a channel using the notification helper method: Echo.private('App.User.' + userId) .notification((notification) = { console.log(notification.type); }); Customizing The Notification Channel If you would like to customize which channels a notifiable entity receives its broadcast notifications on, you may define a receivesBroadcastNotificationsOn method on the notifiable entity: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Broadcasting\\PrivateChannel; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * The channels the user receives notification broadcasts on. * * @return string */ public function receivesBroadcastNotificationsOn() { return 'users.'.$this- id; } } SMS Notifications Prerequisites Sending SMS notifications in Space MVC is powered by Nexmo . Before you can send notifications via Nexmo, you need to install the nexmo/client Composer package and add a few configuration options to your config/services.php configuration file. You may copy the example configuration below to get started: 'nexmo' = [ 'key' = env('NEXMO_KEY'), 'secret' = env('NEXMO_SECRET'), 'sms_from' = '15556666666', ], The sms_from option is the phone number that your SMS messages will be sent from. You should generate a phone number for your application in the Nexmo control panel. Formatting SMS Notifications If a notification supports being sent as an SMS, you should define a toNexmo method on the notification class. This method will receive a $notifiable entity and should return a Illuminate\\Notifications\\Messages\\NexmoMessage instance: /** * Get the Nexmo / SMS representation of the notification. * * @param mixed $notifiable * @return NexmoMessage */ public function toNexmo($notifiable) { return (new NexmoMessage) - content('Your SMS message content'); } Unicode Content If your SMS message will contain unicode characters, you should call the unicode method when constructing the NexmoMessage instance: /** * Get the Nexmo / SMS representation of the notification. * * @param mixed $notifiable * @return NexmoMessage */ public function toNexmo($notifiable) { return (new NexmoMessage) - content('Your unicode message') - unicode(); } Customizing The \"From\" Number If you would like to send some notifications from a phone number that is different from the phone number specified in your config/services.php file, you may use the from method on a NexmoMessage instance: /** * Get the Nexmo / SMS representation of the notification. * * @param mixed $notifiable * @return NexmoMessage */ public function toNexmo($notifiable) { return (new NexmoMessage) - content('Your SMS message content') - from('15554443333'); } Routing SMS Notifications When sending notifications via the nexmo channel, the notification system will automatically look for a phone_number attribute on the notifiable entity. If you would like to customize the phone number the notification is delivered to, define a routeNotificationForNexmo method on the entity: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * Route notifications for the Nexmo channel. * * @param \\Illuminate\\Notifications\\Notification $notification * @return string */ public function routeNotificationForNexmo($notification) { return $this- phone; } } Slack Notifications Prerequisites Before you can send notifications via Slack, you must install the Guzzle HTTP library via Composer: composer require guzzlehttp/guzzle You will also need to configure an \"Incoming Webhook\" integration for your Slack team. This integration will provide you with a URL you may use when routing Slack notifications . Formatting Slack Notifications If a notification supports being sent as a Slack message, you should define a toSlack method on the notification class. This method will receive a $notifiable entity and should return a Illuminate\\Notifications\\Messages\\SlackMessage instance. Slack messages may contain text content as well as an \"attachment\" that formats additional text or an array of fields. Let's take a look at a basic toSlack example: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { return (new SlackMessage) - content('One of your invoices has been paid!'); } In this example we are just sending a single line of text to Slack, which will create a message that looks like the following: Customizing The Sender Recipient You may use the from and to methods to customize the sender and recipient. The from method accepts a username and emoji identifier, while the to method accepts a channel or username: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { return (new SlackMessage) - from('Ghost', ':ghost:') - to('#other') - content('This will be sent to #other'); } You may also use an image as your logo instead of an emoji: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { return (new SlackMessage) - from('Space MVC') - image('https://Space MVC.com/favicon.png') - content('This will display the Space MVC logo next to the message'); } Slack Attachments You may also add \"attachments\" to Slack messages. Attachments provide richer formatting options than simple text messages. In this example, we will send an error notification about an exception that occurred in an application, including a link to view more details about the exception: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { $url = url('/exceptions/'.$this- exception- id); return (new SlackMessage) - error() - content('Whoops! Something went wrong.') - attachment(function ($attachment) use ($url) { $attachment- title('Exception: File Not Found', $url) - content('File [background.jpg] was not found.'); }); } The example above will generate a Slack message that looks like the following: Attachments also allow you to specify an array of data that should be presented to the user. The given data will be presented in a table-style format for easy reading: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { $url = url('/invoices/'.$this- invoice- id); return (new SlackMessage) - success() - content('One of your invoices has been paid!') - attachment(function ($attachment) use ($url) { $attachment- title('Invoice 1322', $url) - fields([ 'Title' = 'Server Expenses', 'Amount' = '$1,234', 'Via' = 'American Express', 'Was Overdue' = ':-1:', ]); }); } The example above will create a Slack message that looks like the following: Markdown Attachment Content If some of your attachment fields contain Markdown, you may use the markdown method to instruct Slack to parse and display the given attachment fields as Markdown formatted text. The values accepted by this method are: pretext, text, and / or fields. For more information about Slack attachment formatting, check out the Slack API documentation : /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { $url = url('/exceptions/'.$this- exception- id); return (new SlackMessage) - error() - content('Whoops! Something went wrong.') - attachment(function ($attachment) use ($url) { $attachment- title('Exception: File Not Found', $url) - content('File [background.jpg] was *not found*.') - markdown(['text']); }); } Routing Slack Notifications To route Slack notifications to the proper location, define a routeNotificationForSlack method on your notifiable entity. This should return the webhook URL to which the notification should be delivered. Webhook URLs may be generated by adding an \"Incoming Webhook\" service to your Slack team: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * Route notifications for the Slack channel. * * @param \\Illuminate\\Notifications\\Notification $notification * @return string */ public function routeNotificationForSlack($notification) { return 'https://hooks.slack.com/services/...'; } } Localizing Notifications Space MVC allows you to send notifications in a locale other than the current language, and will even remember this locale if the notification is queued. To accomplish this, the Illuminate\\Notifications\\Notification class offers a locale method to set the desired language. The application will change into this locale when the notification is being formatted and then revert back to the previous locale when formatting is complete: $user- notify((new InvoicePaid($invoice))- locale('es')); Localization of multiple notifiable entries may also be achieved via the Notification facade: Notification::locale('es')- send($users, new InvoicePaid($invoice)); User Preferred Locales Sometimes, applications store each user's preferred locale. By implementing the HasLocalePreference contract on your notifiable model, you may instruct Space MVC to use this stored locale when sending a notification: use Illuminate\\Contracts\\Translation\\HasLocalePreference; class User extends Model implements HasLocalePreference { /** * Get the user's preferred locale. * * @return string */ public function preferredLocale() { return $this- locale; } } Once you have implemented the interface, Space MVC will automatically use the preferred locale when sending notifications and mailables to the model. Therefore, there is no need to call the locale method when using this interface: $user- notify(new InvoicePaid($invoice)); Notification Events When a notification is sent, the Illuminate\\Notifications\\Events\\NotificationSent event is fired by the notification system. This contains the \"notifiable\" entity and the notification instance itself. You may register listeners for this event in your EventServiceProvider: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'Illuminate\\Notifications\\Events\\NotificationSent' = [ 'App\\Listeners\\LogNotification', ], ]; After registering listeners in your EventServiceProvider, use the event:generate Artisan command to quickly generate listener classes. Within an event listener, you may access the notifiable, notification, and channel properties on the event to learn more about the notification recipient or the notification itself: /** * Handle the event. * * @param NotificationSent $event * @return void */ public function handle(NotificationSent $event) { // $event- channel // $event- notifiable // $event- notification } Custom Channels Space MVC ships with a handful of notification channels, but you may want to write your own drivers to deliver notifications via other channels. Space MVC makes it simple. To get started, define a class that contains a send method. The method should receive two arguments: a $notifiable and a $notification: ?php namespace App\\Channels; use Illuminate\\Notifications\\Notification; class VoiceChannel { /** * Send the given notification. * * @param mixed $notifiable * @param \\Illuminate\\Notifications\\Notification $notification * @return void */ public function send($notifiable, Notification $notification) { $message = $notification- toVoice($notifiable); // Send notification to the $notifiable instance... } } Once your notification channel class has been defined, you may return the class name from the via method of any of your notifications: ?php namespace App\\Notifications; use Illuminate\\Bus\\Queueable; use App\\Channels\\VoiceChannel; use App\\Channels\\Messages\\VoiceMessage; use Illuminate\\Notifications\\Notification; use Illuminate\\Contracts\\Queue\\ShouldQueue; class InvoicePaid extends Notification { use Queueable; /** * Get the notification channels. * * @param mixed $notifiable * @return array|string */ public function via($notifiable) { return [VoiceChannel::class]; } /** * Get the voice representation of the notification. * * @param mixed $notifiable * @return VoiceMessage */ public function toVoice($notifiable) { // ... } }","title":"Notifications"},{"location":"notifications/#notifications","text":"ul li a href=\"#introduction\" Introduction /a /li li a href=\"#creating-notifications\" Creating Notifications /a /li li a href=\"#sending-notifications\" Sending Notifications /a ul li a href=\"#using-the-notifiable-trait\" Using The Notifiable Trait /a /li li a href=\"#using-the-notification-facade\" Using The Notification Facade /a /li li a href=\"#specifying-delivery-channels\" Specifying Delivery Channels /a /li li a href=\"#queueing-notifications\" Queueing Notifications /a /li li a href=\"#on-demand-notifications\" On-Demand Notifications /a /li /ul /li li a href=\"#mail-notifications\" Mail Notifications /a ul li a href=\"#formatting-mail-messages\" Formatting Mail Messages /a /li li a href=\"#customizing-the-recipient\" Customizing The Recipient /a /li li a href=\"#customizing-the-subject\" Customizing The Subject /a /li li a href=\"#customizing-the-templates\" Customizing The Templates /a /li /ul /li li a href=\"#markdown-mail-notifications\" Markdown Mail Notifications /a ul li a href=\"#generating-the-message\" Generating The Message /a /li li a href=\"#writing-the-message\" Writing The Message /a /li li a href=\"#customizing-the-components\" Customizing The Components /a /li /ul /li li a href=\"#database-notifications\" Database Notifications /a ul li a href=\"#database-prerequisites\" Prerequisites /a /li li a href=\"#formatting-database-notifications\" Formatting Database Notifications /a /li li a href=\"#accessing-the-notifications\" Accessing The Notifications /a /li li a href=\"#marking-notifications-as-read\" Marking Notifications As Read /a /li /ul /li li a href=\"#broadcast-notifications\" Broadcast Notifications /a ul li a href=\"#broadcast-prerequisites\" Prerequisites /a /li li a href=\"#formatting-broadcast-notifications\" Formatting Broadcast Notifications /a /li li a href=\"#listening-for-notifications\" Listening For Notifications /a /li /ul /li li a href=\"#sms-notifications\" SMS Notifications /a ul li a href=\"#sms-prerequisites\" Prerequisites /a /li li a href=\"#formatting-sms-notifications\" Formatting SMS Notifications /a /li li a href=\"#customizing-the-from-number\" Customizing The \"From\" Number /a /li li a href=\"#routing-sms-notifications\" Routing SMS Notifications /a /li /ul /li li a href=\"#slack-notifications\" Slack Notifications /a ul li a href=\"#slack-prerequisites\" Prerequisites /a /li li a href=\"#formatting-slack-notifications\" Formatting Slack Notifications /a /li li a href=\"#slack-attachments\" Slack Attachments /a /li li a href=\"#routing-slack-notifications\" Routing Slack Notifications /a /li /ul /li li a href=\"#localizing-notifications\" Localizing Notifications /a /li li a href=\"#notification-events\" Notification Events /a /li li a href=\"#custom-channels\" Custom Channels /a /li /ul","title":"Notifications"},{"location":"notifications/#introduction","text":"In addition to support for sending email , Space MVC provides support for sending notifications across a variety of delivery channels, including mail, SMS (via Nexmo ), and Slack . Notifications may also be stored in a database so they may be displayed in your web interface. Typically, notifications should be short, informational messages that notify users of something that occurred in your application. For example, if you are writing a billing application, you might send an \"Invoice Paid\" notification to your users via the email and SMS channels.","title":"Introduction"},{"location":"notifications/#creating-notifications","text":"In Space MVC, each notification is represented by a single class (typically stored in the app/Notifications directory). Don't worry if you don't see this directory in your application, it will be created for you when you run the make:notification Artisan command: php artisan make:notification InvoicePaid This command will place a fresh notification class in your app/Notifications directory. Each notification class contains a via method and a variable number of message building methods (such as toMail or toDatabase) that convert the notification to a message optimized for that particular channel.","title":"Creating Notifications"},{"location":"notifications/#sending-notifications","text":"","title":"Sending Notifications"},{"location":"notifications/#using-the-notifiable-trait","text":"Notifications may be sent in two ways: using the notify method of the Notifiable trait or using the Notification facade . First, let's explore using the trait: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; } This trait is utilized by the default App\\User model and contains one method that may be used to send notifications: notify. The notify method expects to receive a notification instance: use App\\Notifications\\InvoicePaid; $user- notify(new InvoicePaid($invoice)); Remember, you may use the Illuminate\\Notifications\\Notifiable trait on any of your models. You are not limited to only including it on your User model.","title":"Using The Notifiable Trait"},{"location":"notifications/#using-the-notification-facade","text":"Alternatively, you may send notifications via the Notification facade . This is useful primarily when you need to send a notification to multiple notifiable entities such as a collection of users. To send notifications using the facade, pass all of the notifiable entities and the notification instance to the send method: Notification::send($users, new InvoicePaid($invoice));","title":"Using The Notification Facade"},{"location":"notifications/#specifying-delivery-channels","text":"Every notification class has a via method that determines on which channels the notification will be delivered. Out of the box, notifications may be sent on the mail, database, broadcast, nexmo, and slack channels. If you would like to use other delivery channels such as Telegram or Pusher, check out the community driven Space MVC Notification Channels website . The via method receives a $notifiable instance, which will be an instance of the class to which the notification is being sent. You may use $notifiable to determine which channels the notification should be delivered on: /** * Get the notification's delivery channels. * * @param mixed $notifiable * @return array */ public function via($notifiable) { return $notifiable- prefers_sms ? ['nexmo'] : ['mail', 'database']; }","title":"Specifying Delivery Channels"},{"location":"notifications/#queueing-notifications","text":"Before queueing notifications you should configure your queue and start a worker . Sending notifications can take time, especially if the channel needs an external API call to deliver the notification. To speed up your application's response time, let your notification be queued by adding the ShouldQueue interface and Queueable trait to your class. The interface and trait are already imported for all notifications generated using make:notification, so you may immediately add them to your notification class: ?php namespace App\\Notifications; use Illuminate\\Bus\\Queueable; use Illuminate\\Notifications\\Notification; use Illuminate\\Contracts\\Queue\\ShouldQueue; class InvoicePaid extends Notification implements ShouldQueue { use Queueable; // ... } Once the ShouldQueue interface has been added to your notification, you may send the notification like normal. Space MVC will detect the ShouldQueue interface on the class and automatically queue the delivery of the notification: $user- notify(new InvoicePaid($invoice)); If you would like to delay the delivery of the notification, you may chain the delay method onto your notification instantiation: $when = now()- addMinutes(10); $user- notify((new InvoicePaid($invoice))- delay($when));","title":"Queueing Notifications"},{"location":"notifications/#on-demand-notifications","text":"Sometimes you may need to send a notification to someone who is not stored as a \"user\" of your application. Using the Notification::route method, you may specify ad-hoc notification routing information before sending the notification: Notification::route('mail', 'taylor@example.com') - route('nexmo', '5555555555') - notify(new InvoicePaid($invoice));","title":"On-Demand Notifications"},{"location":"notifications/#mail-notifications","text":"","title":"Mail Notifications"},{"location":"notifications/#formatting-mail-messages","text":"If a notification supports being sent as an email, you should define a toMail method on the notification class. This method will receive a $notifiable entity and should return a Illuminate\\Notifications\\Messages\\MailMessage instance. Mail messages may contain lines of text as well as a \"call to action\". Let's take a look at an example toMail method: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { $url = url('/invoice/'.$this- invoice- id); return (new MailMessage) - greeting('Hello!') - line('One of your invoices has been paid!') - action('View Invoice', $url) - line('Thank you for using our application!'); } Note we are using $this- invoice- id in our toMail method. You may pass any data your notification needs to generate its message into the notification's constructor. In this example, we register a greeting, a line of text, a call to action, and then another line of text. These methods provided by the MailMessage object make it simple and fast to format small transactional emails. The mail channel will then translate the message components into a nice, responsive HTML email template with a plain-text counterpart. Here is an example of an email generated by the mail channel: When sending mail notifications, be sure to set the name value in your config/app.php configuration file. This value will be used in the header and footer of your mail notification messages.","title":"Formatting Mail Messages"},{"location":"notifications/#other-notification-formatting-options","text":"Instead of defining the \"lines\" of text in the notification class, you may use the view method to specify a custom template that should be used to render the notification email: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { return (new MailMessage)- view( 'emails.name', ['invoice' = $this- invoice] ); } In addition, you may return a mailable object from the toMail method: use App\\Mail\\InvoicePaid as Mailable; /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return Mailable */ public function toMail($notifiable) { return (new Mailable($this- invoice))- to($this- user- email); }","title":"Other Notification Formatting Options"},{"location":"notifications/#error-messages","text":"Some notifications inform users of errors, such as a failed invoice payment. You may indicate that a mail message is regarding an error by calling the error method when building your message. When using the error method on a mail message, the call to action button will be red instead of blue: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Message */ public function toMail($notifiable) { return (new MailMessage) - error() - subject('Notification Subject') - line('...'); }","title":"Error Messages"},{"location":"notifications/#customizing-the-recipient","text":"When sending notifications via the mail channel, the notification system will automatically look for an email property on your notifiable entity. You may customize which email address is used to deliver the notification by defining a routeNotificationForMail method on the entity: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * Route notifications for the mail channel. * * @param \\Illuminate\\Notifications\\Notification $notification * @return string */ public function routeNotificationForMail($notification) { return $this- email_address; } }","title":"Customizing The Recipient"},{"location":"notifications/#customizing-the-subject","text":"By default, the email's subject is the class name of the notification formatted to \"title case\". So, if your notification class is named InvoicePaid, the email's subject will be Invoice Paid. If you would like to specify an explicit subject for the message, you may call the subject method when building your message: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { return (new MailMessage) - subject('Notification Subject') - line('...'); }","title":"Customizing The Subject"},{"location":"notifications/#customizing-the-templates","text":"You can modify the HTML and plain-text template used by mail notifications by publishing the notification package's resources. After running this command, the mail notification templates will be located in the resources/views/vendor/notifications directory: php artisan vendor:publish --tag=Space MVC-notifications","title":"Customizing The Templates"},{"location":"notifications/#markdown-mail-notifications","text":"Markdown mail notifications allow you to take advantage of the pre-built templates of mail notifications, while giving you more freedom to write longer, customized messages. Since the messages are written in Markdown, Space MVC is able to render beautiful, responsive HTML templates for the messages while also automatically generating a plain-text counterpart.","title":"Markdown Mail Notifications"},{"location":"notifications/#generating-the-message","text":"To generate a notification with a corresponding Markdown template, you may use the --markdown option of the make:notification Artisan command: php artisan make:notification InvoicePaid --markdown=mail.invoice.paid Like all other mail notifications, notifications that use Markdown templates should define a toMail method on their notification class. However, instead of using the line and action methods to construct the notification, use the markdown method to specify the name of the Markdown template that should be used: /** * Get the mail representation of the notification. * * @param mixed $notifiable * @return \\Illuminate\\Notifications\\Messages\\MailMessage */ public function toMail($notifiable) { $url = url('/invoice/'.$this- invoice- id); return (new MailMessage) - subject('Invoice Paid') - markdown('mail.invoice.paid', ['url' = $url]); }","title":"Generating The Message"},{"location":"notifications/#writing-the-message","text":"Markdown mail notifications use a combination of Blade components and Markdown syntax which allow you to easily construct notifications while leveraging Space MVC's pre-crafted notification components: @component('mail::message') # Invoice Paid Your invoice has been paid! @component('mail::button', ['url' = $url]) View Invoice @endcomponent Thanks, br {{ config('app.name') }} @endcomponent","title":"Writing The Message"},{"location":"notifications/#button-component","text":"The button component renders a centered button link. The component accepts two arguments, a url and an optional color. Supported colors are blue, green, and red. You may add as many button components to a notification as you wish: @component('mail::button', ['url' = $url, 'color' = 'green']) View Invoice @endcomponent","title":"Button Component"},{"location":"notifications/#panel-component","text":"The panel component renders the given block of text in a panel that has a slightly different background color than the rest of the notification. This allows you to draw attention to a given block of text: @component('mail::panel') This is the panel content. @endcomponent","title":"Panel Component"},{"location":"notifications/#table-component","text":"The table component allows you to transform a Markdown table into an HTML table. The component accepts the Markdown table as its content. Table column alignment is supported using the default Markdown table alignment syntax: @component('mail::table') | Space MVC | Table | Example | | ------------- |:-------------:| --------:| | Col 2 is | Centered | $10 | | Col 3 is | Right-Aligned | $20 | @endcomponent","title":"Table Component"},{"location":"notifications/#customizing-the-components","text":"You may export all of the Markdown notification components to your own application for customization. To export the components, use the vendor:publish Artisan command to publish the Space MVC-mail asset tag: php artisan vendor:publish --tag=Space MVC-mail This command will publish the Markdown mail components to the resources/views/vendor/mail directory. The mail directory will contain a html and a markdown directory, each containing their respective representations of every available component. You are free to customize these components however you like.","title":"Customizing The Components"},{"location":"notifications/#customizing-the-css","text":"After exporting the components, the resources/views/vendor/mail/html/themes directory will contain a default.css file. You may customize the CSS in this file and your styles will automatically be in-lined within the HTML representations of your Markdown notifications. If you would like to build an entirely new theme for the Markdown components, write a new CSS file within the html/themes directory and change the theme option of your mail configuration file.","title":"Customizing The CSS"},{"location":"notifications/#database-notifications","text":"","title":"Database Notifications"},{"location":"notifications/#prerequisites","text":"The database notification channel stores the notification information in a database table. This table will contain information such as the notification type as well as custom JSON data that describes the notification. You can query the table to display the notifications in your application's user interface. But, before you can do that, you will need to create a database table to hold your notifications. You may use the notifications:table command to generate a migration with the proper table schema: php artisan notifications:table php artisan migrate","title":"Prerequisites"},{"location":"notifications/#formatting-database-notifications","text":"If a notification supports being stored in a database table, you should define a toDatabase or toArray method on the notification class. This method will receive a $notifiable entity and should return a plain PHP array. The returned array will be encoded as JSON and stored in the data column of your notifications table. Let's take a look at an example toArray method: /** * Get the array representation of the notification. * * @param mixed $notifiable * @return array */ public function toArray($notifiable) { return [ 'invoice_id' = $this- invoice- id, 'amount' = $this- invoice- amount, ]; }","title":"Formatting Database Notifications"},{"location":"notifications/#todatabase-vs-toarray","text":"The toArray method is also used by the broadcast channel to determine which data to broadcast to your JavaScript client. If you would like to have two different array representations for the database and broadcast channels, you should define a toDatabase method instead of a toArray method.","title":"toDatabase Vs. toArray"},{"location":"notifications/#accessing-the-notifications","text":"Once notifications are stored in the database, you need a convenient way to access them from your notifiable entities. The Illuminate\\Notifications\\Notifiable trait, which is included on Space MVC's default App\\User model, includes a notifications Eloquent relationship that returns the notifications for the entity. To fetch notifications, you may access this method like any other Eloquent relationship. By default, notifications will be sorted by the created_at timestamp: $user = App\\User::find(1); foreach ($user- notifications as $notification) { echo $notification- type; } If you want to retrieve only the \"unread\" notifications, you may use the unreadNotifications relationship. Again, these notifications will be sorted by the created_at timestamp: $user = App\\User::find(1); foreach ($user- unreadNotifications as $notification) { echo $notification- type; } To access your notifications from your JavaScript client, you should define a notification controller for your application which returns the notifications for a notifiable entity, such as the current user. You may then make an HTTP request to that controller's URI from your JavaScript client.","title":"Accessing The Notifications"},{"location":"notifications/#marking-notifications-as-read","text":"Typically, you will want to mark a notification as \"read\" when a user views it. The Illuminate\\Notifications\\Notifiable trait provides a markAsRead method, which updates the read_at column on the notification's database record: $user = App\\User::find(1); foreach ($user- unreadNotifications as $notification) { $notification- markAsRead(); } However, instead of looping through each notification, you may use the markAsRead method directly on a collection of notifications: $user- unreadNotifications- markAsRead(); You may also use a mass-update query to mark all of the notifications as read without retrieving them from the database: $user = App\\User::find(1); $user- unreadNotifications()- update(['read_at' = now()]); Of course, you may delete the notifications to remove them from the table entirely: $user- notifications()- delete();","title":"Marking Notifications As Read"},{"location":"notifications/#broadcast-notifications","text":"","title":"Broadcast Notifications"},{"location":"notifications/#prerequisites_1","text":"Before broadcasting notifications, you should configure and be familiar with Space MVC's event broadcasting services. Event broadcasting provides a way to react to server-side fired Space MVC events from your JavaScript client.","title":"Prerequisites"},{"location":"notifications/#formatting-broadcast-notifications","text":"The broadcast channel broadcasts notifications using Space MVC's event broadcasting services, allowing your JavaScript client to catch notifications in realtime. If a notification supports broadcasting, you should define a toBroadcast method on the notification class. This method will receive a $notifiable entity and should return a BroadcastMessage instance. The returned data will be encoded as JSON and broadcast to your JavaScript client. Let's take a look at an example toBroadcast method: use Illuminate\\Notifications\\Messages\\BroadcastMessage; /** * Get the broadcastable representation of the notification. * * @param mixed $notifiable * @return BroadcastMessage */ public function toBroadcast($notifiable) { return new BroadcastMessage([ 'invoice_id' = $this- invoice- id, 'amount' = $this- invoice- amount, ]); }","title":"Formatting Broadcast Notifications"},{"location":"notifications/#broadcast-queue-configuration","text":"All broadcast notifications are queued for broadcasting. If you would like to configure the queue connection or queue name that is used to queue the broadcast operation, you may use the onConnection and onQueue methods of the BroadcastMessage: return (new BroadcastMessage($data)) - onConnection('sqs') - onQueue('broadcasts'); In addition to the data you specify, broadcast notifications will also contain a type field containing the class name of the notification.","title":"Broadcast Queue Configuration"},{"location":"notifications/#listening-for-notifications","text":"Notifications will broadcast on a private channel formatted using a {notifiable}.{id} convention. So, if you are sending a notification to a App\\User instance with an ID of 1, the notification will be broadcast on the App.User.1 private channel. When using Space MVC Echo , you may easily listen for notifications on a channel using the notification helper method: Echo.private('App.User.' + userId) .notification((notification) = { console.log(notification.type); });","title":"Listening For Notifications"},{"location":"notifications/#customizing-the-notification-channel","text":"If you would like to customize which channels a notifiable entity receives its broadcast notifications on, you may define a receivesBroadcastNotificationsOn method on the notifiable entity: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Broadcasting\\PrivateChannel; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * The channels the user receives notification broadcasts on. * * @return string */ public function receivesBroadcastNotificationsOn() { return 'users.'.$this- id; } }","title":"Customizing The Notification Channel"},{"location":"notifications/#sms-notifications","text":"","title":"SMS Notifications"},{"location":"notifications/#prerequisites_2","text":"Sending SMS notifications in Space MVC is powered by Nexmo . Before you can send notifications via Nexmo, you need to install the nexmo/client Composer package and add a few configuration options to your config/services.php configuration file. You may copy the example configuration below to get started: 'nexmo' = [ 'key' = env('NEXMO_KEY'), 'secret' = env('NEXMO_SECRET'), 'sms_from' = '15556666666', ], The sms_from option is the phone number that your SMS messages will be sent from. You should generate a phone number for your application in the Nexmo control panel.","title":"Prerequisites"},{"location":"notifications/#formatting-sms-notifications","text":"If a notification supports being sent as an SMS, you should define a toNexmo method on the notification class. This method will receive a $notifiable entity and should return a Illuminate\\Notifications\\Messages\\NexmoMessage instance: /** * Get the Nexmo / SMS representation of the notification. * * @param mixed $notifiable * @return NexmoMessage */ public function toNexmo($notifiable) { return (new NexmoMessage) - content('Your SMS message content'); }","title":"Formatting SMS Notifications"},{"location":"notifications/#unicode-content","text":"If your SMS message will contain unicode characters, you should call the unicode method when constructing the NexmoMessage instance: /** * Get the Nexmo / SMS representation of the notification. * * @param mixed $notifiable * @return NexmoMessage */ public function toNexmo($notifiable) { return (new NexmoMessage) - content('Your unicode message') - unicode(); }","title":"Unicode Content"},{"location":"notifications/#customizing-the-from-number","text":"If you would like to send some notifications from a phone number that is different from the phone number specified in your config/services.php file, you may use the from method on a NexmoMessage instance: /** * Get the Nexmo / SMS representation of the notification. * * @param mixed $notifiable * @return NexmoMessage */ public function toNexmo($notifiable) { return (new NexmoMessage) - content('Your SMS message content') - from('15554443333'); }","title":"Customizing The \"From\" Number"},{"location":"notifications/#routing-sms-notifications","text":"When sending notifications via the nexmo channel, the notification system will automatically look for a phone_number attribute on the notifiable entity. If you would like to customize the phone number the notification is delivered to, define a routeNotificationForNexmo method on the entity: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * Route notifications for the Nexmo channel. * * @param \\Illuminate\\Notifications\\Notification $notification * @return string */ public function routeNotificationForNexmo($notification) { return $this- phone; } }","title":"Routing SMS Notifications"},{"location":"notifications/#slack-notifications","text":"","title":"Slack Notifications"},{"location":"notifications/#prerequisites_3","text":"Before you can send notifications via Slack, you must install the Guzzle HTTP library via Composer: composer require guzzlehttp/guzzle You will also need to configure an \"Incoming Webhook\" integration for your Slack team. This integration will provide you with a URL you may use when routing Slack notifications .","title":"Prerequisites"},{"location":"notifications/#formatting-slack-notifications","text":"If a notification supports being sent as a Slack message, you should define a toSlack method on the notification class. This method will receive a $notifiable entity and should return a Illuminate\\Notifications\\Messages\\SlackMessage instance. Slack messages may contain text content as well as an \"attachment\" that formats additional text or an array of fields. Let's take a look at a basic toSlack example: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { return (new SlackMessage) - content('One of your invoices has been paid!'); } In this example we are just sending a single line of text to Slack, which will create a message that looks like the following:","title":"Formatting Slack Notifications"},{"location":"notifications/#customizing-the-sender-recipient","text":"You may use the from and to methods to customize the sender and recipient. The from method accepts a username and emoji identifier, while the to method accepts a channel or username: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { return (new SlackMessage) - from('Ghost', ':ghost:') - to('#other') - content('This will be sent to #other'); } You may also use an image as your logo instead of an emoji: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { return (new SlackMessage) - from('Space MVC') - image('https://Space MVC.com/favicon.png') - content('This will display the Space MVC logo next to the message'); }","title":"Customizing The Sender &amp; Recipient"},{"location":"notifications/#slack-attachments","text":"You may also add \"attachments\" to Slack messages. Attachments provide richer formatting options than simple text messages. In this example, we will send an error notification about an exception that occurred in an application, including a link to view more details about the exception: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { $url = url('/exceptions/'.$this- exception- id); return (new SlackMessage) - error() - content('Whoops! Something went wrong.') - attachment(function ($attachment) use ($url) { $attachment- title('Exception: File Not Found', $url) - content('File [background.jpg] was not found.'); }); } The example above will generate a Slack message that looks like the following: Attachments also allow you to specify an array of data that should be presented to the user. The given data will be presented in a table-style format for easy reading: /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { $url = url('/invoices/'.$this- invoice- id); return (new SlackMessage) - success() - content('One of your invoices has been paid!') - attachment(function ($attachment) use ($url) { $attachment- title('Invoice 1322', $url) - fields([ 'Title' = 'Server Expenses', 'Amount' = '$1,234', 'Via' = 'American Express', 'Was Overdue' = ':-1:', ]); }); } The example above will create a Slack message that looks like the following:","title":"Slack Attachments"},{"location":"notifications/#markdown-attachment-content","text":"If some of your attachment fields contain Markdown, you may use the markdown method to instruct Slack to parse and display the given attachment fields as Markdown formatted text. The values accepted by this method are: pretext, text, and / or fields. For more information about Slack attachment formatting, check out the Slack API documentation : /** * Get the Slack representation of the notification. * * @param mixed $notifiable * @return SlackMessage */ public function toSlack($notifiable) { $url = url('/exceptions/'.$this- exception- id); return (new SlackMessage) - error() - content('Whoops! Something went wrong.') - attachment(function ($attachment) use ($url) { $attachment- title('Exception: File Not Found', $url) - content('File [background.jpg] was *not found*.') - markdown(['text']); }); }","title":"Markdown Attachment Content"},{"location":"notifications/#routing-slack-notifications","text":"To route Slack notifications to the proper location, define a routeNotificationForSlack method on your notifiable entity. This should return the webhook URL to which the notification should be delivered. Webhook URLs may be generated by adding an \"Incoming Webhook\" service to your Slack team: ?php namespace App; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use Notifiable; /** * Route notifications for the Slack channel. * * @param \\Illuminate\\Notifications\\Notification $notification * @return string */ public function routeNotificationForSlack($notification) { return 'https://hooks.slack.com/services/...'; } }","title":"Routing Slack Notifications"},{"location":"notifications/#localizing-notifications","text":"Space MVC allows you to send notifications in a locale other than the current language, and will even remember this locale if the notification is queued. To accomplish this, the Illuminate\\Notifications\\Notification class offers a locale method to set the desired language. The application will change into this locale when the notification is being formatted and then revert back to the previous locale when formatting is complete: $user- notify((new InvoicePaid($invoice))- locale('es')); Localization of multiple notifiable entries may also be achieved via the Notification facade: Notification::locale('es')- send($users, new InvoicePaid($invoice));","title":"Localizing Notifications"},{"location":"notifications/#user-preferred-locales","text":"Sometimes, applications store each user's preferred locale. By implementing the HasLocalePreference contract on your notifiable model, you may instruct Space MVC to use this stored locale when sending a notification: use Illuminate\\Contracts\\Translation\\HasLocalePreference; class User extends Model implements HasLocalePreference { /** * Get the user's preferred locale. * * @return string */ public function preferredLocale() { return $this- locale; } } Once you have implemented the interface, Space MVC will automatically use the preferred locale when sending notifications and mailables to the model. Therefore, there is no need to call the locale method when using this interface: $user- notify(new InvoicePaid($invoice));","title":"User Preferred Locales"},{"location":"notifications/#notification-events","text":"When a notification is sent, the Illuminate\\Notifications\\Events\\NotificationSent event is fired by the notification system. This contains the \"notifiable\" entity and the notification instance itself. You may register listeners for this event in your EventServiceProvider: /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'Illuminate\\Notifications\\Events\\NotificationSent' = [ 'App\\Listeners\\LogNotification', ], ]; After registering listeners in your EventServiceProvider, use the event:generate Artisan command to quickly generate listener classes. Within an event listener, you may access the notifiable, notification, and channel properties on the event to learn more about the notification recipient or the notification itself: /** * Handle the event. * * @param NotificationSent $event * @return void */ public function handle(NotificationSent $event) { // $event- channel // $event- notifiable // $event- notification }","title":"Notification Events"},{"location":"notifications/#custom-channels","text":"Space MVC ships with a handful of notification channels, but you may want to write your own drivers to deliver notifications via other channels. Space MVC makes it simple. To get started, define a class that contains a send method. The method should receive two arguments: a $notifiable and a $notification: ?php namespace App\\Channels; use Illuminate\\Notifications\\Notification; class VoiceChannel { /** * Send the given notification. * * @param mixed $notifiable * @param \\Illuminate\\Notifications\\Notification $notification * @return void */ public function send($notifiable, Notification $notification) { $message = $notification- toVoice($notifiable); // Send notification to the $notifiable instance... } } Once your notification channel class has been defined, you may return the class name from the via method of any of your notifications: ?php namespace App\\Notifications; use Illuminate\\Bus\\Queueable; use App\\Channels\\VoiceChannel; use App\\Channels\\Messages\\VoiceMessage; use Illuminate\\Notifications\\Notification; use Illuminate\\Contracts\\Queue\\ShouldQueue; class InvoicePaid extends Notification { use Queueable; /** * Get the notification channels. * * @param mixed $notifiable * @return array|string */ public function via($notifiable) { return [VoiceChannel::class]; } /** * Get the voice representation of the notification. * * @param mixed $notifiable * @return VoiceMessage */ public function toVoice($notifiable) { // ... } }","title":"Custom Channels"},{"location":"requests/","text":"HTTP Requests Accessing The Request To obtain an instance of the current HTTP request via dependency injection, you should type-hint the Illuminate\\Http\\Request class on your controller method. The incoming request instance will automatically be injected by the service container : ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request- input('name'); // } } Dependency Injection Route Parameters If your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so: Route::put('user/{id}', 'UserController@update'); You may still type-hint the Illuminate\\Http\\Request and access your route parameter id by defining your controller method as follows: ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the specified user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } } Accessing The Request Via Route Closures You may also type-hint the Illuminate\\Http\\Request class on a route Closure. The service container will automatically inject the incoming request into the Closure when it is executed: use Illuminate\\Http\\Request; Route::get('/', function (Request $request) { // }); Request Path Method The Illuminate\\Http\\Request instance provides a variety of methods for examining the HTTP request for your application and extends the Symfony\\Component\\HttpFoundation\\Request class. We will discuss a few of the most important methods below. Retrieving The Request Path The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar: $uri = $request- path(); The is method allows you to verify that the incoming request path matches a given pattern. You may use the * character as a wildcard when utilizing this method: if ($request- is('admin/*')) { // } Retrieving The Request URL To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string: // Without Query String... $url = $request- url(); // With Query String... $url = $request- fullUrl(); Retrieving The Request Method The method method will return the HTTP verb for the request. You may use the isMethod method to verify that the HTTP verb matches a given string: $method = $request- method(); if ($request- isMethod('post')) { // } PSR-7 Requests The PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Space MVC request, you will first need to install a few libraries. Space MVC uses the Symfony HTTP Message Bridge component to convert typical Space MVC requests and responses into PSR-7 compatible implementations: composer require symfony/psr-http-message-bridge composer require zendframework/zend-diactoros Once you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route Closure or controller method: use Psr\\Http\\Message\\ServerRequestInterface; Route::get('/', function (ServerRequestInterface $request) { // }); If you return a PSR-7 response instance from a route or controller, it will automatically be converted back to a Space MVC response instance and be displayed by the framework. Input Trimming Normalization By default, Space MVC includes the TrimStrings and ConvertEmptyStringsToNull middleware in your application's global middleware stack. These middleware are listed in the stack by the App\\Http\\Kernel class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to null. This allows you to not have to worry about these normalization concerns in your routes and controllers. If you would like to disable this behavior, you may remove the two middleware from your application's middleware stack by removing them from the $middleware property of your App\\Http\\Kernel class. Retrieving Input Retrieving All Input Data You may also retrieve all of the input data as an array using the all method: $input = $request- all(); Retrieving An Input Value Using a few simple methods, you may access all of the user input from your Illuminate\\Http\\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input: $name = $request- input('name'); You may pass a default value as the second argument to the input method. This value will be returned if the requested input value is not present on the request: $name = $request- input('name', 'Sally'); When working with forms that contain array inputs, use \"dot\" notation to access the arrays: $name = $request- input('products.0.name'); $names = $request- input('products.*.name'); Retrieving Input From The Query String While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string: $name = $request- query('name'); If the requested query string value data is not present, the second argument to this method will be returned: $name = $request- query('name', 'Helen'); You may call the query method without any arguments in order to retrieve all of the query string values as an associative array: $query = $request- query(); Retrieving Input Via Dynamic Properties You may also access user input using dynamic properties on the Illuminate\\Http\\Request instance. For example, if one of your application's forms contains a name field, you may access the value of the field like so: $name = $request- name; When using dynamic properties, Space MVC will first look for the parameter's value in the request payload. If it is not present, Space MVC will search for the field in the route parameters. Retrieving JSON Input Values When sending JSON requests to your application, you may access the JSON data via the input method as long as the Content-Type header of the request is properly set to application/json. You may even use \"dot\" syntax to dig into JSON arrays: $name = $request- input('user.name'); Retrieving A Portion Of The Input Data If you need to retrieve a subset of the input data, you may use the only and except methods. Both of these methods accept a single array or a dynamic list of arguments: $input = $request- only(['username', 'password']); $input = $request- only('username', 'password'); $input = $request- except(['credit_card']); $input = $request- except('credit_card'); The only method returns all of the key / value pairs that you request; however, it will not return key / value pairs that are not present on the request. Determining If An Input Value Is Present You should use the has method to determine if a value is present on the request. The has method returns true if the value is present on the request: if ($request- has('name')) { // } When given an array, the has method will determine if all of the specified values are present: if ($request- has(['name', 'email'])) { // } If you would like to determine if a value is present on the request and is not empty, you may use the filled method: if ($request- filled('name')) { // } Old Input Space MVC allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Space MVC's included validation features , it is unlikely you will need to manually use these methods, as some of Space MVC's built-in validation facilities will call them automatically. Flashing Input To The Session The flash method on the Illuminate\\Http\\Request class will flash the current input to the session so that it is available during the user's next request to the application: $request- flash(); You may also use the flashOnly and flashExcept methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session: $request- flashOnly(['username', 'email']); $request- flashExcept('password'); Flashing Input Then Redirecting Since you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the withInput method: return redirect('form')- withInput(); return redirect('form')- withInput( $request- except('password') ); Retrieving Old Input To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session : $username = $request- old('username'); Space MVC also provides a global old helper. If you are displaying old input within a Blade template , it is more convenient to use the old helper. If no old input exists for the given field, null will be returned: input type= text name= username value= {{ old('username') }} Cookies Retrieving Cookies From Requests All cookies created by the Space MVC framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the cookie method on a Illuminate\\Http\\Request instance: $value = $request- cookie('name'); Alternatively, you may use the Cookie facade to access cookie values: $value = Cookie::get('name'); Attaching Cookies To Responses You may attach a cookie to an outgoing Illuminate\\Http\\Response instance using the cookie method. You should pass the name, value, and number of minutes the cookie should be considered valid to this method: return response('Hello World')- cookie( 'name', 'value', $minutes ); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: return response('Hello World')- cookie( 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly ); Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes); Generating Cookie Instances If you would like to generate a Symfony\\Component\\HttpFoundation\\Cookie instance that can be given to a response instance at a later time, you may use the global cookie helper. This cookie will not be sent back to the client unless it is attached to a response instance: $cookie = cookie('name', 'value', $minutes); return response('Hello World')- cookie($cookie); Files Retrieving Uploaded Files You may access uploaded files from a Illuminate\\Http\\Request instance using the file method or using dynamic properties. The file method returns an instance of the Illuminate\\Http\\UploadedFile class, which extends the PHP SplFileInfo class and provides a variety of methods for interacting with the file: $file = $request- file('photo'); $file = $request- photo; You may determine if a file is present on the request using the hasFile method: if ($request- hasFile('photo')) { // } Validating Successful Uploads In addition to checking if the file is present, you may verify that there were no problems uploading the file via the isValid method: if ($request- file('photo')- isValid()) { // } File Paths Extensions The UploadedFile class also contains methods for accessing the file's fully-qualified path and its extension. The extension method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client: $path = $request- photo- path(); $extension = $request- photo- extension(); Other File Methods There are a variety of other methods available on UploadedFile instances. Check out the API documentation for the class for more information regarding these methods. Storing Uploaded Files To store an uploaded file, you will typically use one of your configured filesystems . The UploadedFile class has a store method which will move an uploaded file to one of your disks, which may be a location on your local filesystem or even a cloud storage location like Amazon S3. The store method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a file name, since a unique ID will automatically be generated to serve as the file name. The store method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root: $path = $request- photo- store('images'); $path = $request- photo- store('images', 's3'); If you do not want a file name to be automatically generated, you may use the storeAs method, which accepts the path, file name, and disk name as its arguments: $path = $request- photo- storeAs('images', 'filename.jpg'); $path = $request- photo- storeAs('images', 'filename.jpg', 's3'); Configuring Trusted Proxies When running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links. To solve this, you may use the App\\Http\\Middleware\\TrustProxies middleware that is included in your Space MVC application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be listed as an array on the $proxies property of this middleware. In addition to configuring the trusted proxies, you may configure the proxy $headers that should be trusted: ?php namespace App\\Http\\Middleware; use Illuminate\\Http\\Request; use Fideloper\\Proxy\\TrustProxies as Middleware; class TrustProxies extends Middleware { /** * The trusted proxies for this application. * * @var array */ protected $proxies = [ '192.168.1.1', '192.168.1.2', ]; /** * The headers that should be used to detect proxies. * * @var string */ protected $headers = Request::HEADER_X_FORWARDED_ALL; } If you are using AWS Elastic Load Balancing, your $headers value should be Request::HEADER_X_FORWARDED_AWS_ELB. For more information on the constants that may be used in the $headers property, check out Symfony's documentation on trusting proxies . Trusting All Proxies If you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use * to trust all proxies: /** * The trusted proxies for this application. * * @var array */ protected $proxies = '*';","title":"Requests"},{"location":"requests/#http-requests","text":"","title":"HTTP Requests"},{"location":"requests/#accessing-the-request","text":"To obtain an instance of the current HTTP request via dependency injection, you should type-hint the Illuminate\\Http\\Request class on your controller method. The incoming request instance will automatically be injected by the service container : ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) { $name = $request- input('name'); // } }","title":"Accessing The Request"},{"location":"requests/#dependency-injection-route-parameters","text":"If your controller method is also expecting input from a route parameter you should list your route parameters after your other dependencies. For example, if your route is defined like so: Route::put('user/{id}', 'UserController@update'); You may still type-hint the Illuminate\\Http\\Request and access your route parameter id by defining your controller method as follows: ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; class UserController extends Controller { /** * Update the specified user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) { // } }","title":"Dependency Injection &amp; Route Parameters"},{"location":"requests/#accessing-the-request-via-route-closures","text":"You may also type-hint the Illuminate\\Http\\Request class on a route Closure. The service container will automatically inject the incoming request into the Closure when it is executed: use Illuminate\\Http\\Request; Route::get('/', function (Request $request) { // });","title":"Accessing The Request Via Route Closures"},{"location":"requests/#request-path-method","text":"The Illuminate\\Http\\Request instance provides a variety of methods for examining the HTTP request for your application and extends the Symfony\\Component\\HttpFoundation\\Request class. We will discuss a few of the most important methods below.","title":"Request Path &amp; Method"},{"location":"requests/#retrieving-the-request-path","text":"The path method returns the request's path information. So, if the incoming request is targeted at http://domain.com/foo/bar, the path method will return foo/bar: $uri = $request- path(); The is method allows you to verify that the incoming request path matches a given pattern. You may use the * character as a wildcard when utilizing this method: if ($request- is('admin/*')) { // }","title":"Retrieving The Request Path"},{"location":"requests/#retrieving-the-request-url","text":"To retrieve the full URL for the incoming request you may use the url or fullUrl methods. The url method will return the URL without the query string, while the fullUrl method includes the query string: // Without Query String... $url = $request- url(); // With Query String... $url = $request- fullUrl();","title":"Retrieving The Request URL"},{"location":"requests/#retrieving-the-request-method","text":"The method method will return the HTTP verb for the request. You may use the isMethod method to verify that the HTTP verb matches a given string: $method = $request- method(); if ($request- isMethod('post')) { // }","title":"Retrieving The Request Method"},{"location":"requests/#psr-7-requests","text":"The PSR-7 standard specifies interfaces for HTTP messages, including requests and responses. If you would like to obtain an instance of a PSR-7 request instead of a Space MVC request, you will first need to install a few libraries. Space MVC uses the Symfony HTTP Message Bridge component to convert typical Space MVC requests and responses into PSR-7 compatible implementations: composer require symfony/psr-http-message-bridge composer require zendframework/zend-diactoros Once you have installed these libraries, you may obtain a PSR-7 request by type-hinting the request interface on your route Closure or controller method: use Psr\\Http\\Message\\ServerRequestInterface; Route::get('/', function (ServerRequestInterface $request) { // }); If you return a PSR-7 response instance from a route or controller, it will automatically be converted back to a Space MVC response instance and be displayed by the framework.","title":"PSR-7 Requests"},{"location":"requests/#input-trimming-normalization","text":"By default, Space MVC includes the TrimStrings and ConvertEmptyStringsToNull middleware in your application's global middleware stack. These middleware are listed in the stack by the App\\Http\\Kernel class. These middleware will automatically trim all incoming string fields on the request, as well as convert any empty string fields to null. This allows you to not have to worry about these normalization concerns in your routes and controllers. If you would like to disable this behavior, you may remove the two middleware from your application's middleware stack by removing them from the $middleware property of your App\\Http\\Kernel class.","title":"Input Trimming &amp; Normalization"},{"location":"requests/#retrieving-input","text":"","title":"Retrieving Input"},{"location":"requests/#retrieving-all-input-data","text":"You may also retrieve all of the input data as an array using the all method: $input = $request- all();","title":"Retrieving All Input Data"},{"location":"requests/#retrieving-an-input-value","text":"Using a few simple methods, you may access all of the user input from your Illuminate\\Http\\Request instance without worrying about which HTTP verb was used for the request. Regardless of the HTTP verb, the input method may be used to retrieve user input: $name = $request- input('name'); You may pass a default value as the second argument to the input method. This value will be returned if the requested input value is not present on the request: $name = $request- input('name', 'Sally'); When working with forms that contain array inputs, use \"dot\" notation to access the arrays: $name = $request- input('products.0.name'); $names = $request- input('products.*.name');","title":"Retrieving An Input Value"},{"location":"requests/#retrieving-input-from-the-query-string","text":"While the input method retrieves values from entire request payload (including the query string), the query method will only retrieve values from the query string: $name = $request- query('name'); If the requested query string value data is not present, the second argument to this method will be returned: $name = $request- query('name', 'Helen'); You may call the query method without any arguments in order to retrieve all of the query string values as an associative array: $query = $request- query();","title":"Retrieving Input From The Query String"},{"location":"requests/#retrieving-input-via-dynamic-properties","text":"You may also access user input using dynamic properties on the Illuminate\\Http\\Request instance. For example, if one of your application's forms contains a name field, you may access the value of the field like so: $name = $request- name; When using dynamic properties, Space MVC will first look for the parameter's value in the request payload. If it is not present, Space MVC will search for the field in the route parameters.","title":"Retrieving Input Via Dynamic Properties"},{"location":"requests/#retrieving-json-input-values","text":"When sending JSON requests to your application, you may access the JSON data via the input method as long as the Content-Type header of the request is properly set to application/json. You may even use \"dot\" syntax to dig into JSON arrays: $name = $request- input('user.name');","title":"Retrieving JSON Input Values"},{"location":"requests/#retrieving-a-portion-of-the-input-data","text":"If you need to retrieve a subset of the input data, you may use the only and except methods. Both of these methods accept a single array or a dynamic list of arguments: $input = $request- only(['username', 'password']); $input = $request- only('username', 'password'); $input = $request- except(['credit_card']); $input = $request- except('credit_card'); The only method returns all of the key / value pairs that you request; however, it will not return key / value pairs that are not present on the request.","title":"Retrieving A Portion Of The Input Data"},{"location":"requests/#determining-if-an-input-value-is-present","text":"You should use the has method to determine if a value is present on the request. The has method returns true if the value is present on the request: if ($request- has('name')) { // } When given an array, the has method will determine if all of the specified values are present: if ($request- has(['name', 'email'])) { // } If you would like to determine if a value is present on the request and is not empty, you may use the filled method: if ($request- filled('name')) { // }","title":"Determining If An Input Value Is Present"},{"location":"requests/#old-input","text":"Space MVC allows you to keep input from one request during the next request. This feature is particularly useful for re-populating forms after detecting validation errors. However, if you are using Space MVC's included validation features , it is unlikely you will need to manually use these methods, as some of Space MVC's built-in validation facilities will call them automatically.","title":"Old Input"},{"location":"requests/#flashing-input-to-the-session","text":"The flash method on the Illuminate\\Http\\Request class will flash the current input to the session so that it is available during the user's next request to the application: $request- flash(); You may also use the flashOnly and flashExcept methods to flash a subset of the request data to the session. These methods are useful for keeping sensitive information such as passwords out of the session: $request- flashOnly(['username', 'email']); $request- flashExcept('password');","title":"Flashing Input To The Session"},{"location":"requests/#flashing-input-then-redirecting","text":"Since you often will want to flash input to the session and then redirect to the previous page, you may easily chain input flashing onto a redirect using the withInput method: return redirect('form')- withInput(); return redirect('form')- withInput( $request- except('password') );","title":"Flashing Input Then Redirecting"},{"location":"requests/#retrieving-old-input","text":"To retrieve flashed input from the previous request, use the old method on the Request instance. The old method will pull the previously flashed input data from the session : $username = $request- old('username'); Space MVC also provides a global old helper. If you are displaying old input within a Blade template , it is more convenient to use the old helper. If no old input exists for the given field, null will be returned: input type= text name= username value= {{ old('username') }}","title":"Retrieving Old Input"},{"location":"requests/#cookies","text":"","title":"Cookies"},{"location":"requests/#retrieving-cookies-from-requests","text":"All cookies created by the Space MVC framework are encrypted and signed with an authentication code, meaning they will be considered invalid if they have been changed by the client. To retrieve a cookie value from the request, use the cookie method on a Illuminate\\Http\\Request instance: $value = $request- cookie('name'); Alternatively, you may use the Cookie facade to access cookie values: $value = Cookie::get('name');","title":"Retrieving Cookies From Requests"},{"location":"requests/#attaching-cookies-to-responses","text":"You may attach a cookie to an outgoing Illuminate\\Http\\Response instance using the cookie method. You should pass the name, value, and number of minutes the cookie should be considered valid to this method: return response('Hello World')- cookie( 'name', 'value', $minutes ); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: return response('Hello World')- cookie( 'name', 'value', $minutes, $path, $domain, $secure, $httpOnly ); Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes);","title":"Attaching Cookies To Responses"},{"location":"requests/#generating-cookie-instances","text":"If you would like to generate a Symfony\\Component\\HttpFoundation\\Cookie instance that can be given to a response instance at a later time, you may use the global cookie helper. This cookie will not be sent back to the client unless it is attached to a response instance: $cookie = cookie('name', 'value', $minutes); return response('Hello World')- cookie($cookie);","title":"Generating Cookie Instances"},{"location":"requests/#files","text":"","title":"Files"},{"location":"requests/#retrieving-uploaded-files","text":"You may access uploaded files from a Illuminate\\Http\\Request instance using the file method or using dynamic properties. The file method returns an instance of the Illuminate\\Http\\UploadedFile class, which extends the PHP SplFileInfo class and provides a variety of methods for interacting with the file: $file = $request- file('photo'); $file = $request- photo; You may determine if a file is present on the request using the hasFile method: if ($request- hasFile('photo')) { // }","title":"Retrieving Uploaded Files"},{"location":"requests/#validating-successful-uploads","text":"In addition to checking if the file is present, you may verify that there were no problems uploading the file via the isValid method: if ($request- file('photo')- isValid()) { // }","title":"Validating Successful Uploads"},{"location":"requests/#file-paths-extensions","text":"The UploadedFile class also contains methods for accessing the file's fully-qualified path and its extension. The extension method will attempt to guess the file's extension based on its contents. This extension may be different from the extension that was supplied by the client: $path = $request- photo- path(); $extension = $request- photo- extension();","title":"File Paths &amp; Extensions"},{"location":"requests/#other-file-methods","text":"There are a variety of other methods available on UploadedFile instances. Check out the API documentation for the class for more information regarding these methods.","title":"Other File Methods"},{"location":"requests/#storing-uploaded-files","text":"To store an uploaded file, you will typically use one of your configured filesystems . The UploadedFile class has a store method which will move an uploaded file to one of your disks, which may be a location on your local filesystem or even a cloud storage location like Amazon S3. The store method accepts the path where the file should be stored relative to the filesystem's configured root directory. This path should not contain a file name, since a unique ID will automatically be generated to serve as the file name. The store method also accepts an optional second argument for the name of the disk that should be used to store the file. The method will return the path of the file relative to the disk's root: $path = $request- photo- store('images'); $path = $request- photo- store('images', 's3'); If you do not want a file name to be automatically generated, you may use the storeAs method, which accepts the path, file name, and disk name as its arguments: $path = $request- photo- storeAs('images', 'filename.jpg'); $path = $request- photo- storeAs('images', 'filename.jpg', 's3');","title":"Storing Uploaded Files"},{"location":"requests/#configuring-trusted-proxies","text":"When running your applications behind a load balancer that terminates TLS / SSL certificates, you may notice your application sometimes does not generate HTTPS links. Typically this is because your application is being forwarded traffic from your load balancer on port 80 and does not know it should generate secure links. To solve this, you may use the App\\Http\\Middleware\\TrustProxies middleware that is included in your Space MVC application, which allows you to quickly customize the load balancers or proxies that should be trusted by your application. Your trusted proxies should be listed as an array on the $proxies property of this middleware. In addition to configuring the trusted proxies, you may configure the proxy $headers that should be trusted: ?php namespace App\\Http\\Middleware; use Illuminate\\Http\\Request; use Fideloper\\Proxy\\TrustProxies as Middleware; class TrustProxies extends Middleware { /** * The trusted proxies for this application. * * @var array */ protected $proxies = [ '192.168.1.1', '192.168.1.2', ]; /** * The headers that should be used to detect proxies. * * @var string */ protected $headers = Request::HEADER_X_FORWARDED_ALL; } If you are using AWS Elastic Load Balancing, your $headers value should be Request::HEADER_X_FORWARDED_AWS_ELB. For more information on the constants that may be used in the $headers property, check out Symfony's documentation on trusting proxies .","title":"Configuring Trusted Proxies"},{"location":"requests/#trusting-all-proxies","text":"If you are using Amazon AWS or another \"cloud\" load balancer provider, you may not know the IP addresses of your actual balancers. In this case, you may use * to trust all proxies: /** * The trusted proxies for this application. * * @var array */ protected $proxies = '*';","title":"Trusting All Proxies"},{"location":"responses/","text":"HTTP Responses Creating Responses Strings Arrays All routes and controllers should return a response to be sent back to the user's browser. Space MVC provides several different ways to return responses. The most basic response is returning a string from a route or controller. The framework will automatically convert the string into a full HTTP response: Route::get('/', function () { return 'Hello World'; }); In addition to returning strings from your routes and controllers, you may also return arrays. The framework will automatically convert the array into a JSON response: Route::get('/', function () { return [1, 2, 3]; }); Did you know you can also return Eloquent collections from your routes or controllers? They will automatically be converted to JSON. Give it a shot! Response Objects Typically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full Illuminate\\Http\\Response instances or views . Returning a full Response instance allows you to customize the response's HTTP status code and headers. A Response instance inherits from the Symfony\\Component\\HttpFoundation\\Response class, which provides a variety of methods for building HTTP responses: Route::get('home', function () { return response('Hello World', 200) - header('Content-Type', 'text/plain'); }); Attaching Headers To Responses Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, you may use the header method to add a series of headers to the response before sending it back to the user: return response($content) - header('Content-Type', $type) - header('X-Header-One', 'Header Value') - header('X-Header-Two', 'Header Value'); Or, you may use the withHeaders method to specify an array of headers to be added to the response: return response($content) - withHeaders([ 'Content-Type' = $type, 'X-Header-One' = 'Header Value', 'X-Header-Two' = 'Header Value', ]); Attaching Cookies To Responses The cookie method on response instances allows you to easily attach cookies to the response. For example, you may use the cookie method to generate a cookie and fluently attach it to the response instance like so: return response($content) - header('Content-Type', $type) - cookie('name', 'value', $minutes); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: - cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly) Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes); Cookies Encryption By default, all cookies generated by Space MVC are encrypted and signed so that they can't be modified or read by the client. If you would like to disable encryption for a subset of cookies generated by your application, you may use the $except property of the App\\Http\\Middleware\\EncryptCookies middleware, which is located in the app/Http/Middleware directory: /** * The names of the cookies that should not be encrypted. * * @var array */ protected $except = [ 'cookie_name', ]; Redirects Redirect responses are instances of the Illuminate\\Http\\RedirectResponse class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a RedirectResponse instance. The simplest method is to use the global redirect helper: Route::get('dashboard', function () { return redirect('home/dashboard'); }); Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global back helper function. Since this feature utilizes the session , make sure the route calling the back function is using the web middleware group or has all of the session middleware applied: Route::post('user/profile', function () { // Validate the request... return back()- withInput(); }); Redirecting To Named Routes When you call the redirect helper with no parameters, an instance of Illuminate\\Routing\\Redirector is returned, allowing you to call any method on the Redirector instance. For example, to generate a RedirectResponse to a named route, you may use the route method: return redirect()- route('login'); If your route has parameters, you may pass them as the second argument to the route method: // For a route with the following URI: profile/{id} return redirect()- route('profile', ['id' = 1]); Populating Parameters Via Eloquent Models If you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may pass the model itself. The ID will be extracted automatically: // For a route with the following URI: profile/{id} return redirect()- route('profile', [$user]); If you would like to customize the value that is placed in the route parameter, you should override the getRouteKey method on your Eloquent model: /** * Get the value of the model's route key. * * @return mixed */ public function getRouteKey() { return $this- slug; } Redirecting To Controller Actions You may also generate redirects to controller actions . To do so, pass the controller and action name to the action method. Remember, you do not need to specify the full namespace to the controller since Space MVC's RouteServiceProvider will automatically set the base controller namespace: return redirect()- action('HomeController@index'); If your controller route requires parameters, you may pass them as the second argument to the action method: return redirect()- action( 'UserController@profile', ['id' = 1] ); Redirecting To External Domains Sometimes you may need to redirect to a domain outside of your application. You may do so by calling the away method, which creates a RedirectResponse without any additional URL encoding, validation, or verification: return redirect()- away('https://www.google.com'); Redirecting With Flashed Session Data Redirecting to a new URL and flashing data to the session are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a RedirectResponse instance and flash data to the session in a single, fluent method chain: Route::post('user/profile', function () { // Update the user's profile... return redirect('dashboard')- with('status', 'Profile updated!'); }); After the user is redirected, you may display the flashed message from the session . For example, using Blade syntax : @if (session('status')) div class= alert alert-success {{ session('status') }} /div @endif Other Response Types The response helper may be used to generate other types of response instances. When the response helper is called without arguments, an implementation of the Illuminate\\Contracts\\Routing\\ResponseFactory contract is returned. This contract provides several helpful methods for generating responses. View Responses If you need control over the response's status and headers but also need to return a view as the response's content, you should use the view method: return response() - view('hello', $data, 200) - header('Content-Type', $type); Of course, if you do not need to pass a custom HTTP status code or custom headers, you should use the global view helper function. JSON Responses The json method will automatically set the Content-Type header to application/json, as well as convert the given array to JSON using the json_encode PHP function: return response()- json([ 'name' = 'Abigail', 'state' = 'CA' ]); If you would like to create a JSONP response, you may use the json method in combination with the withCallback method: return response() - json(['name' = 'Abigail', 'state' = 'CA']) - withCallback($request- input('callback')); File Downloads The download method may be used to generate a response that forces the user's browser to download the file at the given path. The download method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method: return response()- download($pathToFile); return response()- download($pathToFile, $name, $headers); return response()- download($pathToFile)- deleteFileAfterSend(); Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name. Streamed Downloads Sometimes you may wish to turn the string response of a given operation into a downloadable response without having to write the contents of the operation to disk. You may use the streamDownload method in this scenario. This method accepts a callback, file name, and an optional array of headers as its arguments: return response()- streamDownload(function () { echo GitHub::api('repo') - contents() - readme('Space MVC', 'Space MVC')['contents']; }, 'Space MVC-readme.md'); File Responses The file method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second argument: return response()- file($pathToFile); return response()- file($pathToFile, $headers); Response Macros If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method: ?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Response; class ResponseMacroServiceProvider extends ServiceProvider { /** * Register the application's response macros. * * @return void */ public function boot() { Response::macro('caps', function ($value) { return Response::make(strtoupper($value)); }); } } The macro function accepts a name as its first argument, and a Closure as its second. The macro's Closure will be executed when calling the macro name from a ResponseFactory implementation or the response helper: return response()- caps('foo');","title":"Responses"},{"location":"responses/#http-responses","text":"","title":"HTTP Responses"},{"location":"responses/#creating-responses","text":"","title":"Creating Responses"},{"location":"responses/#strings-arrays","text":"All routes and controllers should return a response to be sent back to the user's browser. Space MVC provides several different ways to return responses. The most basic response is returning a string from a route or controller. The framework will automatically convert the string into a full HTTP response: Route::get('/', function () { return 'Hello World'; }); In addition to returning strings from your routes and controllers, you may also return arrays. The framework will automatically convert the array into a JSON response: Route::get('/', function () { return [1, 2, 3]; }); Did you know you can also return Eloquent collections from your routes or controllers? They will automatically be converted to JSON. Give it a shot!","title":"Strings &amp; Arrays"},{"location":"responses/#response-objects","text":"Typically, you won't just be returning simple strings or arrays from your route actions. Instead, you will be returning full Illuminate\\Http\\Response instances or views . Returning a full Response instance allows you to customize the response's HTTP status code and headers. A Response instance inherits from the Symfony\\Component\\HttpFoundation\\Response class, which provides a variety of methods for building HTTP responses: Route::get('home', function () { return response('Hello World', 200) - header('Content-Type', 'text/plain'); });","title":"Response Objects"},{"location":"responses/#attaching-headers-to-responses","text":"Keep in mind that most response methods are chainable, allowing for the fluent construction of response instances. For example, you may use the header method to add a series of headers to the response before sending it back to the user: return response($content) - header('Content-Type', $type) - header('X-Header-One', 'Header Value') - header('X-Header-Two', 'Header Value'); Or, you may use the withHeaders method to specify an array of headers to be added to the response: return response($content) - withHeaders([ 'Content-Type' = $type, 'X-Header-One' = 'Header Value', 'X-Header-Two' = 'Header Value', ]);","title":"Attaching Headers To Responses"},{"location":"responses/#attaching-cookies-to-responses","text":"The cookie method on response instances allows you to easily attach cookies to the response. For example, you may use the cookie method to generate a cookie and fluently attach it to the response instance like so: return response($content) - header('Content-Type', $type) - cookie('name', 'value', $minutes); The cookie method also accepts a few more arguments which are used less frequently. Generally, these arguments have the same purpose and meaning as the arguments that would be given to PHP's native setcookie method: - cookie($name, $value, $minutes, $path, $domain, $secure, $httpOnly) Alternatively, you can use the Cookie facade to \"queue\" cookies for attachment to the outgoing response from your application. The queue method accepts a Cookie instance or the arguments needed to create a Cookie instance. These cookies will be attached to the outgoing response before it is sent to the browser: Cookie::queue(Cookie::make('name', 'value', $minutes)); Cookie::queue('name', 'value', $minutes);","title":"Attaching Cookies To Responses"},{"location":"responses/#cookies-encryption","text":"By default, all cookies generated by Space MVC are encrypted and signed so that they can't be modified or read by the client. If you would like to disable encryption for a subset of cookies generated by your application, you may use the $except property of the App\\Http\\Middleware\\EncryptCookies middleware, which is located in the app/Http/Middleware directory: /** * The names of the cookies that should not be encrypted. * * @var array */ protected $except = [ 'cookie_name', ];","title":"Cookies &amp; Encryption"},{"location":"responses/#redirects","text":"Redirect responses are instances of the Illuminate\\Http\\RedirectResponse class, and contain the proper headers needed to redirect the user to another URL. There are several ways to generate a RedirectResponse instance. The simplest method is to use the global redirect helper: Route::get('dashboard', function () { return redirect('home/dashboard'); }); Sometimes you may wish to redirect the user to their previous location, such as when a submitted form is invalid. You may do so by using the global back helper function. Since this feature utilizes the session , make sure the route calling the back function is using the web middleware group or has all of the session middleware applied: Route::post('user/profile', function () { // Validate the request... return back()- withInput(); });","title":"Redirects"},{"location":"responses/#redirecting-to-named-routes","text":"When you call the redirect helper with no parameters, an instance of Illuminate\\Routing\\Redirector is returned, allowing you to call any method on the Redirector instance. For example, to generate a RedirectResponse to a named route, you may use the route method: return redirect()- route('login'); If your route has parameters, you may pass them as the second argument to the route method: // For a route with the following URI: profile/{id} return redirect()- route('profile', ['id' = 1]);","title":"Redirecting To Named Routes"},{"location":"responses/#populating-parameters-via-eloquent-models","text":"If you are redirecting to a route with an \"ID\" parameter that is being populated from an Eloquent model, you may pass the model itself. The ID will be extracted automatically: // For a route with the following URI: profile/{id} return redirect()- route('profile', [$user]); If you would like to customize the value that is placed in the route parameter, you should override the getRouteKey method on your Eloquent model: /** * Get the value of the model's route key. * * @return mixed */ public function getRouteKey() { return $this- slug; }","title":"Populating Parameters Via Eloquent Models"},{"location":"responses/#redirecting-to-controller-actions","text":"You may also generate redirects to controller actions . To do so, pass the controller and action name to the action method. Remember, you do not need to specify the full namespace to the controller since Space MVC's RouteServiceProvider will automatically set the base controller namespace: return redirect()- action('HomeController@index'); If your controller route requires parameters, you may pass them as the second argument to the action method: return redirect()- action( 'UserController@profile', ['id' = 1] );","title":"Redirecting To Controller Actions"},{"location":"responses/#redirecting-to-external-domains","text":"Sometimes you may need to redirect to a domain outside of your application. You may do so by calling the away method, which creates a RedirectResponse without any additional URL encoding, validation, or verification: return redirect()- away('https://www.google.com');","title":"Redirecting To External Domains"},{"location":"responses/#redirecting-with-flashed-session-data","text":"Redirecting to a new URL and flashing data to the session are usually done at the same time. Typically, this is done after successfully performing an action when you flash a success message to the session. For convenience, you may create a RedirectResponse instance and flash data to the session in a single, fluent method chain: Route::post('user/profile', function () { // Update the user's profile... return redirect('dashboard')- with('status', 'Profile updated!'); }); After the user is redirected, you may display the flashed message from the session . For example, using Blade syntax : @if (session('status')) div class= alert alert-success {{ session('status') }} /div @endif","title":"Redirecting With Flashed Session Data"},{"location":"responses/#other-response-types","text":"The response helper may be used to generate other types of response instances. When the response helper is called without arguments, an implementation of the Illuminate\\Contracts\\Routing\\ResponseFactory contract is returned. This contract provides several helpful methods for generating responses.","title":"Other Response Types"},{"location":"responses/#view-responses","text":"If you need control over the response's status and headers but also need to return a view as the response's content, you should use the view method: return response() - view('hello', $data, 200) - header('Content-Type', $type); Of course, if you do not need to pass a custom HTTP status code or custom headers, you should use the global view helper function.","title":"View Responses"},{"location":"responses/#json-responses","text":"The json method will automatically set the Content-Type header to application/json, as well as convert the given array to JSON using the json_encode PHP function: return response()- json([ 'name' = 'Abigail', 'state' = 'CA' ]); If you would like to create a JSONP response, you may use the json method in combination with the withCallback method: return response() - json(['name' = 'Abigail', 'state' = 'CA']) - withCallback($request- input('callback'));","title":"JSON Responses"},{"location":"responses/#file-downloads","text":"The download method may be used to generate a response that forces the user's browser to download the file at the given path. The download method accepts a file name as the second argument to the method, which will determine the file name that is seen by the user downloading the file. Finally, you may pass an array of HTTP headers as the third argument to the method: return response()- download($pathToFile); return response()- download($pathToFile, $name, $headers); return response()- download($pathToFile)- deleteFileAfterSend(); Symfony HttpFoundation, which manages file downloads, requires the file being downloaded to have an ASCII file name.","title":"File Downloads"},{"location":"responses/#streamed-downloads","text":"Sometimes you may wish to turn the string response of a given operation into a downloadable response without having to write the contents of the operation to disk. You may use the streamDownload method in this scenario. This method accepts a callback, file name, and an optional array of headers as its arguments: return response()- streamDownload(function () { echo GitHub::api('repo') - contents() - readme('Space MVC', 'Space MVC')['contents']; }, 'Space MVC-readme.md');","title":"Streamed Downloads"},{"location":"responses/#file-responses","text":"The file method may be used to display a file, such as an image or PDF, directly in the user's browser instead of initiating a download. This method accepts the path to the file as its first argument and an array of headers as its second argument: return response()- file($pathToFile); return response()- file($pathToFile, $headers);","title":"File Responses"},{"location":"responses/#response-macros","text":"If you would like to define a custom response that you can re-use in a variety of your routes and controllers, you may use the macro method on the Response facade. For example, from a service provider's boot method: ?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Response; class ResponseMacroServiceProvider extends ServiceProvider { /** * Register the application's response macros. * * @return void */ public function boot() { Response::macro('caps', function ($value) { return Response::make(strtoupper($value)); }); } } The macro function accepts a name as its first argument, and a Closure as its second. The macro's Closure will be executed when calling the macro name from a ResponseFactory implementation or the response helper: return response()- caps('foo');","title":"Response Macros"},{"location":"routing/","text":"Routing Basic Routing The most basic Laravel routes accept a URI and a Closure, providing a very simple and expressive method of defining routes: ?php return [ // introduction [ 'uri' = '/docs/introduction/what-is-space', 'controller' = 'Docs\\IntroductionController', 'action' = 'whatIsSpace', ], // getting started [ 'uri' = '/docs/getting-started/installation', 'controller' = 'Docs\\IndexController', 'action' = 'installation', ], Route::get('foo', function () { return 'Hello World'; }); The Default Route Files All Laravel routes are defined in your route files, which are located in the routes directory. These files are automatically loaded by the framework. The routes/web.php file defines routes that are for your web interface. These routes are assigned the web middleware group, which provides features like session state and CSRF protection. The routes in routes/api.php are stateless and are assigned the api middleware group. For most applications, you will begin by defining routes in your routes/web.php file. The routes defined in routes/web.php may be accessed by entering the defined route's URL in your browser. For example, you may access the following route by navigating to http://your-app.test/user in your browser: Route::get('/user', 'UserController@index'); Routes defined in the routes/api.php file are nested within a route group by the RouteServiceProvider. Within this group, the /api URI prefix is automatically applied so you do not need to manually apply it to every route in the file. You may modify the prefix and other route group options by modifying your RouteServiceProvider class. Available Router Methods The router allows you to register routes that respond to any HTTP verb: Route::get($uri, $callback); Route::post($uri, $callback); Route::put($uri, $callback); Route::patch($uri, $callback); Route::delete($uri, $callback); Route::options($uri, $callback); Sometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the match method. Or, you may even register a route that responds to all HTTP verbs using the any method: Route::match(['get', 'post'], '/', function () { // }); Route::any('foo', function () { // }); CSRF Protection Any HTML forms pointing to POST, PUT, or DELETE routes that are defined in the web routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the CSRF documentation : form method= POST action= /profile @csrf ... /form Redirect Routes If you are defining a route that redirects to another URI, you may use the Route::redirect method. This method provides a convenient shortcut so that you do not have to define a full route or controller for performing a simple redirect: Route::redirect('/here', '/there', 301); View Routes If your route only needs to return a view, you may use the Route::view method. Like the redirect method, this method provides a simple shortcut so that you do not have to define a full route or controller. The view method accepts a URI as its first argument and a view name as its second argument. In addition, you may provide an array of data to pass to the view as an optional third argument: Route::view('/welcome', 'welcome'); Route::view('/welcome', 'welcome', ['name' = ; 'Taylor']); Route Parameters Required Parameters Of course, sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters: Route::get('user/{id}', function ($id) { return 'User '.$id; }); You may define as many route parameters as required by your route: Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) { // }); Route parameters are always encased within {} braces and should consist of alphabetic characters, and may not contain a - character. Instead of using the - character, use an underscore (_). Route parameters are injected into route callbacks / controllers based on their order - the names of the callback / controller arguments do not matter. Optional Parameters Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Route::get('user/{name?}', function ($name = null) { return $name; }); Route::get('user/{name?}', function ($name = 'John') { return $name; }); Regular Expression Constraints You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Route::get('user/{name}', function ($name) { // })- ;where('name', '[A-Za-z]+'); Route::get('user/{id}', function ($id) { // })- ;where('id', '[0-9]+'); Route::get('user/{id}/{name}', function ($id, $name) { // })- ;where(['id' = ; '[0-9]+', 'name' = ; '[a-z]+']); Global Constraints If you would like a route parameter to always be constrained by a given regular expression, you may use the pattern method. You should define these patterns in the boot method of your RouteServiceProvider: /** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { Route::pattern('id', '[0-9]+'); parent::boot(); } Once the pattern has been defined, it is automatically applied to all routes using that parameter name: Route::get('user/{id}', function ($id) { // Only executed if {id} is numeric... }); Named Routes Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Route::get('user/profile', function () { // })- ;name('profile'); You may also specify route names for controller actions: Route::get('user/profile', 'UserProfileController@show')- ;name('profile'); Generating URLs To Named Routes Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global route function: // Generating URLs... $url = route('profile'); // Generating Redirects... return redirect()- ;route('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the route function. The given parameters will automatically be inserted into the URL in their correct positions: Route::get('user/{id}/profile', function ($id) { // })- ;name('profile'); $url = route('profile', ['id' = ; 1]); Inspecting The Current Route If you would like to determine if the current request was routed to a given named route, you may use the named method on a Route instance. For example, you may check the current route name from a route middleware: /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request- ;route()- ;named('profile')) { // } return $next($request); } Route Groups Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Route::group method. Middleware To assign middleware to all routes within a group, you may use the middleware method before defining the group. Middleware are executed in the order they are listed in the array: Route::middleware(['first', 'second'])- ;group(function () { Route::get('/', function () { // Uses first amp; second Middleware }); Route::get('user/profile', function () { // Uses first amp; second Middleware }); }); Namespaces Another common use-case for route groups is assigning the same PHP namespace to a group of controllers using the namespace method: Route::namespace('Admin')- ;group(function () { // Controllers Within The App\\Http\\Controllers\\Admin Namespace }); Remember, by default, the RouteServiceProvider includes your route files within a namespace group, allowing you to register controller routes without specifying the full App\\Http\\Controllers namespace prefix. So, you only need to specify the portion of the namespace that comes after the base App\\Http\\Controllers namespace. Sub-Domain Routing Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route URIs, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified by calling the domain method before defining the group: Route::domain('{account}.myapp.com')- ;group(function () { Route::get('user/{id}', function ($account, $id) { // }); }); Route Prefixes The prefix method may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with admin: Route::prefix('admin')- ;group(function () { Route::get('users', function () { // Matches The /admin/users URL }); }); Route Name Prefixes The name method may be used to prefix each route name in the group with a given string. For example, you may want to prefix all of the grouped route's names with admin. The given string is prefixed to the route name exactly as it is specified, so we will be sure to provide the trailing . character in the prefix: Route::name('admin.')- ;group(function () { Route::get('users', function () { // Route assigned name admin.users ... })- ;name('users'); }); Route Model Binding When injecting a model ID to a route or controller action, you will often query to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire User model instance that matches the given ID. Implicit Binding Laravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example: Route::get('api/users/{user}', function (App\\User $user) { return $user- ;email; }); Since the $user variable is type-hinted as the App\\User Eloquent model and the variable name matches the {user} URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated. Customizing The Key Name If you would like model binding to use a database column other than id when retrieving a given model class, you may override the getRouteKeyName method on the Eloquent model: /** * Get the route key for the model. * * @return string */ public function getRouteKeyName() { return 'slug'; } Explicit Binding To register an explicit binding, use the router's model method to specify the class for a given parameter. You should define your explicit model bindings in the boot method of the RouteServiceProvider class: public function boot() { parent::boot(); Route::model('user', App\\User::class); } Next, define a route that contains a {user} parameter: Route::get('profile/{user}', function (App\\User $user) { // }); Since we have bound all {user} parameters to the App\\User model, a User instance will be injected into the route. So, for example, a request to profile/1 will inject the User instance from the database which has an ID of 1. If a matching model instance is not found in the database, a 404 HTTP response will be automatically generated. Customizing The Resolution Logic If you wish to use your own resolution logic, you may use the Route::bind method. The Closure you pass to the bind method will receive the value of the URI segment and should return the instance of the class that should be injected into the route: public function boot() { parent::boot(); Route::bind('user', function ($value) { return App\\User::where('name', $value)- ;first() ?? abort(404); }); } Fallback Routes Using the Route::fallback method, you may define a route that will be executed when no other route matches the incoming request. Typically, unhandled requests will automatically render a \"404\" page via your application's exception handler. However, since you may define the fallback route within your routes/web.php file, all middleware in the web middleware group will apply to the route. Of course, you are free to add additional middleware to this route as needed: Route::fallback(function () { // }); Rate Limiting Laravel includes a middleware to rate limit access to routes within your application. To get started, assign the throttle middleware to a route or a group of routes. The throttle middleware accepts two parameters that determine the maximum number of requests that can be made in a given number of minutes. For example, let's specify that an authenticated user may access the following group of routes 60 times per minute: Route::middleware('auth:api', 'throttle:60,1')- ;group(function () { Route::get('/user', function () { // }); }); Dynamic Rate Limiting You may specify a dynamic request maximum based on an attribute of the authenticated User model. For example, if your User model contains a rate_limit attribute, you may pass the name of the attribute to the throttle middleware so that it is used to calculate the maximum request count: Route::middleware('auth:api', 'throttle:rate_limit,1')- ;group(function () { Route::get('/user', function () { // }); }); Form Method Spoofing HTML forms do not support PUT, PATCH or DELETE actions. So, when defining PUT, PATCH or DELETE routes that are called from an HTML form, you will need to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: form action= /foo/bar method= POST ; input type= hidden name= _method value= PUT ; input type= hidden name= _token value= {{ csrf_token() }} ; /form ; You may use the @method Blade directive to generate the _method input: form action= /foo/bar method= POST ; @method('PUT') @csrf /form ; Accessing The Current Route You may use the current, currentRouteName, and currentRouteAction methods on the Route facade to access information about the route handling the incoming request: $route = Route::current(); $name = Route::currentRouteName(); $action = Route::currentRouteAction(); Refer to the API documentation for both the underlying class of the Route facade and Route instance to review all accessible methods.","title":"Routing"},{"location":"routing/#routing","text":"","title":"Routing"},{"location":"routing/#basic-routing","text":"The most basic Laravel routes accept a URI and a Closure, providing a very simple and expressive method of defining routes: ?php return [ // introduction [ 'uri' = '/docs/introduction/what-is-space', 'controller' = 'Docs\\IntroductionController', 'action' = 'whatIsSpace', ], // getting started [ 'uri' = '/docs/getting-started/installation', 'controller' = 'Docs\\IndexController', 'action' = 'installation', ], Route::get('foo', function () { return 'Hello World'; });","title":"Basic Routing"},{"location":"routing/#the-default-route-files","text":"All Laravel routes are defined in your route files, which are located in the routes directory. These files are automatically loaded by the framework. The routes/web.php file defines routes that are for your web interface. These routes are assigned the web middleware group, which provides features like session state and CSRF protection. The routes in routes/api.php are stateless and are assigned the api middleware group. For most applications, you will begin by defining routes in your routes/web.php file. The routes defined in routes/web.php may be accessed by entering the defined route's URL in your browser. For example, you may access the following route by navigating to http://your-app.test/user in your browser: Route::get('/user', 'UserController@index'); Routes defined in the routes/api.php file are nested within a route group by the RouteServiceProvider. Within this group, the /api URI prefix is automatically applied so you do not need to manually apply it to every route in the file. You may modify the prefix and other route group options by modifying your RouteServiceProvider class.","title":"The Default Route Files"},{"location":"routing/#available-router-methods","text":"The router allows you to register routes that respond to any HTTP verb: Route::get($uri, $callback); Route::post($uri, $callback); Route::put($uri, $callback); Route::patch($uri, $callback); Route::delete($uri, $callback); Route::options($uri, $callback); Sometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the match method. Or, you may even register a route that responds to all HTTP verbs using the any method: Route::match(['get', 'post'], '/', function () { // }); Route::any('foo', function () { // });","title":"Available Router Methods"},{"location":"routing/#csrf-protection","text":"Any HTML forms pointing to POST, PUT, or DELETE routes that are defined in the web routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the CSRF documentation : form method= POST action= /profile @csrf ... /form","title":"CSRF Protection"},{"location":"routing/#redirect-routes","text":"If you are defining a route that redirects to another URI, you may use the Route::redirect method. This method provides a convenient shortcut so that you do not have to define a full route or controller for performing a simple redirect: Route::redirect('/here', '/there', 301);","title":"Redirect Routes"},{"location":"routing/#view-routes","text":"If your route only needs to return a view, you may use the Route::view method. Like the redirect method, this method provides a simple shortcut so that you do not have to define a full route or controller. The view method accepts a URI as its first argument and a view name as its second argument. In addition, you may provide an array of data to pass to the view as an optional third argument: Route::view('/welcome', 'welcome'); Route::view('/welcome', 'welcome', ['name' = ; 'Taylor']);","title":"View Routes"},{"location":"routing/#route-parameters","text":"","title":"Route Parameters"},{"location":"routing/#required-parameters","text":"Of course, sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters: Route::get('user/{id}', function ($id) { return 'User '.$id; }); You may define as many route parameters as required by your route: Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) { // }); Route parameters are always encased within {} braces and should consist of alphabetic characters, and may not contain a - character. Instead of using the - character, use an underscore (_). Route parameters are injected into route callbacks / controllers based on their order - the names of the callback / controller arguments do not matter.","title":"Required Parameters"},{"location":"routing/#optional-parameters","text":"Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value: Route::get('user/{name?}', function ($name = null) { return $name; }); Route::get('user/{name?}', function ($name = 'John') { return $name; });","title":"Optional Parameters"},{"location":"routing/#regular-expression-constraints","text":"You may constrain the format of your route parameters using the where method on a route instance. The where method accepts the name of the parameter and a regular expression defining how the parameter should be constrained: Route::get('user/{name}', function ($name) { // })- ;where('name', '[A-Za-z]+'); Route::get('user/{id}', function ($id) { // })- ;where('id', '[0-9]+'); Route::get('user/{id}/{name}', function ($id, $name) { // })- ;where(['id' = ; '[0-9]+', 'name' = ; '[a-z]+']);","title":"Regular Expression Constraints"},{"location":"routing/#global-constraints","text":"If you would like a route parameter to always be constrained by a given regular expression, you may use the pattern method. You should define these patterns in the boot method of your RouteServiceProvider: /** * Define your route model bindings, pattern filters, etc. * * @return void */ public function boot() { Route::pattern('id', '[0-9]+'); parent::boot(); } Once the pattern has been defined, it is automatically applied to all routes using that parameter name: Route::get('user/{id}', function ($id) { // Only executed if {id} is numeric... });","title":"Global Constraints"},{"location":"routing/#named-routes","text":"Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the name method onto the route definition: Route::get('user/profile', function () { // })- ;name('profile'); You may also specify route names for controller actions: Route::get('user/profile', 'UserProfileController@show')- ;name('profile');","title":"Named Routes"},{"location":"routing/#generating-urls-to-named-routes","text":"Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via the global route function: // Generating URLs... $url = route('profile'); // Generating Redirects... return redirect()- ;route('profile'); If the named route defines parameters, you may pass the parameters as the second argument to the route function. The given parameters will automatically be inserted into the URL in their correct positions: Route::get('user/{id}/profile', function ($id) { // })- ;name('profile'); $url = route('profile', ['id' = ; 1]);","title":"Generating URLs To Named Routes"},{"location":"routing/#inspecting-the-current-route","text":"If you would like to determine if the current request was routed to a given named route, you may use the named method on a Route instance. For example, you may check the current route name from a route middleware: /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) { if ($request- ;route()- ;named('profile')) { // } return $next($request); }","title":"Inspecting The Current Route"},{"location":"routing/#route-groups","text":"Route groups allow you to share route attributes, such as middleware or namespaces, across a large number of routes without needing to define those attributes on each individual route. Shared attributes are specified in an array format as the first parameter to the Route::group method.","title":"Route Groups"},{"location":"routing/#middleware","text":"To assign middleware to all routes within a group, you may use the middleware method before defining the group. Middleware are executed in the order they are listed in the array: Route::middleware(['first', 'second'])- ;group(function () { Route::get('/', function () { // Uses first amp; second Middleware }); Route::get('user/profile', function () { // Uses first amp; second Middleware }); });","title":"Middleware"},{"location":"routing/#namespaces","text":"Another common use-case for route groups is assigning the same PHP namespace to a group of controllers using the namespace method: Route::namespace('Admin')- ;group(function () { // Controllers Within The App\\Http\\Controllers\\Admin Namespace }); Remember, by default, the RouteServiceProvider includes your route files within a namespace group, allowing you to register controller routes without specifying the full App\\Http\\Controllers namespace prefix. So, you only need to specify the portion of the namespace that comes after the base App\\Http\\Controllers namespace.","title":"Namespaces"},{"location":"routing/#sub-domain-routing","text":"Route groups may also be used to handle sub-domain routing. Sub-domains may be assigned route parameters just like route URIs, allowing you to capture a portion of the sub-domain for usage in your route or controller. The sub-domain may be specified by calling the domain method before defining the group: Route::domain('{account}.myapp.com')- ;group(function () { Route::get('user/{id}', function ($account, $id) { // }); });","title":"Sub-Domain Routing"},{"location":"routing/#route-prefixes","text":"The prefix method may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with admin: Route::prefix('admin')- ;group(function () { Route::get('users', function () { // Matches The /admin/users URL }); });","title":"Route Prefixes"},{"location":"routing/#route-name-prefixes","text":"The name method may be used to prefix each route name in the group with a given string. For example, you may want to prefix all of the grouped route's names with admin. The given string is prefixed to the route name exactly as it is specified, so we will be sure to provide the trailing . character in the prefix: Route::name('admin.')- ;group(function () { Route::get('users', function () { // Route assigned name admin.users ... })- ;name('users'); });","title":"Route Name Prefixes"},{"location":"routing/#route-model-binding","text":"When injecting a model ID to a route or controller action, you will often query to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire User model instance that matches the given ID.","title":"Route Model Binding"},{"location":"routing/#implicit-binding","text":"Laravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example: Route::get('api/users/{user}', function (App\\User $user) { return $user- ;email; }); Since the $user variable is type-hinted as the App\\User Eloquent model and the variable name matches the {user} URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated.","title":"Implicit Binding"},{"location":"routing/#customizing-the-key-name","text":"If you would like model binding to use a database column other than id when retrieving a given model class, you may override the getRouteKeyName method on the Eloquent model: /** * Get the route key for the model. * * @return string */ public function getRouteKeyName() { return 'slug'; }","title":"Customizing The Key Name"},{"location":"routing/#explicit-binding","text":"To register an explicit binding, use the router's model method to specify the class for a given parameter. You should define your explicit model bindings in the boot method of the RouteServiceProvider class: public function boot() { parent::boot(); Route::model('user', App\\User::class); } Next, define a route that contains a {user} parameter: Route::get('profile/{user}', function (App\\User $user) { // }); Since we have bound all {user} parameters to the App\\User model, a User instance will be injected into the route. So, for example, a request to profile/1 will inject the User instance from the database which has an ID of 1. If a matching model instance is not found in the database, a 404 HTTP response will be automatically generated.","title":"Explicit Binding"},{"location":"routing/#customizing-the-resolution-logic","text":"If you wish to use your own resolution logic, you may use the Route::bind method. The Closure you pass to the bind method will receive the value of the URI segment and should return the instance of the class that should be injected into the route: public function boot() { parent::boot(); Route::bind('user', function ($value) { return App\\User::where('name', $value)- ;first() ?? abort(404); }); }","title":"Customizing The Resolution Logic"},{"location":"routing/#fallback-routes","text":"Using the Route::fallback method, you may define a route that will be executed when no other route matches the incoming request. Typically, unhandled requests will automatically render a \"404\" page via your application's exception handler. However, since you may define the fallback route within your routes/web.php file, all middleware in the web middleware group will apply to the route. Of course, you are free to add additional middleware to this route as needed: Route::fallback(function () { // });","title":"Fallback Routes"},{"location":"routing/#rate-limiting","text":"Laravel includes a middleware to rate limit access to routes within your application. To get started, assign the throttle middleware to a route or a group of routes. The throttle middleware accepts two parameters that determine the maximum number of requests that can be made in a given number of minutes. For example, let's specify that an authenticated user may access the following group of routes 60 times per minute: Route::middleware('auth:api', 'throttle:60,1')- ;group(function () { Route::get('/user', function () { // }); });","title":"Rate Limiting"},{"location":"routing/#dynamic-rate-limiting","text":"You may specify a dynamic request maximum based on an attribute of the authenticated User model. For example, if your User model contains a rate_limit attribute, you may pass the name of the attribute to the throttle middleware so that it is used to calculate the maximum request count: Route::middleware('auth:api', 'throttle:rate_limit,1')- ;group(function () { Route::get('/user', function () { // }); });","title":"Dynamic Rate Limiting"},{"location":"routing/#form-method-spoofing","text":"HTML forms do not support PUT, PATCH or DELETE actions. So, when defining PUT, PATCH or DELETE routes that are called from an HTML form, you will need to add a hidden _method field to the form. The value sent with the _method field will be used as the HTTP request method: form action= /foo/bar method= POST ; input type= hidden name= _method value= PUT ; input type= hidden name= _token value= {{ csrf_token() }} ; /form ; You may use the @method Blade directive to generate the _method input: form action= /foo/bar method= POST ; @method('PUT') @csrf /form ;","title":"Form Method Spoofing"},{"location":"routing/#accessing-the-current-route","text":"You may use the current, currentRouteName, and currentRouteAction methods on the Route facade to access information about the route handling the incoming request: $route = Route::current(); $name = Route::currentRouteName(); $action = Route::currentRouteAction(); Refer to the API documentation for both the underlying class of the Route facade and Route instance to review all accessible methods.","title":"Accessing The Current Route"},{"location":"session/","text":"HTTP Session Introduction Since HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple requests. Space MVC ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular backends such as Memcached , Redis , and databases is included out of the box. Configuration The session configuration file is stored at config/session.php. Be sure to review the options available to you in this file. By default, Space MVC is configured to use the file session driver, which will work well for many applications. In production applications, you may consider using the memcached or redis drivers for even faster session performance. The session driver configuration option defines where session data will be stored for each request. Space MVC ships with several great drivers out of the box: file - sessions are stored in storage/framework/sessions. cookie - sessions are stored in secure, encrypted cookies. database - sessions are stored in a relational database. memcached / redis - sessions are stored in one of these fast, cache based stores. array - sessions are stored in a PHP array and will not be persisted. The array driver is used during testing and prevents the data stored in the session from being persisted. Driver Prerequisites Database When using the database session driver, you will need to create a table to contain the session items. Below is an example Schema declaration for the table: Schema::create('sessions', function ($table) { $table- string('id')- unique(); $table- unsignedInteger('user_id')- nullable(); $table- string('ip_address', 45)- nullable(); $table- text('user_agent')- nullable(); $table- text('payload'); $table- integer('last_activity'); }); You may use the session:table Artisan command to generate this migration: php artisan session:table php artisan migrate Redis Before using Redis sessions with Space MVC, you will need to install the predis/predis package (~1.0) via Composer. You may configure your Redis connections in the database configuration file. In the session configuration file, the connection option may be used to specify which Redis connection is used by the session. Using The Session Retrieving Data There are two primary ways of working with session data in Space MVC: the global session helper and via a Request instance. First, let's look at accessing the session via a Request instance, which can be type-hinted on a controller method. Remember, controller method dependencies are automatically injected via the Space MVC service container : ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param Request $request * @param int $id * @return Response */ public function show(Request $request, $id) { $value = $request- session()- get('key'); // } } When you retrieve an item from the session, you may also pass a default value as the second argument to the get method. This default value will be returned if the specified key does not exist in the session. If you pass a Closure as the default value to the get method and the requested key does not exist, the Closure will be executed and its result returned: $value = $request- session()- get('key', 'default'); $value = $request- session()- get('key', function () { return 'default'; }); The Global Session Helper You may also use the global session PHP function to retrieve and store data in the session. When the session helper is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of key / value pairs, those values will be stored in the session: Route::get('home', function () { // Retrieve a piece of data from the session... $value = session('key'); // Specifying a default value... $value = session('key', 'default'); // Store a piece of data in the session... session(['key' = 'value']); }); There is little practical difference between using the session via an HTTP request instance versus using the global session helper. Both methods are testable via the assertSessionHas method which is available in all of your test cases. Retrieving All Session Data If you would like to retrieve all the data in the session, you may use the all method: $data = $request- session()- all(); Determining If An Item Exists In The Session To determine if an item is present in the session, you may use the has method. The has method returns true if the item is present and is not null: if ($request- session()- has('users')) { // } To determine if an item is present in the session, even if its value is null, you may use the exists method. The exists method returns true if the item is present: if ($request- session()- exists('users')) { // } Storing Data To store data in the session, you will typically use the put method or the session helper: // Via a request instance... $request- session()- put('key', 'value'); // Via the global helper... session(['key' = 'value']); Pushing To Array Session Values The push method may be used to push a new value onto a session value that is an array. For example, if the user.teams key contains an array of team names, you may push a new value onto the array like so: $request- session()- push('user.teams', 'developers'); Retrieving Deleting An Item The pull method will retrieve and delete an item from the session in a single statement: $value = $request- session()- pull('key', 'default'); Flash Data Sometimes you may wish to store items in the session only for the next request. You may do so using the flash method. Data stored in the session using this method will only be available during the subsequent HTTP request, and then will be deleted. Flash data is primarily useful for short-lived status messages: $request- session()- flash('status', 'Task was successful!'); If you need to keep your flash data around for several requests, you may use the reflash method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the keep method: $request- session()- reflash(); $request- session()- keep(['username', 'email']); Deleting Data The forget method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the flush method: $request- session()- forget('key'); $request- session()- flush(); Regenerating The Session ID Regenerating the session ID is often done in order to prevent malicious users from exploiting a session fixation attack on your application. Space MVC automatically regenerates the session ID during authentication if you are using the built-in LoginController; however, if you need to manually regenerate the session ID, you may use the regenerate method. $request- session()- regenerate(); Adding Custom Session Drivers Implementing The Driver Your custom session driver should implement the SessionHandlerInterface. This interface contains just a few simple methods we need to implement. A stubbed MongoDB implementation looks something like this: ?php namespace App\\Extensions; class MongoSessionHandler implements \\SessionHandlerInterface { public function open($savePath, $sessionName) {} public function close() {} public function read($sessionId) {} public function write($sessionId, $data) {} public function destroy($sessionId) {} public function gc($lifetime) {} } Space MVC does not ship with a directory to contain your extensions. You are free to place them anywhere you like. In this example, we have created an Extensions directory to house the MongoSessionHandler. Since the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do: The open method would typically be used in file based session store systems. Since Space MVC ships with a file session driver, you will almost never need to put anything in this method. You can leave it as an empty stub. It is a fact of poor interface design (which we'll discuss later) that PHP requires us to implement this method. The close method, like the open method, can also usually be disregarded. For most drivers, it is not needed. The read method should return the string version of the session data associated with the given $sessionId. There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as Space MVC will perform the serialization for you. The write method should write the given $data string associated with the $sessionId to some persistent storage system, such as MongoDB, Dynamo, etc. Again, you should not perform any serialization - Space MVC will have already handled that for you. The destroy method should remove the data associated with the $sessionId from persistent storage. The gc method should destroy all session data that is older than the given $lifetime, which is a UNIX timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty. Registering The Driver Once your driver has been implemented, you are ready to register it with the framework. To add additional drivers to Space MVC's session backend, you may use the extend method on the Session facade . You should call the extend method from the boot method of a service provider . You may do this from the existing AppServiceProvider or create an entirely new provider: ?php namespace App\\Providers; use App\\Extensions\\MongoSessionHandler; use Illuminate\\Support\\Facades\\Session; use Illuminate\\Support\\ServiceProvider; class SessionServiceProvider extends ServiceProvider { /** * Perform post-registration booting of services. * * @return void */ public function boot() { Session::extend('mongo', function ($app) { // Return implementation of SessionHandlerInterface... return new MongoSessionHandler; }); } /** * Register bindings in the container. * * @return void */ public function register() { // } } Once the session driver has been registered, you may use the mongo driver in your config/session.php configuration file.","title":"Session"},{"location":"session/#http-session","text":"","title":"HTTP Session"},{"location":"session/#introduction","text":"Since HTTP driven applications are stateless, sessions provide a way to store information about the user across multiple requests. Space MVC ships with a variety of session backends that are accessed through an expressive, unified API. Support for popular backends such as Memcached , Redis , and databases is included out of the box.","title":"Introduction"},{"location":"session/#configuration","text":"The session configuration file is stored at config/session.php. Be sure to review the options available to you in this file. By default, Space MVC is configured to use the file session driver, which will work well for many applications. In production applications, you may consider using the memcached or redis drivers for even faster session performance. The session driver configuration option defines where session data will be stored for each request. Space MVC ships with several great drivers out of the box: file - sessions are stored in storage/framework/sessions. cookie - sessions are stored in secure, encrypted cookies. database - sessions are stored in a relational database. memcached / redis - sessions are stored in one of these fast, cache based stores. array - sessions are stored in a PHP array and will not be persisted. The array driver is used during testing and prevents the data stored in the session from being persisted.","title":"Configuration"},{"location":"session/#driver-prerequisites","text":"","title":"Driver Prerequisites"},{"location":"session/#database","text":"When using the database session driver, you will need to create a table to contain the session items. Below is an example Schema declaration for the table: Schema::create('sessions', function ($table) { $table- string('id')- unique(); $table- unsignedInteger('user_id')- nullable(); $table- string('ip_address', 45)- nullable(); $table- text('user_agent')- nullable(); $table- text('payload'); $table- integer('last_activity'); }); You may use the session:table Artisan command to generate this migration: php artisan session:table php artisan migrate","title":"Database"},{"location":"session/#redis","text":"Before using Redis sessions with Space MVC, you will need to install the predis/predis package (~1.0) via Composer. You may configure your Redis connections in the database configuration file. In the session configuration file, the connection option may be used to specify which Redis connection is used by the session.","title":"Redis"},{"location":"session/#using-the-session","text":"","title":"Using The Session"},{"location":"session/#retrieving-data","text":"There are two primary ways of working with session data in Space MVC: the global session helper and via a Request instance. First, let's look at accessing the session via a Request instance, which can be type-hinted on a controller method. Remember, controller method dependencies are automatically injected via the Space MVC service container : ?php namespace App\\Http\\Controllers; use Illuminate\\Http\\Request; use App\\Http\\Controllers\\Controller; class UserController extends Controller { /** * Show the profile for the given user. * * @param Request $request * @param int $id * @return Response */ public function show(Request $request, $id) { $value = $request- session()- get('key'); // } } When you retrieve an item from the session, you may also pass a default value as the second argument to the get method. This default value will be returned if the specified key does not exist in the session. If you pass a Closure as the default value to the get method and the requested key does not exist, the Closure will be executed and its result returned: $value = $request- session()- get('key', 'default'); $value = $request- session()- get('key', function () { return 'default'; });","title":"Retrieving Data"},{"location":"session/#the-global-session-helper","text":"You may also use the global session PHP function to retrieve and store data in the session. When the session helper is called with a single, string argument, it will return the value of that session key. When the helper is called with an array of key / value pairs, those values will be stored in the session: Route::get('home', function () { // Retrieve a piece of data from the session... $value = session('key'); // Specifying a default value... $value = session('key', 'default'); // Store a piece of data in the session... session(['key' = 'value']); }); There is little practical difference between using the session via an HTTP request instance versus using the global session helper. Both methods are testable via the assertSessionHas method which is available in all of your test cases.","title":"The Global Session Helper"},{"location":"session/#retrieving-all-session-data","text":"If you would like to retrieve all the data in the session, you may use the all method: $data = $request- session()- all();","title":"Retrieving All Session Data"},{"location":"session/#determining-if-an-item-exists-in-the-session","text":"To determine if an item is present in the session, you may use the has method. The has method returns true if the item is present and is not null: if ($request- session()- has('users')) { // } To determine if an item is present in the session, even if its value is null, you may use the exists method. The exists method returns true if the item is present: if ($request- session()- exists('users')) { // }","title":"Determining If An Item Exists In The Session"},{"location":"session/#storing-data","text":"To store data in the session, you will typically use the put method or the session helper: // Via a request instance... $request- session()- put('key', 'value'); // Via the global helper... session(['key' = 'value']);","title":"Storing Data"},{"location":"session/#pushing-to-array-session-values","text":"The push method may be used to push a new value onto a session value that is an array. For example, if the user.teams key contains an array of team names, you may push a new value onto the array like so: $request- session()- push('user.teams', 'developers');","title":"Pushing To Array Session Values"},{"location":"session/#retrieving-deleting-an-item","text":"The pull method will retrieve and delete an item from the session in a single statement: $value = $request- session()- pull('key', 'default');","title":"Retrieving &amp; Deleting An Item"},{"location":"session/#flash-data","text":"Sometimes you may wish to store items in the session only for the next request. You may do so using the flash method. Data stored in the session using this method will only be available during the subsequent HTTP request, and then will be deleted. Flash data is primarily useful for short-lived status messages: $request- session()- flash('status', 'Task was successful!'); If you need to keep your flash data around for several requests, you may use the reflash method, which will keep all of the flash data for an additional request. If you only need to keep specific flash data, you may use the keep method: $request- session()- reflash(); $request- session()- keep(['username', 'email']);","title":"Flash Data"},{"location":"session/#deleting-data","text":"The forget method will remove a piece of data from the session. If you would like to remove all data from the session, you may use the flush method: $request- session()- forget('key'); $request- session()- flush();","title":"Deleting Data"},{"location":"session/#regenerating-the-session-id","text":"Regenerating the session ID is often done in order to prevent malicious users from exploiting a session fixation attack on your application. Space MVC automatically regenerates the session ID during authentication if you are using the built-in LoginController; however, if you need to manually regenerate the session ID, you may use the regenerate method. $request- session()- regenerate();","title":"Regenerating The Session ID"},{"location":"session/#adding-custom-session-drivers","text":"","title":"Adding Custom Session Drivers"},{"location":"session/#implementing-the-driver","text":"Your custom session driver should implement the SessionHandlerInterface. This interface contains just a few simple methods we need to implement. A stubbed MongoDB implementation looks something like this: ?php namespace App\\Extensions; class MongoSessionHandler implements \\SessionHandlerInterface { public function open($savePath, $sessionName) {} public function close() {} public function read($sessionId) {} public function write($sessionId, $data) {} public function destroy($sessionId) {} public function gc($lifetime) {} } Space MVC does not ship with a directory to contain your extensions. You are free to place them anywhere you like. In this example, we have created an Extensions directory to house the MongoSessionHandler. Since the purpose of these methods is not readily understandable, let's quickly cover what each of the methods do: The open method would typically be used in file based session store systems. Since Space MVC ships with a file session driver, you will almost never need to put anything in this method. You can leave it as an empty stub. It is a fact of poor interface design (which we'll discuss later) that PHP requires us to implement this method. The close method, like the open method, can also usually be disregarded. For most drivers, it is not needed. The read method should return the string version of the session data associated with the given $sessionId. There is no need to do any serialization or other encoding when retrieving or storing session data in your driver, as Space MVC will perform the serialization for you. The write method should write the given $data string associated with the $sessionId to some persistent storage system, such as MongoDB, Dynamo, etc. Again, you should not perform any serialization - Space MVC will have already handled that for you. The destroy method should remove the data associated with the $sessionId from persistent storage. The gc method should destroy all session data that is older than the given $lifetime, which is a UNIX timestamp. For self-expiring systems like Memcached and Redis, this method may be left empty.","title":"Implementing The Driver"},{"location":"session/#registering-the-driver","text":"Once your driver has been implemented, you are ready to register it with the framework. To add additional drivers to Space MVC's session backend, you may use the extend method on the Session facade . You should call the extend method from the boot method of a service provider . You may do this from the existing AppServiceProvider or create an entirely new provider: ?php namespace App\\Providers; use App\\Extensions\\MongoSessionHandler; use Illuminate\\Support\\Facades\\Session; use Illuminate\\Support\\ServiceProvider; class SessionServiceProvider extends ServiceProvider { /** * Perform post-registration booting of services. * * @return void */ public function boot() { Session::extend('mongo', function ($app) { // Return implementation of SessionHandlerInterface... return new MongoSessionHandler; }); } /** * Register bindings in the container. * * @return void */ public function register() { // } } Once the session driver has been registered, you may use the mongo driver in your config/session.php configuration file.","title":"Registering The Driver"},{"location":"space-cli/","text":"Space Command Line Interface (CLI) Tool Space is the command-line interface included with Space MVC. It provides a number of helpful commands that can assist you while you build your application. To view a list of all available Space commands, you may use the list command: php space list Every command also includes a \"help\" screen which displays and describes the command's available arguments and options. To view a help screen, precede the name of the command with help: php space help migrate Space MVC REPL All Space MVC applications include Tinker, a REPL powered by the PsySH package. Tinker allows you to interact with your entire Space MVC application on the command line, including the Eloquent ORM, jobs, events, and more. To enter the Tinker environment, run the tinker Space command: php space tinker Writing Commands In addition to the commands provided with Space, you may also build your own custom commands. Commands are typically stored in the app/Console/Commands directory; however, you are free to choose your own storage location as long as your commands can be loaded by Composer. Generating Commands To create a new command, use the make:command Space command. This command will create a new command class in the app/Console/Commands directory. Don't worry if this directory does not exist in your application, since it will be created the first time you run the make:command Space command. The generated command will include the default set of properties and methods that are present on all commands: php space make:command SendEmails Command Structure After generating your command, you should fill in the signature and description properties of the class, which will be used when displaying your command on the list screen. The handle method will be called when your command is executed. You may place your command logic in this method. For greater code reuse, it is good practice to keep your console commands light and let them defer to application services to accomplish their tasks. In the example below, note that we inject a service class to do the \"heavy lifting\" of sending the e-mails. Let's take a look at an example command. Note that we are able to inject any dependencies we need into the command's constructor or handle method. The Space MVC service container will automatically inject all dependencies type-hinted in the constructor or handle method: ?php namespace App\\Console\\Commands; use App\\User; use App\\DripEmailer; use Illuminate\\Console\\Command; class SendEmails extends Command { /** * The name and signature of the console command. * * @var string */ protected \\$signature = \\'email:send {user}\\'; /** * The console command description. * * @var string */ protected \\$description = \\'Send drip e-mails to a user\\'; /** * The drip e-mail service. * * @var DripEmailer */ protected \\$drip; /** * Create a new command instance. * * @param DripEmailer \\$drip * @return void */ public function __construct(DripEmailer \\$drip) { parent::__construct(); \\$this- drip = \\$drip; } /** * Execute the console command. * * @return mixed */ public function handle() { \\$this- drip- send(User::find(\\$this- argument(\\'user\\'))); } } ?php namespace App\\Console\\Commands; use App\\User; use App\\DripEmailer; use Illuminate\\Console\\Command; class SendEmails extends Command { /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user}\\'; /** * The console command description. * * @var string */ protected $description = \\'Send drip e-mails to a user\\'; /** * The drip e-mail service. * * @var DripEmailer */ protected $drip; /** * Create a new command instance. * * @param DripEmailer $drip * @return void */ public function __construct(DripEmailer $drip) { parent::__construct(); $this- drip = $drip; } /** * Execute the console command. * * @return mixed */ public function handle() { $this- drip- send(User::find($this- argument(\\'user\\'))); } } Closure Commands Closure based commands provide an alternative to defining console commands as classes. In the same way that route Closures are an alternative to controllers, think of command Closures as an alternative to command classes. Within the commands method of your app/Console/Kernel.php file, Space MVC loads the routes/console.php file: /** * Register the Closure based commands for the application. * * @return void */ protected function commands() { require base_path(\\'routes/console.php\\'); } Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application. Within this file, you may define all of your Closure based routes using the Space::command method. The command method accepts two arguments: the command signature and a Closure which receives the commands arguments and options: Space::command(\\'build {project}\\', function ($project) { $this- info( Building {$project}! ); }); The Closure is bound to the underlying command instance, so you have full access to all of the helper methods you would typically be able to access on a full command class. Type-Hinting Dependencies In addition to receiving your command's arguments and options, command Closures may also type-hint additional dependencies that you would like resolved out of the service container : use App\\User; use App\\DripEmailer; Space::command(\\'email:send {user}\\', function (DripEmailer $drip, $user) { $drip- send(User::find($user)); }); Closure Command Descriptions When defining a Closure based command, you may use the describe method to add a description to the command. This description will be displayed when you run the php space list or php space help commands: Space::command(\\'build {project}\\', function ($project) { $this- info( Building {$project}! ); })- describe(\\'Build the project\\'); Defining Input Expectations When writing console commands, it is common to gather input from the user through arguments or options. Space MVC makes it very convenient to define the input you expect from the user using the signature property on your commands. The signature property allows you to define the name, arguments, and options for the command in a single, expressive, route-like syntax. Arguments All user supplied arguments and options are wrapped in curly braces. In the following example, the command defines one required argument: user: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user}\\'; You may also make arguments optional and define default values for arguments: // Optional argument... email:send {user?} // Optional argument with default value... email:send {user=foo} Options Options, like arguments, are another form of user input. Options are prefixed by two hyphens (--) when they are specified on the command line. There are two types of options: those that receive a value and those that don't. Options that don't receive a value serve as a boolean \"switch\". Let's take a look at an example of this type of option: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user} {--queue}\\'; In this example, the --queue switch may be specified when calling the Space command. If the --queue switch is passed, the value of the option will be true. Otherwise, the value will be false: php space email:send 1 --queue Options With Values Next, let's take a look at an option that expects a value. If the user must specify a value for an option, suffix the option name with a = sign: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user} {--queue=}\\'; In this example, the user may pass a value for the option like so: php space email:send 1 --queue=default You may assign default values to options by specifying the default value after the option name. If no option value is passed by the user, the default value will be used: email:send {user} {--queue=default} Option Shortcuts To assign a shortcut when defining an option, you may specify it before the option name and use a | delimiter to separate the shortcut from the full option name: email:send {user} {--Q|queue} Input Arrays If you would like to define arguments or options to expect array inputs, you may use the * character. First, let's take a look at an example that specifies an array argument: email:send {user*} When calling this method, the user arguments may be passed in order to the command line. For example, the following command will set the value of user to ['foo', 'bar']: php space email:send foo bar When defining an option that expects an array input, each option value passed to the command should be prefixed with the option name: email:send {user} {--id=*} php space email:send --id=1 --id=2 Input Descriptions You may assign descriptions to input arguments and options by separating the parameter from the description using a colon. If you need a little extra room to define your command, feel free to spread the definition across multiple lines: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user : The ID of the user} {--queue= : Whether the job should be queued}\\'; Command I/O Retrieving Input While your command is executing, you will obviously need to access the values for the arguments and options accepted by your command. To do so, you may use the argument and option methods: /** * Execute the console command. * * @return mixed */ public function handle() { $userId = $this- argument(\\'user\\'); // } If you need to retrieve all of the arguments as an array, call the arguments method: $arguments = $this- arguments(); Options may be retrieved just as easily as arguments using the option method. To retrieve all of the options as an array, call the options method: // Retrieve a specific option... $queueName = $this- option(\\'queue\\'); // Retrieve all options... $options = $this- options(); If the argument or option does not exist, null will be returned. Prompting For Input In addition to displaying output, you may also ask the user to provide input during the execution of your command. The ask method will prompt the user with the given question, accept their input, and then return the user's input back to your command: /** * Execute the console command. * * @return mixed */ public function handle() { $name = $this- ask(\\'What is your name?\\'); } The secret method is similar to ask, but the user's input will not be visible to them as they type in the console. This method is useful when asking for sensitive information such as a password: $password = $this- secret(\\'What is the password?\\'); Asking For Confirmation If you need to ask the user for a simple confirmation, you may use the confirm method. By default, this method will return false. However, if the user enters y or yes in response to the prompt, the method will return true. if ($this- confirm(\\'Do you wish to continue?\\')) { // } Auto-Completion The anticipate method can be used to provide auto-completion for possible choices. The user can still choose any answer, regardless of the auto-completion hints: $name = $this- anticipate(\\'What is your name?\\', [\\'Taylor\\', \\'Dayle\\']); Multiple Choice Questions If you need to give the user a predefined set of choices, you may use the choice method. You may set the array index of the default value to be returned if no option is chosen: $name = $this- choice(\\'What is your name?\\', [\\'Taylor\\', \\'Dayle\\'], $defaultIndex); Writing Output To send output to the console, use the line, info, comment, question and error methods. Each of these methods will use appropriate ANSI colors for their purpose. For example, let's display some general information to the user. Typically, the info method will display in the console as green text: /** * Execute the console command. * * @return mixed */ public function handle() { $this- info(\\'Display this on the screen\\'); } To display an error message, use the error method. Error message text is typically displayed in red: $this- error(\\'Something went wrong!\\'); If you would like to display plain, uncolored console output, use the line method: $this- line(\\'Display this on the screen\\'); Table Layouts The table method makes it easy to correctly format multiple rows / columns of data. Just pass in the headers and rows to the method. The width and height will be dynamically calculated based on the given data: $headers = [\\'Name\\', \\'Email\\']; $users = App\\User::all([\\'name\\', \\'email\\'])- toArray(); $this- table($headers, $users); Progress Bars For long running tasks, it could be helpful to show a progress indicator. Using the output object, we can start, advance and stop the Progress Bar. First, define the total number of steps the process will iterate through. Then, advance the Progress Bar after processing each item: $users = App\\User::all(); $bar = $this- output- createProgressBar(count($users)); $bar- start(); foreach ($users as $user) { $this- performTask($user); $bar- advance(); } $bar- finish(); For more advanced options, check out the Symfony Progress Bar component documentation . Registering Commands Because of the load method call in your console kernel's commands method, all commands within the app/Console/Commands directory will automatically be registered with Space. In fact, you are free to make additional calls to the load method to scan other directories for Space commands: /** * Register the commands for the application. * * @return void */ protected function commands() { $this- load(__DIR__.\\'/Commands\\'); $this- load(__DIR__.\\'/MoreCommands\\'); // ... } You may also manually register commands by adding its class name to the $commands property of your app/Console/Kernel.php file. When Space boots, all the commands listed in this property will be resolved by the service container and registered with Space: protected $commands = [ Commands\\SendEmails::class ]; Programmatically Executing Commands Sometimes you may wish to execute an Space command outside of the CLI. For example, you may wish to fire an Space command from a route or controller. You may use the call method on the Space facade to accomplish this. The call method accepts either the command's name or class as the first argument, and an array of command parameters as the second argument. The exit code will be returned: Route::get(\\'/foo\\', function () { $exitCode = Space::call(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]); // }); Using the queue method on the Space facade, you may even queue Space commands so they are processed in the background by your queue workers . Before using this method, make sure you have configured your queue and are running a queue listener: Route::get(\\'/foo\\', function () { Space::queue(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]); // }); You may also specify the connection or queue the Space command should be dispatched to: Space::queue(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ])- onConnection(\\'redis\\')- onQueue(\\'commands\\'); Passing Array Values If your command defines an option that accepts an array, you may pass an array of values to that option: Route::get(\\'/foo\\', function () { $exitCode = Space::call(\\'email:send\\', [ \\'user\\' = 1, \\'--id\\' = [5, 13] ]); }); Passing Boolean Values If you need to specify the value of an option that does not accept string values, such as the --force flag on the migrate:refresh command, you should pass true or false: $exitCode = Space::call(\\'migrate:refresh\\', [ \\'--force\\' = true, ]); Calling Commands From Other Commands Sometimes you may wish to call other commands from an existing Space command. You may do so using the call method. This call method accepts the command name and an array of command parameters: /** * Execute the console command. * * @return mixed */ public function handle() { $this- call(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]); // } If you would like to call another console command and suppress all of its output, you may use the callSilent method. The callSilent method has the same signature as the call method: $this- callSilent(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]);","title":"Space CLI Tool"},{"location":"space-cli/#space-command-line-interface-cli-tool","text":"Space is the command-line interface included with Space MVC. It provides a number of helpful commands that can assist you while you build your application. To view a list of all available Space commands, you may use the list command: php space list Every command also includes a \"help\" screen which displays and describes the command's available arguments and options. To view a help screen, precede the name of the command with help: php space help migrate","title":"Space Command Line Interface (CLI) Tool"},{"location":"space-cli/#space-mvc-repl","text":"All Space MVC applications include Tinker, a REPL powered by the PsySH package. Tinker allows you to interact with your entire Space MVC application on the command line, including the Eloquent ORM, jobs, events, and more. To enter the Tinker environment, run the tinker Space command: php space tinker","title":"Space MVC REPL"},{"location":"space-cli/#writing-commands","text":"In addition to the commands provided with Space, you may also build your own custom commands. Commands are typically stored in the app/Console/Commands directory; however, you are free to choose your own storage location as long as your commands can be loaded by Composer.","title":"Writing Commands"},{"location":"space-cli/#generating-commands","text":"To create a new command, use the make:command Space command. This command will create a new command class in the app/Console/Commands directory. Don't worry if this directory does not exist in your application, since it will be created the first time you run the make:command Space command. The generated command will include the default set of properties and methods that are present on all commands: php space make:command SendEmails","title":"Generating Commands"},{"location":"space-cli/#command-structure","text":"After generating your command, you should fill in the signature and description properties of the class, which will be used when displaying your command on the list screen. The handle method will be called when your command is executed. You may place your command logic in this method. For greater code reuse, it is good practice to keep your console commands light and let them defer to application services to accomplish their tasks. In the example below, note that we inject a service class to do the \"heavy lifting\" of sending the e-mails. Let's take a look at an example command. Note that we are able to inject any dependencies we need into the command's constructor or handle method. The Space MVC service container will automatically inject all dependencies type-hinted in the constructor or handle method: ?php namespace App\\Console\\Commands; use App\\User; use App\\DripEmailer; use Illuminate\\Console\\Command; class SendEmails extends Command { /** * The name and signature of the console command. * * @var string */ protected \\$signature = \\'email:send {user}\\'; /** * The console command description. * * @var string */ protected \\$description = \\'Send drip e-mails to a user\\'; /** * The drip e-mail service. * * @var DripEmailer */ protected \\$drip; /** * Create a new command instance. * * @param DripEmailer \\$drip * @return void */ public function __construct(DripEmailer \\$drip) { parent::__construct(); \\$this- drip = \\$drip; } /** * Execute the console command. * * @return mixed */ public function handle() { \\$this- drip- send(User::find(\\$this- argument(\\'user\\'))); } } ?php namespace App\\Console\\Commands; use App\\User; use App\\DripEmailer; use Illuminate\\Console\\Command; class SendEmails extends Command { /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user}\\'; /** * The console command description. * * @var string */ protected $description = \\'Send drip e-mails to a user\\'; /** * The drip e-mail service. * * @var DripEmailer */ protected $drip; /** * Create a new command instance. * * @param DripEmailer $drip * @return void */ public function __construct(DripEmailer $drip) { parent::__construct(); $this- drip = $drip; } /** * Execute the console command. * * @return mixed */ public function handle() { $this- drip- send(User::find($this- argument(\\'user\\'))); } }","title":"Command Structure"},{"location":"space-cli/#closure-commands","text":"Closure based commands provide an alternative to defining console commands as classes. In the same way that route Closures are an alternative to controllers, think of command Closures as an alternative to command classes. Within the commands method of your app/Console/Kernel.php file, Space MVC loads the routes/console.php file: /** * Register the Closure based commands for the application. * * @return void */ protected function commands() { require base_path(\\'routes/console.php\\'); } Even though this file does not define HTTP routes, it defines console based entry points (routes) into your application. Within this file, you may define all of your Closure based routes using the Space::command method. The command method accepts two arguments: the command signature and a Closure which receives the commands arguments and options: Space::command(\\'build {project}\\', function ($project) { $this- info( Building {$project}! ); }); The Closure is bound to the underlying command instance, so you have full access to all of the helper methods you would typically be able to access on a full command class.","title":"Closure Commands"},{"location":"space-cli/#type-hinting-dependencies","text":"In addition to receiving your command's arguments and options, command Closures may also type-hint additional dependencies that you would like resolved out of the service container : use App\\User; use App\\DripEmailer; Space::command(\\'email:send {user}\\', function (DripEmailer $drip, $user) { $drip- send(User::find($user)); });","title":"Type-Hinting Dependencies"},{"location":"space-cli/#closure-command-descriptions","text":"When defining a Closure based command, you may use the describe method to add a description to the command. This description will be displayed when you run the php space list or php space help commands: Space::command(\\'build {project}\\', function ($project) { $this- info( Building {$project}! ); })- describe(\\'Build the project\\');","title":"Closure Command Descriptions"},{"location":"space-cli/#defining-input-expectations","text":"When writing console commands, it is common to gather input from the user through arguments or options. Space MVC makes it very convenient to define the input you expect from the user using the signature property on your commands. The signature property allows you to define the name, arguments, and options for the command in a single, expressive, route-like syntax.","title":"Defining Input Expectations"},{"location":"space-cli/#arguments","text":"All user supplied arguments and options are wrapped in curly braces. In the following example, the command defines one required argument: user: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user}\\'; You may also make arguments optional and define default values for arguments: // Optional argument... email:send {user?} // Optional argument with default value... email:send {user=foo}","title":"Arguments"},{"location":"space-cli/#options","text":"Options, like arguments, are another form of user input. Options are prefixed by two hyphens (--) when they are specified on the command line. There are two types of options: those that receive a value and those that don't. Options that don't receive a value serve as a boolean \"switch\". Let's take a look at an example of this type of option: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user} {--queue}\\'; In this example, the --queue switch may be specified when calling the Space command. If the --queue switch is passed, the value of the option will be true. Otherwise, the value will be false: php space email:send 1 --queue","title":"Options"},{"location":"space-cli/#options-with-values","text":"Next, let's take a look at an option that expects a value. If the user must specify a value for an option, suffix the option name with a = sign: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user} {--queue=}\\'; In this example, the user may pass a value for the option like so: php space email:send 1 --queue=default You may assign default values to options by specifying the default value after the option name. If no option value is passed by the user, the default value will be used: email:send {user} {--queue=default}","title":"Options With Values"},{"location":"space-cli/#option-shortcuts","text":"To assign a shortcut when defining an option, you may specify it before the option name and use a | delimiter to separate the shortcut from the full option name: email:send {user} {--Q|queue}","title":"Option Shortcuts"},{"location":"space-cli/#input-arrays","text":"If you would like to define arguments or options to expect array inputs, you may use the * character. First, let's take a look at an example that specifies an array argument: email:send {user*} When calling this method, the user arguments may be passed in order to the command line. For example, the following command will set the value of user to ['foo', 'bar']: php space email:send foo bar When defining an option that expects an array input, each option value passed to the command should be prefixed with the option name: email:send {user} {--id=*} php space email:send --id=1 --id=2","title":"Input Arrays"},{"location":"space-cli/#input-descriptions","text":"You may assign descriptions to input arguments and options by separating the parameter from the description using a colon. If you need a little extra room to define your command, feel free to spread the definition across multiple lines: /** * The name and signature of the console command. * * @var string */ protected $signature = \\'email:send {user : The ID of the user} {--queue= : Whether the job should be queued}\\';","title":"Input Descriptions"},{"location":"space-cli/#command-io","text":"","title":"Command I/O"},{"location":"space-cli/#retrieving-input","text":"While your command is executing, you will obviously need to access the values for the arguments and options accepted by your command. To do so, you may use the argument and option methods: /** * Execute the console command. * * @return mixed */ public function handle() { $userId = $this- argument(\\'user\\'); // } If you need to retrieve all of the arguments as an array, call the arguments method: $arguments = $this- arguments(); Options may be retrieved just as easily as arguments using the option method. To retrieve all of the options as an array, call the options method: // Retrieve a specific option... $queueName = $this- option(\\'queue\\'); // Retrieve all options... $options = $this- options(); If the argument or option does not exist, null will be returned.","title":"Retrieving Input"},{"location":"space-cli/#prompting-for-input","text":"In addition to displaying output, you may also ask the user to provide input during the execution of your command. The ask method will prompt the user with the given question, accept their input, and then return the user's input back to your command: /** * Execute the console command. * * @return mixed */ public function handle() { $name = $this- ask(\\'What is your name?\\'); } The secret method is similar to ask, but the user's input will not be visible to them as they type in the console. This method is useful when asking for sensitive information such as a password: $password = $this- secret(\\'What is the password?\\');","title":"Prompting For Input"},{"location":"space-cli/#asking-for-confirmation","text":"If you need to ask the user for a simple confirmation, you may use the confirm method. By default, this method will return false. However, if the user enters y or yes in response to the prompt, the method will return true. if ($this- confirm(\\'Do you wish to continue?\\')) { // }","title":"Asking For Confirmation"},{"location":"space-cli/#auto-completion","text":"The anticipate method can be used to provide auto-completion for possible choices. The user can still choose any answer, regardless of the auto-completion hints: $name = $this- anticipate(\\'What is your name?\\', [\\'Taylor\\', \\'Dayle\\']);","title":"Auto-Completion"},{"location":"space-cli/#multiple-choice-questions","text":"If you need to give the user a predefined set of choices, you may use the choice method. You may set the array index of the default value to be returned if no option is chosen: $name = $this- choice(\\'What is your name?\\', [\\'Taylor\\', \\'Dayle\\'], $defaultIndex);","title":"Multiple Choice Questions"},{"location":"space-cli/#writing-output","text":"To send output to the console, use the line, info, comment, question and error methods. Each of these methods will use appropriate ANSI colors for their purpose. For example, let's display some general information to the user. Typically, the info method will display in the console as green text: /** * Execute the console command. * * @return mixed */ public function handle() { $this- info(\\'Display this on the screen\\'); } To display an error message, use the error method. Error message text is typically displayed in red: $this- error(\\'Something went wrong!\\'); If you would like to display plain, uncolored console output, use the line method: $this- line(\\'Display this on the screen\\');","title":"Writing Output"},{"location":"space-cli/#table-layouts","text":"The table method makes it easy to correctly format multiple rows / columns of data. Just pass in the headers and rows to the method. The width and height will be dynamically calculated based on the given data: $headers = [\\'Name\\', \\'Email\\']; $users = App\\User::all([\\'name\\', \\'email\\'])- toArray(); $this- table($headers, $users);","title":"Table Layouts"},{"location":"space-cli/#progress-bars","text":"For long running tasks, it could be helpful to show a progress indicator. Using the output object, we can start, advance and stop the Progress Bar. First, define the total number of steps the process will iterate through. Then, advance the Progress Bar after processing each item: $users = App\\User::all(); $bar = $this- output- createProgressBar(count($users)); $bar- start(); foreach ($users as $user) { $this- performTask($user); $bar- advance(); } $bar- finish(); For more advanced options, check out the Symfony Progress Bar component documentation .","title":"Progress Bars"},{"location":"space-cli/#registering-commands","text":"Because of the load method call in your console kernel's commands method, all commands within the app/Console/Commands directory will automatically be registered with Space. In fact, you are free to make additional calls to the load method to scan other directories for Space commands: /** * Register the commands for the application. * * @return void */ protected function commands() { $this- load(__DIR__.\\'/Commands\\'); $this- load(__DIR__.\\'/MoreCommands\\'); // ... } You may also manually register commands by adding its class name to the $commands property of your app/Console/Kernel.php file. When Space boots, all the commands listed in this property will be resolved by the service container and registered with Space: protected $commands = [ Commands\\SendEmails::class ];","title":"Registering Commands"},{"location":"space-cli/#programmatically-executing-commands","text":"Sometimes you may wish to execute an Space command outside of the CLI. For example, you may wish to fire an Space command from a route or controller. You may use the call method on the Space facade to accomplish this. The call method accepts either the command's name or class as the first argument, and an array of command parameters as the second argument. The exit code will be returned: Route::get(\\'/foo\\', function () { $exitCode = Space::call(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]); // }); Using the queue method on the Space facade, you may even queue Space commands so they are processed in the background by your queue workers . Before using this method, make sure you have configured your queue and are running a queue listener: Route::get(\\'/foo\\', function () { Space::queue(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]); // }); You may also specify the connection or queue the Space command should be dispatched to: Space::queue(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ])- onConnection(\\'redis\\')- onQueue(\\'commands\\');","title":"Programmatically Executing Commands"},{"location":"space-cli/#passing-array-values","text":"If your command defines an option that accepts an array, you may pass an array of values to that option: Route::get(\\'/foo\\', function () { $exitCode = Space::call(\\'email:send\\', [ \\'user\\' = 1, \\'--id\\' = [5, 13] ]); });","title":"Passing Array Values"},{"location":"space-cli/#passing-boolean-values","text":"If you need to specify the value of an option that does not accept string values, such as the --force flag on the migrate:refresh command, you should pass true or false: $exitCode = Space::call(\\'migrate:refresh\\', [ \\'--force\\' = true, ]);","title":"Passing Boolean Values"},{"location":"space-cli/#calling-commands-from-other-commands","text":"Sometimes you may wish to call other commands from an existing Space command. You may do so using the call method. This call method accepts the command name and an array of command parameters: /** * Execute the console command. * * @return mixed */ public function handle() { $this- call(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]); // } If you would like to call another console command and suppress all of its output, you may use the callSilent method. The callSilent method has the same signature as the call method: $this- callSilent(\\'email:send\\', [ \\'user\\' = 1, \\'--queue\\' = \\'default\\' ]);","title":"Calling Commands From Other Commands"},{"location":"support-ticket/","text":"Submit a Support Ticket Please feel free to create a support ticket to ask for us for help anytime. Email Subject Message Submit Ticket","title":"Support ticket"},{"location":"validation/","text":"Validation Introduction Space MVC provides several different approaches to validate your application's incoming data. By default, Space MVC's base controller class uses a ValidatesRequests trait which provides a convenient method to validate incoming HTTP request with a variety of powerful validation rules. Validation Quickstart To learn about Space MVC's powerful validation features, let's look at a complete example of validating a form and displaying the error messages back to the user.","title":"Validation"},{"location":"validation/#validation","text":"","title":"Validation"},{"location":"validation/#introduction","text":"Space MVC provides several different approaches to validate your application's incoming data. By default, Space MVC's base controller class uses a ValidatesRequests trait which provides a convenient method to validate incoming HTTP request with a variety of powerful validation rules.","title":"Introduction"},{"location":"validation/#validation-quickstart","text":"To learn about Space MVC's powerful validation features, let's look at a complete example of validating a form and displaying the error messages back to the user.","title":"Validation Quickstart"},{"location":"views/","text":"Views Creating Views Looking for more information on how to write Blade templates? Check out the full Blade documentation to get started. Views contain the HTML served by your application and separate your controller / application logic from your presentation logic. Views are stored in the resources/views directory. A simple view might look something like this: !-- View stored in resources/views/greeting.blade.php -- html body h1 Hello, {{ $name }} /h1 /body /html Since this view is stored at resources/views/greeting.blade.php, we may return it using the global view helper like so: Route::get('/', function () { return view('greeting', ['name' = 'James']); }); As you can see, the first argument passed to the view helper corresponds to the name of the view file in the resources/views directory. The second argument is an array of data that should be made available to the view. In this case, we are passing the name variable, which is displayed in the view using Blade syntax . Of course, views may also be nested within sub-directories of the resources/views directory. \"Dot\" notation may be used to reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php, you may reference it like so: return view('admin.profile', $data); Determining If A View Exists If you need to determine if a view exists, you may use the View facade. The exists method will return true if the view exists: use Illuminate\\Support\\Facades\\View; if (View::exists('emails.customer')) { // } Creating The First Available View Using the first method, you may create the first view that exists in a given array of views. This is useful if your application or package allows views to be customized or overwritten: return view()- first(['custom.admin', 'admin'], $data); Of course, you may also call this method via the View facade : use Illuminate\\Support\\Facades\\View; return View::first(['custom.admin', 'admin'], $data); Passing Data To Views As you saw in the previous examples, you may pass an array of data to views: return view('greetings', ['name' = 'Victoria']); When passing information in this manner, the data should be an array with key / value pairs. Inside your view, you can then access each value using its corresponding key, such as ?php echo $key; ? . As an alternative to passing a complete array of data to the view helper function, you may use the with method to add individual pieces of data to the view: return view('greeting')- with('name', 'Victoria'); Sharing Data With All Views Occasionally, you may need to share a piece of data with all views that are rendered by your application. You may do so using the view facade's share method. Typically, you should place calls to share within a service provider's boot method. You are free to add them to the AppServiceProvider or generate a separate service provider to house them: ?php namespace App\\Providers; use Illuminate\\Support\\Facades\\View; class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { View::share('key', 'value'); } /** * Register the service provider. * * @return void */ public function register() { // } } View Composers View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single location. For this example, let's register the view composers within a service provider . We'll use the View facade to access the underlying Illuminate\\Contracts\\View\\Factory contract implementation. Remember, Space MVC does not include a default directory for view composers. You are free to organize them however you wish. For example, you could create an app/Http/ViewComposers directory: ?php namespace App\\Providers; use Illuminate\\Support\\Facades\\View; use Illuminate\\Support\\ServiceProvider; class ComposerServiceProvider extends ServiceProvider { /** * Register bindings in the container. * * @return void */ public function boot() { // Using class based composers... View::composer( 'profile', 'App\\Http\\ViewComposers\\ProfileComposer' ); // Using Closure based composers... View::composer('dashboard', function ($view) { // }); } /** * Register the service provider. * * @return void */ public function register() { // } } Remember, if you create a new service provider to contain your view composer registrations, you will need to add the service provider to the providers array in the config/app.php configuration file. Now that we have registered the composer, the ProfileComposer@compose method will be executed each time the profile view is being rendered. So, let's define the composer class: ?php namespace App\\Http\\ViewComposers; use Illuminate\\View\\View; use App\\Repositories\\UserRepository; class ProfileComposer { /** * The user repository implementation. * * @var UserRepository */ protected $users; /** * Create a new profile composer. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { // Dependencies automatically resolved by service container... $this- users = $users; } /** * Bind data to the view. * * @param View $view * @return void */ public function compose(View $view) { $view- with('count', $this- users- count()); } } Just before the view is rendered, the composer's compose method is called with the Illuminate\\View\\View instance. You may use the with method to bind data to the view. All view composers are resolved via the service container , so you may type-hint any dependencies you need within a composer's constructor. Attaching A Composer To Multiple Views You may attach a view composer to multiple views at once by passing an array of views as the first argument to the composer method: View::composer( ['profile', 'dashboard'], 'App\\Http\\ViewComposers\\MyViewComposer' ); The composer method also accepts the * character as a wildcard, allowing you to attach a composer to all views: View::composer('*', function ($view) { // }); View Creators View creators are very similar to view composers; however, they are executed immediately after the view is instantiated instead of waiting until the view is about to render. To register a view creator, use the creator method: View::creator('profile', 'App\\Http\\ViewCreators\\ProfileCreator');","title":"Views"},{"location":"views/#views","text":"","title":"Views"},{"location":"views/#creating-views","text":"Looking for more information on how to write Blade templates? Check out the full Blade documentation to get started. Views contain the HTML served by your application and separate your controller / application logic from your presentation logic. Views are stored in the resources/views directory. A simple view might look something like this: !-- View stored in resources/views/greeting.blade.php -- html body h1 Hello, {{ $name }} /h1 /body /html Since this view is stored at resources/views/greeting.blade.php, we may return it using the global view helper like so: Route::get('/', function () { return view('greeting', ['name' = 'James']); }); As you can see, the first argument passed to the view helper corresponds to the name of the view file in the resources/views directory. The second argument is an array of data that should be made available to the view. In this case, we are passing the name variable, which is displayed in the view using Blade syntax . Of course, views may also be nested within sub-directories of the resources/views directory. \"Dot\" notation may be used to reference nested views. For example, if your view is stored at resources/views/admin/profile.blade.php, you may reference it like so: return view('admin.profile', $data);","title":"Creating Views"},{"location":"views/#determining-if-a-view-exists","text":"If you need to determine if a view exists, you may use the View facade. The exists method will return true if the view exists: use Illuminate\\Support\\Facades\\View; if (View::exists('emails.customer')) { // }","title":"Determining If A View Exists"},{"location":"views/#creating-the-first-available-view","text":"Using the first method, you may create the first view that exists in a given array of views. This is useful if your application or package allows views to be customized or overwritten: return view()- first(['custom.admin', 'admin'], $data); Of course, you may also call this method via the View facade : use Illuminate\\Support\\Facades\\View; return View::first(['custom.admin', 'admin'], $data);","title":"Creating The First Available View"},{"location":"views/#passing-data-to-views","text":"As you saw in the previous examples, you may pass an array of data to views: return view('greetings', ['name' = 'Victoria']); When passing information in this manner, the data should be an array with key / value pairs. Inside your view, you can then access each value using its corresponding key, such as ?php echo $key; ? . As an alternative to passing a complete array of data to the view helper function, you may use the with method to add individual pieces of data to the view: return view('greeting')- with('name', 'Victoria');","title":"Passing Data To Views"},{"location":"views/#sharing-data-with-all-views","text":"Occasionally, you may need to share a piece of data with all views that are rendered by your application. You may do so using the view facade's share method. Typically, you should place calls to share within a service provider's boot method. You are free to add them to the AppServiceProvider or generate a separate service provider to house them: ?php namespace App\\Providers; use Illuminate\\Support\\Facades\\View; class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { View::share('key', 'value'); } /** * Register the service provider. * * @return void */ public function register() { // } }","title":"Sharing Data With All Views"},{"location":"views/#view-composers","text":"View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organize that logic into a single location. For this example, let's register the view composers within a service provider . We'll use the View facade to access the underlying Illuminate\\Contracts\\View\\Factory contract implementation. Remember, Space MVC does not include a default directory for view composers. You are free to organize them however you wish. For example, you could create an app/Http/ViewComposers directory: ?php namespace App\\Providers; use Illuminate\\Support\\Facades\\View; use Illuminate\\Support\\ServiceProvider; class ComposerServiceProvider extends ServiceProvider { /** * Register bindings in the container. * * @return void */ public function boot() { // Using class based composers... View::composer( 'profile', 'App\\Http\\ViewComposers\\ProfileComposer' ); // Using Closure based composers... View::composer('dashboard', function ($view) { // }); } /** * Register the service provider. * * @return void */ public function register() { // } } Remember, if you create a new service provider to contain your view composer registrations, you will need to add the service provider to the providers array in the config/app.php configuration file. Now that we have registered the composer, the ProfileComposer@compose method will be executed each time the profile view is being rendered. So, let's define the composer class: ?php namespace App\\Http\\ViewComposers; use Illuminate\\View\\View; use App\\Repositories\\UserRepository; class ProfileComposer { /** * The user repository implementation. * * @var UserRepository */ protected $users; /** * Create a new profile composer. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) { // Dependencies automatically resolved by service container... $this- users = $users; } /** * Bind data to the view. * * @param View $view * @return void */ public function compose(View $view) { $view- with('count', $this- users- count()); } } Just before the view is rendered, the composer's compose method is called with the Illuminate\\View\\View instance. You may use the with method to bind data to the view. All view composers are resolved via the service container , so you may type-hint any dependencies you need within a composer's constructor.","title":"View Composers"},{"location":"views/#attaching-a-composer-to-multiple-views","text":"You may attach a view composer to multiple views at once by passing an array of views as the first argument to the composer method: View::composer( ['profile', 'dashboard'], 'App\\Http\\ViewComposers\\MyViewComposer' ); The composer method also accepts the * character as a wildcard, allowing you to attach a composer to all views: View::composer('*', function ($view) { // });","title":"Attaching A Composer To Multiple Views"},{"location":"views/#view-creators","text":"View creators are very similar to view composers; however, they are executed immediately after the view is instantiated instead of waiting until the view is about to render. To register a view creator, use the creator method: View::creator('profile', 'App\\Http\\ViewCreators\\ProfileCreator');","title":"View Creators"},{"location":"what-is-git/","text":"What is Git? By far, the most widely used modern development code backup and history version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments). In short Git is used to backup a copy of your website code online in its original source code state. You can setup git to use private repositories or public repositories to store you data. You can also allow multiple developers to work from your github repositories (project backups). A Private repository will allow for only users you choose to download and develop on your code A Public Repository will allow the general public to view and download your code The main benefit of using git is that multiple developers can work on the same project at the same time and they will pull and push code to and from git Git acts as a centralized location for your code so you can develop as a team more easily What is source tree? In general when using the default git commands this is usually done via the command line or terminal, yet this can be harder to learn for first time users. There programs such as source tree available which offer a graphical user interface to make git easier to use. How to install source tree?","title":"What is Git?"},{"location":"what-is-git/#what-is-git","text":"By far, the most widely used modern development code backup and history version control system in the world today is Git. Git is a mature, actively maintained open source project originally developed in 2005 by Linus Torvalds, the famous creator of the Linux operating system kernel. A staggering number of software projects rely on Git for version control, including commercial projects as well as open source. Developers who have worked with Git are well represented in the pool of available software development talent and it works well on a wide range of operating systems and IDEs (Integrated Development Environments). In short Git is used to backup a copy of your website code online in its original source code state. You can setup git to use private repositories or public repositories to store you data. You can also allow multiple developers to work from your github repositories (project backups). A Private repository will allow for only users you choose to download and develop on your code A Public Repository will allow the general public to view and download your code The main benefit of using git is that multiple developers can work on the same project at the same time and they will pull and push code to and from git Git acts as a centralized location for your code so you can develop as a team more easily","title":"What is Git?"},{"location":"what-is-git/#what-is-source-tree","text":"In general when using the default git commands this is usually done via the command line or terminal, yet this can be harder to learn for first time users. There programs such as source tree available which offer a graphical user interface to make git easier to use.","title":"What is source tree?"},{"location":"what-is-git/#how-to-install-source-tree","text":"","title":"How to install source tree?"},{"location":"what-is-php-storm/","text":"What is an Code Development IDE? An integrated development environment (IDE) is a software suite that consolidates basic tools required to write and test software. Developers use numerous tools throughout software code creation, building and testing. Development tools often include text editors, code libraries, compilers and test platforms. Without an IDE, a developer must select, deploy, integrate and manage all of these tools separately. An IDE brings many of those development-related tools together as a single framework, application or service. The integrated toolset is designed to simplify software development and can identify and minimize coding mistakes and typos. Integrated development environments are designed to maximize programmer productivity by providing tight-knit components with similar user interfaces. IDEs present a single program in which all development is done. This program typically provides many features for authoring, modifying, compiling, deploying and debugging software. Some IDEs are dedicated to a specific programming language, allowing a feature set that most closely matches the programming paradigms of the language. However, there are many multiple-language IDEs. PHP Storm IDE Php storm is a very common and popularly used PHP IDE developers use everyday to developer php code How to install PHP Storm IDE","title":"What is PHP Storm IDE?"},{"location":"what-is-php-storm/#what-is-an-code-development-ide","text":"An integrated development environment (IDE) is a software suite that consolidates basic tools required to write and test software. Developers use numerous tools throughout software code creation, building and testing. Development tools often include text editors, code libraries, compilers and test platforms. Without an IDE, a developer must select, deploy, integrate and manage all of these tools separately. An IDE brings many of those development-related tools together as a single framework, application or service. The integrated toolset is designed to simplify software development and can identify and minimize coding mistakes and typos. Integrated development environments are designed to maximize programmer productivity by providing tight-knit components with similar user interfaces. IDEs present a single program in which all development is done. This program typically provides many features for authoring, modifying, compiling, deploying and debugging software. Some IDEs are dedicated to a specific programming language, allowing a feature set that most closely matches the programming paradigms of the language. However, there are many multiple-language IDEs.","title":"What is an Code Development IDE?"},{"location":"what-is-php-storm/#php-storm-ide","text":"Php storm is a very common and popularly used PHP IDE developers use everyday to developer php code","title":"PHP Storm IDE"},{"location":"what-is-php-storm/#how-to-install-php-storm-ide","text":"","title":"How to install PHP Storm IDE"},{"location":"what-is-wamp/","text":"What does Wamp mean? WAMP is sometimes used as an abbreviated name for the software stack Windows, Apache, MySQL, PHP. It is derived from LAMP which stands for Linux, Apache, MySQL, and PHP. As the name implies, while LAMP is used on Linux servers, WAMP is used on Windows servers. The Apple OSX abbreviation is MAMP for Mac, Apache, Mysql and PHP. The \"A\" in WAMP stands for Apache. Apache is server software that is used to serve webpages. Whenever someone types in your website\u2019s URL, Apache is the software that \"serves\" your website. The \"M\" in WAMP stands for MySQL. MySQL is a database management system. It\u2019s job in the software stack is to store all of your website\u2019s content, user profiles, comments, etc. The \"P\" in WAMP stands for PHP. PHP is the programming language that Space MVC is written in. It is also the piece that holds the entire software stack together. It runs as a process in Apache and communicates with the MySQL database to dynamically build your webpages. WAMP software stack can be downloaded from wampserver project\u2019s download page. What is the Wamp Server Application? You can install mysql, apache, php on your computer manually one by one or you can use the wamp server program created by http://www.wampserver.com to make it easy as it is an all in one application. How to Install the Wamp Server Application? This video shows wamp at php version 5.4, newer versions of wamp will automatically install php 5.6 and php 7 as of this year 2018 Select the latest 32bit or 64bit version for your windows computer Note: If you are using apple we recommend you install Mamp Pro or Mamp. If you are using Linux Lamp is usually already installed or you can use 'tasksel' on the command line","title":"What is Wamp?"},{"location":"what-is-wamp/#what-does-wamp-mean","text":"WAMP is sometimes used as an abbreviated name for the software stack Windows, Apache, MySQL, PHP. It is derived from LAMP which stands for Linux, Apache, MySQL, and PHP. As the name implies, while LAMP is used on Linux servers, WAMP is used on Windows servers. The Apple OSX abbreviation is MAMP for Mac, Apache, Mysql and PHP. The \"A\" in WAMP stands for Apache. Apache is server software that is used to serve webpages. Whenever someone types in your website\u2019s URL, Apache is the software that \"serves\" your website. The \"M\" in WAMP stands for MySQL. MySQL is a database management system. It\u2019s job in the software stack is to store all of your website\u2019s content, user profiles, comments, etc. The \"P\" in WAMP stands for PHP. PHP is the programming language that Space MVC is written in. It is also the piece that holds the entire software stack together. It runs as a process in Apache and communicates with the MySQL database to dynamically build your webpages. WAMP software stack can be downloaded from wampserver project\u2019s download page.","title":"What does Wamp mean?"},{"location":"what-is-wamp/#what-is-the-wamp-server-application","text":"You can install mysql, apache, php on your computer manually one by one or you can use the wamp server program created by http://www.wampserver.com to make it easy as it is an all in one application.","title":"What is the Wamp Server Application?"},{"location":"what-is-wamp/#how-to-install-the-wamp-server-application","text":"This video shows wamp at php version 5.4, newer versions of wamp will automatically install php 5.6 and php 7 as of this year 2018 Select the latest 32bit or 64bit version for your windows computer Note: If you are using apple we recommend you install Mamp Pro or Mamp. If you are using Linux Lamp is usually already installed or you can use 'tasksel' on the command line","title":"How to Install the Wamp Server Application?"}]}